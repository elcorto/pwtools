<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pwtools.pwscf &#8212; pwtools  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=3b47c8d5" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo" />
    
    <h1 class="logo logo-name">pwtools</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=elcorto&repo=pwtools&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/index.html">API Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../written/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/background/index.html">Background, details, special topics</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pwtools.pwscf</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Some handy tools to construct strings for building pwscf input files.</span>
<span class="sd">Readers for QE postprocessing tool output (matdyn.x, dynmat.x).&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">re</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pwtools.common</span> <span class="kn">import</span> <span class="n">fix_eps</span><span class="p">,</span> <span class="n">str_arr</span><span class="p">,</span> <span class="n">file_readlines</span><span class="p">,</span> <span class="n">pj</span>
<span class="kn">from</span> <span class="nn">pwtools</span> <span class="kn">import</span> <span class="n">parse</span><span class="p">,</span> <span class="n">crys</span><span class="p">,</span> <span class="n">common</span>
<span class="kn">from</span> <span class="nn">pwtools.num</span> <span class="kn">import</span> <span class="n">EPS</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sin</span><span class="p">,</span> <span class="n">acos</span><span class="p">,</span> <span class="n">sqrt</span>

<div class="viewcode-block" id="atpos_str">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.atpos_str.html#pwtools.pwscf.atpos_str">[docs]</a>
<span class="k">def</span> <span class="nf">atpos_str</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%.16e</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">zero_eps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">EPS</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="s1">&#39; &#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience function to make a string for the ATOMIC_POSITIONS section</span>
<span class="sd">    of a pw.x input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symbols : sequence</span>
<span class="sd">        strings with atom symbols, (natoms,), must match with the</span>
<span class="sd">        rows of coords</span>
<span class="sd">    coords : array (natoms, 3)</span>
<span class="sd">        with atomic coords, can also be (natoms, &gt;3) to add constraints on</span>
<span class="sd">        atomic forces in PWscf</span>
<span class="sd">    eps : float</span>
<span class="sd">        Print values as 0.0 where abs(coords[i,j]) &lt; eps. If eps &lt; 0.0, then</span>
<span class="sd">        disable this.</span>
<span class="sd">    delim : str</span>
<span class="sd">        delimiter between columns</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; print atpos_str([&#39;Al&#39;, &#39;N&#39;], array([[0,0,0], [0,0,1.]]))</span>
<span class="sd">    Al      0.0000000000    0.0000000000    0.0000000000</span>
<span class="sd">    N       0.0000000000    0.0000000000    1.0000000000</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">zero_eps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`zero_eps` is deprecated, use `eps` &gt; 0 instead&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;len(symbols) != coords.shape[0]&quot;</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s%s%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">delim</span><span class="p">,</span> <span class="n">str_arr</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="n">fmt</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">eps</span><span class="p">,</span>
                                                          <span class="n">delim</span><span class="o">=</span><span class="n">delim</span><span class="p">))</span> \
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">txt</span></div>



<div class="viewcode-block" id="atpos_str_fast">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.atpos_str_fast.html#pwtools.pwscf.atpos_str_fast">[docs]</a>
<span class="k">def</span> <span class="nf">atpos_str_fast</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Fast version of atpos_str() for usage in loops. We use a fixed string</span>
<span class="sd">    dtype ``U32`` to convert the array `coords` to string form. We also avoid</span>
<span class="sd">    all asserts for speed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symbols : list of strings with atom symbols, (natoms,), must match with the</span>
<span class="sd">        rows of coords</span>
<span class="sd">    coords : array (natoms, 3) with atomic coords, can also be (natoms, &gt;3) to</span>
<span class="sd">        add constraints on atomic forces in PWscf</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The string dtype + flatten trick used here is the fastest way to convert a</span>
<span class="sd">    numpy array to string. However the number of digits is limited to 32 chars.</span>
<span class="sd">    We use 32 b/c</span>

<span class="sd">    &gt;&gt;&gt; array([pi]*2).astype(&#39;U&#39;)</span>
<span class="sd">    array([&#39;3.141592653589793&#39;, &#39;3.141592653589793&#39;], dtype=&#39;&lt;U32&#39;)</span>

<span class="sd">    ``&lt;`` means little endian and is based on the machine arch automatically.</span>

<span class="sd">    Needs about 1/3 of the time of :func:`atpos_str`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ncols</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;U32&#39;</span><span class="p">)</span>
    <span class="n">arr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbols</span>
    <span class="n">arr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">coords</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;  &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">ncols</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">*</span><span class="n">nrows</span> <span class="o">%</span><span class="nb">tuple</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">txt</span></div>



<div class="viewcode-block" id="atspec_str">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.atspec_str.html#pwtools.pwscf.atspec_str">[docs]</a>
<span class="k">def</span> <span class="nf">atspec_str</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">masses</span><span class="p">,</span> <span class="n">pseudos</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convenience function to make a string for the ATOMIC_SPECIES section</span>
<span class="sd">    of a pw.x input file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    symbols : sequence of strings with atom symbols, (natoms,)</span>
<span class="sd">    masses : sequence of floats (natoms,) w/ atom masses</span>
<span class="sd">    pseudos : sequence of strings (natoms,) w/ pseudopotential file names</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    string</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt;  print pwscf.atspec_str([&#39;Al&#39;, &#39;N&#39;], [&#39;1.23&#39;, &#39;2.34&#39;], [&#39;Al.UPF&#39;, &#39;N.UPF&#39;])</span>
<span class="sd">    Al      1.23    Al.UPF</span>
<span class="sd">    N       2.34    N.UPF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">masses</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">pseudos</span><span class="p">),</span> \
        <span class="s2">&quot;len(symbols) != len(masses) != len(pseudos)&quot;</span>
    <span class="n">txt</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">mass</span><span class="p">),</span> <span class="n">pp</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span><span class="p">,</span> <span class="n">mass</span><span class="p">,</span> <span class="n">pp</span> <span class="ow">in</span>
    <span class="nb">zip</span><span class="p">(</span><span class="n">symbols</span><span class="p">,</span> <span class="n">masses</span><span class="p">,</span> <span class="n">pseudos</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">txt</span></div>



<div class="viewcode-block" id="kpoints_str">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.kpoints_str.html#pwtools.pwscf.kpoints_str">[docs]</a>
<span class="k">def</span> <span class="nf">kpoints_str</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="s1">&#39;nk&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;[3,3,3] -&gt; &quot;nk1=3,nk2=3,nk3=3&quot;</span>

<span class="sd">    Useful for QE&#39;s phonon toolchain ph.x, q2r.x, matdyn.x</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%s%i</span><span class="s1">=</span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lst</span><span class="p">)])</span></div>

<span class="n">kpointstr</span> <span class="o">=</span> <span class="n">kpoints_str</span>


<div class="viewcode-block" id="kpoints_str_pwin">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.kpoints_str_pwin.html#pwtools.pwscf.kpoints_str_pwin">[docs]</a>
<span class="k">def</span> <span class="nf">kpoints_str_pwin</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;[3,3,3] -&gt; &quot; 3 3 3 0 0 0&quot;</span>
<span class="sd">    Useful for pwscf input files, card K_POINTS.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lst : sequence (3,)</span>
<span class="sd">    shift : sequence (3,), optional</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">lst</span><span class="o">+</span><span class="n">shift</span><span class="p">))</span></div>

<span class="n">kpointstr_pwin</span> <span class="o">=</span> <span class="n">kpoints_str_pwin</span>


<div class="viewcode-block" id="kpoints_str_pwin_full">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.kpoints_str_pwin_full.html#pwtools.pwscf.kpoints_str_pwin_full">[docs]</a>
<span class="k">def</span> <span class="nf">kpoints_str_pwin_full</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">gamma</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Full k-points string for pw.x input files, card K_POINTS.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lst : sequence (3,)</span>
<span class="sd">    shift : sequence (3,), optional</span>
<span class="sd">    gamma : bool, optional</span>
<span class="sd">        If lst == [1,1,1] then return &quot;K_POINTS gamma&quot;, else</span>
<span class="sd">        &quot;K_POINTS automatic &lt;newline&gt; 1 1 1 &lt;`shift`&gt;&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="n">lst</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">list</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lst</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">gamma</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">lst</span> <span class="o">==</span> <span class="s1">&#39;gamma&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;K_POINTS gamma&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;K_POINTS automatic</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span>  <span class="o">%</span><span class="n">kpointstr_pwin</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span></div>

<span class="n">kpointstr_pwin2</span> <span class="o">=</span> <span class="n">kpoints_str_pwin_full</span>


<div class="viewcode-block" id="bool2str">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.bool2str.html#pwtools.pwscf.bool2str">[docs]</a>
<span class="k">def</span> <span class="nf">bool2str</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return Fortran bool string for bool input.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39;.true.&#39;</span> <span class="k">if</span> <span class="n">x</span> <span class="k">else</span> <span class="s1">&#39;.false.&#39;</span></div>



<div class="viewcode-block" id="read_matdyn_modes">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.read_matdyn_modes.html#pwtools.pwscf.read_matdyn_modes">[docs]</a>
<span class="k">def</span> <span class="nf">read_matdyn_modes</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">natoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse modes file produced by QE&#39;s matdyn.x.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        File to parse (usually &quot;matdyn.modes&quot;)</span>
<span class="sd">    natoms : int</span>
<span class="sd">        Number of atoms.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qpoints, freqs, vecs</span>
<span class="sd">    qpoints : 2d array (nqpoints, 3)</span>
<span class="sd">        All qpoints on the grid.</span>
<span class="sd">    freqs : 2d array, (nqpoints, nmodes) where nmodes = 3*natoms</span>
<span class="sd">        Each row: 3*natoms phonon frequencies in [cm^-1] at each q-point.</span>
<span class="sd">    vecs : 4d complex array (nqpoints, nmodes, natoms, 3)</span>
<span class="sd">        Complex eigenvectors of the dynamical matrix for each q-point.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; qpoints,freqs,vecs=read_matdyn_modes(&#39;matdyn.modes&#39;,natoms=27)</span>
<span class="sd">    # how many q-points? -&gt; 8</span>
<span class="sd">    &gt;&gt;&gt; qpoints.shape</span>
<span class="sd">    (8,3)</span>
<span class="sd">    # 1st q-point in file, mode #3 (out of 3*27) -&gt; vectors on all 27 atoms</span>
<span class="sd">    &gt;&gt;&gt; vecs[0,2,...].shape</span>
<span class="sd">    (27,3)</span>
<span class="sd">    # 1st q-point in file, mode #3, vector on atom #15</span>
<span class="sd">    &gt;&gt;&gt; vecs[0,2,14,:].real</span>
<span class="sd">    array([-0.010832,  0.026063, -0.089511])</span>
<span class="sd">    &gt;&gt;&gt; vecs[0,2,14,:].imag</span>
<span class="sd">    array([ 0.,  0.,  0.])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The file to be parsed looks like this::</span>

<span class="sd">           diagonalizing the dynamical matrix ...</span>

<span class="sd">       q =       0.0000      0.0000      0.0000</span>
<span class="sd">       **************************************************************************</span>
<span class="sd">           omega( 1) =     -26.663631 [THz] =    -889.402992 [cm-1]</span>
<span class="sd">       ( -0.218314   0.000000    -0.025643   0.000000    -0.116601   0.000000   )</span>
<span class="sd">       ( -0.086633   0.000000     0.108966   0.000000    -0.066513   0.000000   )</span>
<span class="sd">      [... natoms lines: x_real x_imag y_real y_imag z_real z_imag ... until</span>
<span class="sd">       next omega ...]</span>
<span class="sd">           omega( 2) =     -16.330246 [THz] =    -544.718372 [cm-1]</span>
<span class="sd">       (  0.172149   0.000000     0.008336   0.000000    -0.121991   0.000000   )</span>
<span class="sd">       ( -0.061497   0.000000     0.003782   0.000000    -0.018304   0.000000   )</span>
<span class="sd">      [... until omega(3*natoms) ...]</span>
<span class="sd">       **************************************************************************</span>
<span class="sd">           diagonalizing the dynamical matrix ...</span>

<span class="sd">      [... until next q-point ...]</span>
<span class="sd">       q =       0.0000      0.0000     -0.5000</span>
<span class="sd">       **************************************************************************</span>
<span class="sd">           omega( 1) =     -24.881828 [THz] =    -829.968443 [cm-1]</span>
<span class="sd">       ( -0.225020   0.000464    -0.031584   0.000061    -0.130217   0.000202   )</span>
<span class="sd">       ( -0.085499   0.000180     0.107383  -0.000238    -0.086854   0.000096   )</span>
<span class="sd">      [...]</span>
<span class="sd">       **************************************************************************</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">natoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;grep &#39;q.*=&#39; </span><span class="si">%s</span><span class="s2"> | sed -re &#39;s/.*q\s*=(.*)/\1/&#39;&quot;</span> <span class="o">%</span><span class="n">filename</span>
    <span class="n">qpoints</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">arr2d_from_txt</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
    <span class="n">nqpoints</span> <span class="o">=</span> <span class="n">qpoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nmodes</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">natoms</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;grep &#39;^[ ]*(&#39; </span><span class="si">%s</span><span class="s2"> | sed -re &#39;s/^\s*\((.*)\)/\1/g&#39;&quot;</span> <span class="o">%</span><span class="n">filename</span>
    <span class="c1"># vecs_file_flat: (nqpoints * nmodes * natoms, 6)</span>
    <span class="c1"># this line is the bottleneck</span>
    <span class="n">vecs_file_flat</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">arr2d_from_txt</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
    <span class="n">vecs_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">vecs_file_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">vecs_flat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vecs_flat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">vecs_flat</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">vecs_flat</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nqpoints</span><span class="p">,</span> <span class="n">nmodes</span><span class="p">,</span> <span class="n">natoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;grep omega </span><span class="si">%s</span><span class="s2"> | sed -re </span><span class="se">\</span>
<span class="s2">            &#39;s/.*omega.*=.*\[.*=(.*)\s*\[.*/\1/g&#39;&quot;</span> <span class="o">%</span><span class="n">filename</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">nqpoints</span><span class="p">,</span> <span class="n">nmodes</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">qpoints</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">vecs</span></div>



<div class="viewcode-block" id="read_dyn">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.read_dyn.html#pwtools.pwscf.read_dyn">[docs]</a>
<span class="k">def</span> <span class="nf">read_dyn</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">natoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read one dynamical matrix file (for 1 qpoint) produced by ``ph.x`` and</span>
<span class="sd">    extract the same as :func:`read_matdyn_modes` for this qpoint only.</span>

<span class="sd">    All arrays have one dim less compared to :func:`read_matdyn_modes`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        Name of dyn file. Example: &quot;ph.dyn3&quot; for qpoint 3.</span>
<span class="sd">    natoms : int</span>
<span class="sd">        number of atoms in the cell (used for nmodes=3*natoms only)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qpoints, freqs, vecs</span>
<span class="sd">    qpoints : 1d array (3,)</span>
<span class="sd">        The qpoint of the dyn file.</span>
<span class="sd">    freqs : 1d array, (nmodes,) where nmodes = 3*natoms</span>
<span class="sd">        3*natoms phonon frequencies in [cm^-1] at the q-point.</span>
<span class="sd">    vecs : 3d complex array (nmodes, natoms, 3)</span>
<span class="sd">        Complex eigenvectors of the dynamical matrix for the q-point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">natoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;egrep &#39;q.*=.*\(&#39; </span><span class="si">%s</span><span class="s2"> | tail -n1 | sed -re &#39;s/.*q\s*=.*\((.*)\)/\1/&#39;&quot;</span> <span class="o">%</span><span class="n">filename</span>
    <span class="n">qpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">qpoints</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
    <span class="n">nmodes</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">natoms</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;grep -v &#39;q.*=&#39; </span><span class="si">%s</span><span class="s2"> | grep &#39;^[ ]*(&#39; | sed -re &#39;s/^\s*\((.*)\)/\1/g&#39;&quot;</span> <span class="o">%</span><span class="n">filename</span>
    <span class="c1"># vecs_file_flat: (nmodes * natoms, 6)</span>
    <span class="c1"># this line is the bottleneck</span>
    <span class="n">vecs_file_flat</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">arr2d_from_txt</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
    <span class="n">vecs_flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">vecs_file_flat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">vecs_flat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vecs_flat</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">vecs_flat</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">vecs_file_flat</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">vecs_flat</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmodes</span><span class="p">,</span> <span class="n">natoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;grep omega </span><span class="si">%s</span><span class="s2"> | sed -re </span><span class="se">\</span>
<span class="s2">            &#39;s/.*omega.*=.*\[.*=(.*)\s*\[.*/\1/g&#39;&quot;</span> <span class="o">%</span><span class="n">filename</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qpoints</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">vecs</span></div>



<div class="viewcode-block" id="read_all_dyn">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.read_all_dyn.html#pwtools.pwscf.read_all_dyn">[docs]</a>
<span class="k">def</span> <span class="nf">read_all_dyn</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nqpoints</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">natoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="s1">&#39;ph.dyn&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as :func:`read_matdyn_modes()`, but instead of the file</span>
<span class="sd">    ``matdyn.modes`` which contains freqs,vecs for all qpoints, we read all</span>
<span class="sd">    dynamical matrix files in `path`, one per qpoint.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str</span>
<span class="sd">        Path where dyn files live.</span>
<span class="sd">    nqpoints : int</span>
<span class="sd">        number of dyn files (e.g. 5 for &quot;ph.dyn1&quot;, ..., &quot;ph.dyn5&quot; if</span>
<span class="sd">        ``base=&#39;ph.dyn&#39;``)</span>
<span class="sd">    natoms : int</span>
<span class="sd">    base : str</span>
<span class="sd">        Basename of the dyn files.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (qpoint,freqs,vecs)</span>
<span class="sd">        Same as :func:`read_matdyn_modes`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nmodes</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">natoms</span>
    <span class="n">qpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nqpoints</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nqpoints</span><span class="p">,</span> <span class="n">nmodes</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nqpoints</span><span class="p">,</span> <span class="n">nmodes</span><span class="p">,</span> <span class="n">natoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iq</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nqpoints</span><span class="p">):</span>
        <span class="n">filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s%i</span><span class="s1">&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">iq</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">qq</span><span class="p">,</span> <span class="n">ff</span><span class="p">,</span> <span class="n">vv</span> <span class="o">=</span> <span class="n">read_dyn</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">natoms</span><span class="o">=</span><span class="n">natoms</span><span class="p">)</span>
        <span class="n">qpoints</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">qq</span>
        <span class="n">freqs</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">ff</span>
        <span class="n">vecs</span><span class="p">[</span><span class="n">iq</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">vv</span>
    <span class="k">return</span> <span class="n">qpoints</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">vecs</span></div>



<div class="viewcode-block" id="read_dynmat">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.read_dynmat.html#pwtools.pwscf.read_dynmat">[docs]</a>
<span class="k">def</span> <span class="nf">read_dynmat</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">natoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">&#39;dynmat.out&#39;</span><span class="p">,</span> <span class="n">axsf</span><span class="o">=</span><span class="s1">&#39;dynmat.axsf&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read ``dynmat.x`` output.</span>

<span class="sd">    `freqs` are parsed from `filename` and `vecs` from `axsf`. `qpoints` is</span>
<span class="sd">    alawys Gamma, i.e. [0,0,0].</span>

<span class="sd">    Output format is the same as in :func:`read_dyn`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path : str</span>
<span class="sd">        path where output files are</span>
<span class="sd">    natoms : int</span>
<span class="sd">    filename : str</span>
<span class="sd">        Text output from dynmat.x, where the frequencies are printed, relative</span>
<span class="sd">        to `path`.</span>
<span class="sd">    axsf : str</span>
<span class="sd">        AXSF file (``filxsf`` in input) with mode vectors as forces.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qpoints, freqs, vecs</span>
<span class="sd">    qpoints : 1d array (3,)</span>
<span class="sd">        The qpoint, which is Gamma, i.e. [0,0,0]</span>
<span class="sd">    freqs : 1d array, (nmodes,) where nmodes = 3*natoms</span>
<span class="sd">        3*natoms phonon frequencies in [cm^-1] at the q-point.</span>
<span class="sd">    vecs : 3d real array (nmodes, natoms, 3)</span>
<span class="sd">        Real parts (???) if the eigenvectors of the dynamical matrix for the</span>
<span class="sd">        q-point.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    We assume the output to be generated with ``dynmat.x &lt; dynmat.in &gt;</span>
<span class="sd">    dynmat.out``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">natoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;natoms is None&quot;</span><span class="p">)</span>
    <span class="n">nmodes</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">natoms</span>
    <span class="n">out_fn</span> <span class="o">=</span> <span class="n">pj</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">axsf_fn</span> <span class="o">=</span> <span class="n">pj</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">axsf</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;grep -A</span><span class="si">{0}</span><span class="s2"> PRIMCO </span><span class="si">{1}</span><span class="s2"> | sed -re &#39;/PRIMCO.*/{{N;d;}}&#39; | </span><span class="se">\</span>
<span class="s2">            awk &#39;{{print $5</span><span class="se">\&quot;</span><span class="s2"> </span><span class="se">\&quot;</span><span class="s2">$6</span><span class="se">\&quot;</span><span class="s2"> </span><span class="se">\&quot;</span><span class="s2">$7}}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">natoms</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">axsf_fn</span><span class="p">)</span>
    <span class="n">qpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,))</span>
    <span class="n">vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nmodes</span><span class="p">,</span><span class="n">natoms</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;grep -A</span><span class="si">{0}</span><span class="s2"> &#39;mode.*cm-1&#39; </span><span class="si">{1}</span><span class="s2"> | grep -v mode | </span><span class="se">\</span>
<span class="s2">           awk &#39;{{print $2}}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nmodes</span><span class="p">,</span> <span class="n">out_fn</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">qpoints</span><span class="p">,</span><span class="n">freqs</span><span class="p">,</span><span class="n">vecs</span></div>



<div class="viewcode-block" id="read_dynmat_ir_raman">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.read_dynmat_ir_raman.html#pwtools.pwscf.read_dynmat_ir_raman">[docs]</a>
<span class="k">def</span> <span class="nf">read_dynmat_ir_raman</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;dynmat.out&#39;</span><span class="p">,</span> <span class="n">natoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">cols</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;freqs&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="s1">&#39;ir&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="s1">&#39;raman&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span> <span class="s1">&#39;depol&#39;</span><span class="p">}):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read ``dynmat.x`` text output file and extract IR and Raman</span>
<span class="sd">    intensities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        dynmat.x text output file (e.g. from ``dynmat.x &lt; dynmat.in &gt;</span>
<span class="sd">        dynmat.out``)</span>
<span class="sd">    natoms : int</span>
<span class="sd">        number of atoms in the cell</span>
<span class="sd">    cols : dict</span>
<span class="sd">        column numbers of the text block</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    cols = None</span>
<span class="sd">        Return the parsed array as found in the file</span>
<span class="sd">    cols = dict</span>
<span class="sd">        Return dict with keys from `cols` and 1d arrays ``{&#39;freqs&#39;: &lt;array&gt;,</span>
<span class="sd">        &#39;ir&#39;: &lt;array&gt;, &#39;raman&#39;: &lt;array&gt;, &#39;depol&#39;: &lt;array&gt;}``. If a column is</span>
<span class="sd">        not present, the array is None.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parsed textblock looks like this::</span>

<span class="sd">        # mode   [cm-1]    [THz]      IR          Raman   depol.fact</span>
<span class="sd">            1      0.00    0.0000    0.0000         0.0005    0.7414</span>
<span class="sd">            2      0.00    0.0000    0.0000         0.0005    0.7465</span>
<span class="sd">            3      0.00    0.0000    0.0000         0.0018    0.2647</span>
<span class="sd">            4    252.27    7.5627    0.0000         0.0073    0.7500</span>
<span class="sd">            5    252.27    7.5627    0.0000         0.0073    0.7500</span>
<span class="sd">            6    548.44   16.4419    0.0000         0.0000    0.7434</span>
<span class="sd">            7    603.32   18.0872   35.9045        18.9075    0.7366</span>
<span class="sd">            8    656.82   19.6910    0.0000         7.9317    0.7500</span>
<span class="sd">            9    656.82   19.6910    0.0000         7.9317    0.7500</span>
<span class="sd">           10    669.67   20.0762   31.5712         5.0265    0.7500</span>
<span class="sd">           11    738.22   22.1311    0.0000         0.0000    0.7306</span>
<span class="sd">           12    922.64   27.6600   31.5712         5.0265    0.7500</span>

<span class="sd">    Some columns (e.g. IR, Raman) may be missing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">natoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;natoms is None&quot;</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;grep -A</span><span class="si">{0}</span><span class="s2"> &#39;mode.*cm-1&#39; </span><span class="si">{1}</span><span class="s2"> | grep -v mode&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">natoms</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">parse</span><span class="o">.</span><span class="n">arr2d_from_txt</span><span class="p">(</span><span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dct</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span><span class="n">name</span> <span class="ow">in</span> <span class="n">cols</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dct</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:,</span><span class="n">ii</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dct</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">dct</span></div>



<div class="viewcode-block" id="read_dynmat_out">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.read_dynmat_out.html#pwtools.pwscf.read_dynmat_out">[docs]</a>
<span class="k">def</span> <span class="nf">read_dynmat_out</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Backward compat wrapper for :func:`read_dynmat_ir_raman`.&quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;read_dynmat_out() is deprecated, use read_dynmat_ir_raman()&quot;</span><span class="p">,</span>
                  <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">read_dynmat_ir_raman</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>



<div class="viewcode-block" id="read_matdyn_freq">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.read_matdyn_freq.html#pwtools.pwscf.read_matdyn_freq">[docs]</a>
<span class="k">def</span> <span class="nf">read_matdyn_freq</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse frequency file produced by QE&#39;s matdyn.x (&quot;flfrq&quot; in matdyn.x</span>
<span class="sd">    input, usually &quot;matdyn.freq&quot; or so) when calculating a phonon dispersion on</span>
<span class="sd">    a grid (ldisp=.true., used for phonon dos) or a pre-defined k-path in the</span>
<span class="sd">    BZ.</span>

<span class="sd">    Used in :file:`bin/plot_dispersion.py`.</span>

<span class="sd">    In QE 5.x, a file with suffix &quot;.gp&quot; (e.g. &quot;matdyn.freq.gp&quot;) is now written,</span>
<span class="sd">    where::</span>

<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pwtools import kpath, pwscf</span>
<span class="sd">    &gt;&gt;&gt; d = np.loadtxt(&quot;matdyn.freq.gp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; kpoints,freqs = pwscf.read_matdyn_freq(&quot;matdyn.freq&quot;)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(d[:,0], kpath.get_path_norm(kpoints))</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(d[:,1:], freqs)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : file with k-points and phonon frequencies</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    kpoints : array (nks, 3)</span>
<span class="sd">        Array with `nks` k-points. AFAIK the unit is always ``2*pi/alat`` with</span>
<span class="sd">        ``alat = celldm(1)``.</span>
<span class="sd">    freqs : array (nks, nbnd)</span>
<span class="sd">        Array with `nbnd` energies/frequencies at each of the `nks` k-points.</span>
<span class="sd">        For phonon DOS, nbnd == 3*natoms.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `matdyn.in`::</span>

<span class="sd">        &amp;input</span>
<span class="sd">            asr=&#39;simple&#39;,</span>
<span class="sd">            amass(1)=26.981538,</span>
<span class="sd">            amass(2)=14.00674,</span>
<span class="sd">            flfrc=&#39;fc&#39;,</span>
<span class="sd">            flfrq=&#39;matdyn.freq.disp&#39;</span>
<span class="sd">        /</span>
<span class="sd">        101                                | nks</span>
<span class="sd">        0.000000    0.000000    0.000000   |</span>
<span class="sd">        0.037500    0.037500    0.000000   | List of nks = 101 k-points</span>
<span class="sd">        ....                               |</span>

<span class="sd">    `filename` has the form::</span>

<span class="sd">        &lt;header&gt;</span>
<span class="sd">        &lt;k-point, (3,)&gt;</span>
<span class="sd">        &lt;frequencies,(nbnd,)</span>
<span class="sd">        &lt;k-point, (3,)&gt;</span>
<span class="sd">        &lt;frequencies,(nbnd,)</span>
<span class="sd">        ...</span>

<span class="sd">    for example::</span>

<span class="sd">        &amp;plot nbnd=   6, nks= 101 /</span>
<span class="sd">                  0.000000  0.000000  0.000000</span>
<span class="sd">          0.0000    0.0000    0.0000  456.2385  456.2385  871.5931</span>
<span class="sd">                  0.037500  0.037500  0.000000</span>
<span class="sd">         23.8811   37.3033   54.3776  455.7569  457.2338  869.8832</span>
<span class="sd">         .....</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`pwtools.kpath.plot_dis`,</span>
<span class="sd">    :func:`pwtools.kpath.get_path_norm`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">file_readlines</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="c1"># Read number of bands (nbnd) and k-points (nks). OK, Fortran&#39;s namelists</span>
    <span class="c1"># win here :)</span>
    <span class="c1"># nbnd: number of bands = number of frequencies per k-point = 3*natoms for</span>
    <span class="c1">#   phonons</span>
    <span class="c1"># nks: number of k-points</span>
    <span class="n">pat</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;.*\s+nbnd\s*=\s*([0-9]+)\s*,\s*nks\s*=\s*([0-9]+)\s*/&#39;</span>
    <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">pat</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span> <span class="s2">&quot;match is None&quot;</span>
    <span class="n">nbnd</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">nks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">kpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nks</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nks</span><span class="p">,</span> <span class="n">nbnd</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">nbnd</span>
    <span class="c1"># nasty trick: join all lines containing data into one 1d array: &quot; &quot;.join()</span>
    <span class="c1"># does &quot;1 2\n3 4&quot; -&gt; &quot;1 2\n 3 4&quot; and split() splits at \n + whitespace.</span>
    <span class="n">items</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">//</span> <span class="n">step</span><span class="p">):</span>
        <span class="n">kpoints</span><span class="p">[</span><span class="n">ii</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">ii</span><span class="o">*</span><span class="n">step</span><span class="p">:(</span><span class="n">ii</span><span class="o">*</span><span class="n">step</span><span class="o">+</span><span class="mi">3</span><span class="p">)]</span>
        <span class="n">freqs</span><span class="p">[</span><span class="n">ii</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">items</span><span class="p">[(</span><span class="n">ii</span><span class="o">*</span><span class="n">step</span><span class="o">+</span><span class="mi">3</span><span class="p">):(</span><span class="n">ii</span><span class="o">*</span><span class="n">step</span><span class="o">+</span><span class="n">step</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">kpoints</span><span class="p">,</span> <span class="n">freqs</span></div>



<div class="viewcode-block" id="ibrav2cell">
<a class="viewcode-back" href="../../generated/api/pwtools.pwscf.ibrav2cell.html#pwtools.pwscf.ibrav2cell">[docs]</a>
<span class="k">def</span> <span class="nf">ibrav2cell</span><span class="p">(</span><span class="n">ibrav</span><span class="p">,</span> <span class="n">celldm</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert PWscf&#39;s ibrav + celldm to cell. All formulas are taken straight</span>
<span class="sd">    from the PWscf homepage. Don&#39;t blame me for errors. Use after testing.</span>

<span class="sd">    This function generates *primitive* cells. Note that in crys.py (and</span>
<span class="sd">    anywhere else in the package, for that matter) we do not have a distinction</span>
<span class="sd">    between conventional/primitive cell. We always think in primitive cells.</span>
<span class="sd">    Especially celldm in crys.py can be converted to/from `cell` and</span>
<span class="sd">    `cryst_const`. But here, `celldm` is the PWscf style celldm, which</span>
<span class="sd">    describes the *conventional* cell. For example, for an fcc cell (ibrav=2),</span>
<span class="sd">    celldm[0] == a == alat is the lattice constant &quot;a&quot; of the cubic</span>
<span class="sd">    conventional cell (cell=a*identity(3)), which is also found in a .cif file</span>
<span class="sd">    together with all symmetries. OTOH, for a hexagonal cell (ibrav=4)</span>
<span class="sd">    primitive == conventional cell.</span>

<span class="sd">    `celldm` (a = celldm[0]) is assumed be in the unit that you want for</span>
<span class="sd">    `cell` (Bohr, Angstrom, etc).</span>

<span class="sd">    Note: There are some documentation &lt;-&gt; forluma errors / inconsistencies for</span>
<span class="sd">    ibrav=12,13. See test/test_ibrav.py. If you really need that, have a look</span>
<span class="sd">    at the PWscf source for how they do it there.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ibrav : int</span>
<span class="sd">        1 ... 14</span>
<span class="sd">    celldm : sequence of length 6</span>
<span class="sd">        This not the isame length 6 array `celldm` in crys.py. Here, the</span>
<span class="sd">        entries which are not needed can be None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array (3,3) : cell vectors as rows, unit is that of celldm[0], i.e. a</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * ibrav = 14 is actually the only case where all 6 entries of `celldm` are</span>
<span class="sd">      needed and therefore the same as crys.cc2cell(crys.celldm2cc(celldm)).</span>
<span class="sd">      The returned `cell` here has the same spatial orientation as the one</span>
<span class="sd">      returned from crys.cc2cell(): a along x, b in xy-plane.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># some of celldm can be None</span>
    <span class="n">tofloat</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">aa</span><span class="p">,</span> <span class="n">bb_aa</span><span class="p">,</span> <span class="n">cc_aa</span><span class="p">,</span> <span class="n">cos_alpha</span><span class="p">,</span> <span class="n">cos_beta</span><span class="p">,</span> <span class="n">cos_gamma</span> <span class="o">=</span> <span class="p">[</span><span class="n">tofloat</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">celldm</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">bb_aa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bb</span> <span class="o">=</span> <span class="n">bb_aa</span> <span class="o">*</span> <span class="n">aa</span>
    <span class="k">if</span> <span class="n">cc_aa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cc</span> <span class="o">=</span> <span class="n">cc_aa</span> <span class="o">*</span> <span class="n">aa</span>
    <span class="k">if</span> <span class="n">cos_gamma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sin_gamma</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">acos</span><span class="p">(</span><span class="n">cos_gamma</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># cubic P (sc), sc simple cubic</span>
        <span class="c1"># v1 = a(1,0,0),  v2 = a(0,1,0),  v3 = a(0,0,1)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">aa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># cubic F (fcc), fcc face centered cubic</span>
        <span class="c1"># v1 = (a/2)(-1,0,1),  v2 = (a/2)(0,1,1), v3 = (a/2)(-1,1,0)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">aa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
                                  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="c1"># cubic I (bcc), bcc body entered cubic</span>
        <span class="c1"># v1 = (a/2)(1,1,1),  v2 = (a/2)(-1,1,1),  v3 = (a/2)(-1,-1,1)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">aa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
                                  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">],</span>
                                  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="c1"># Hexagonal and Trigonal P, simple hexagonal and trigonal(p)</span>
        <span class="c1"># v1 = a(1,0,0),  v2 = a(-1/2,sqrt(3)/2,0),  v3 = a(0,0,c/a)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">aa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>            <span class="mi">0</span><span class="p">],</span>
                              <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>  <span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                              <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>            <span class="n">cc</span><span class="o">/</span><span class="n">aa</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="c1"># Trigonal R, trigonal(r)</span>
        <span class="c1"># v1 = a(tx,-ty,tz),   v2 = a(0,2ty,tz),   v3 = a(-tx,-ty,tz)</span>
        <span class="c1">#   where c=cos(alpha) is the cosine of the angle alpha between any pair</span>
        <span class="c1">#   of crystallographic vectors, tc, ty, tz are defined as</span>
        <span class="c1"># tx=sqrt((1-c)/2), ty=sqrt((1-c)/6), tz=sqrt((1+2c)</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos_alpha</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
        <span class="n">ty</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cos_alpha</span><span class="p">)</span><span class="o">/</span><span class="mf">6.0</span><span class="p">)</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">cos_alpha</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">aa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="n">tx</span><span class="p">,</span>   <span class="o">-</span><span class="n">ty</span><span class="p">,</span>      <span class="n">tz</span><span class="p">],</span>
                              <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>   <span class="mf">2.0</span><span class="o">*</span><span class="n">ty</span><span class="p">,</span>  <span class="n">tz</span><span class="p">],</span>
                              <span class="p">[</span><span class="o">-</span><span class="n">tx</span><span class="p">,</span>   <span class="o">-</span><span class="n">ty</span><span class="p">,</span>      <span class="n">tz</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="c1"># Tetragonal P (st), simple tetragonal (p)</span>
        <span class="c1"># v1 = a(1,0,0),  v2 = a(0,1,0),  v3 = a(0,0,c/a)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">aa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                              <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                              <span class="p">[</span><span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="n">cc</span><span class="o">/</span><span class="n">aa</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="c1"># Tetragonal I (bct), body centered tetragonal (i)</span>
        <span class="c1"># v1 = (a/2)(1,-1,c/a),  v2 = (a/2)(1,1,c/a),  v3 = (a/2)(-1,-1,c/a)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">aa</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">1</span><span class="p">,</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="n">cc</span><span class="o">/</span><span class="n">aa</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mi">1</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>  <span class="n">cc</span><span class="o">/</span><span class="n">aa</span><span class="p">],</span>
                                  <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="n">cc</span><span class="o">/</span><span class="n">aa</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
        <span class="c1"># Orthorhombic P, simple orthorhombic (p)</span>
        <span class="c1"># v1 = (a,0,0),  v2 = (0,b,0), v3 = (0,0,c)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">aa</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span>   <span class="n">bb</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>  <span class="n">cc</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
        <span class="c1"># Orthorhombic base-centered(bco), bco base centered orthorhombic</span>
        <span class="c1"># v1 = (a/2,b/2,0),  v2 = (-a/2,b/2,0),  v3 = (0,0,c)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>   <span class="n">bb</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="o">-</span><span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>   <span class="n">bb</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span> <span class="mi">0</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span>        <span class="n">cc</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
        <span class="c1"># Orthorhombic face-centered, face centered orthorhombic</span>
        <span class="c1"># v1 = (a/2,0,c/2),  v2 = (a/2,b/2,0),  v3 = (0,b/2,c/2)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>    <span class="mi">0</span><span class="p">,</span>       <span class="n">cc</span><span class="o">/</span><span class="mf">2.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>    <span class="n">bb</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span>         <span class="n">bb</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>  <span class="n">cc</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">11</span><span class="p">:</span>
        <span class="c1"># Orthorhombic body-centered, body centered orthorhombic</span>
        <span class="c1"># v1 = (a/2,b/2,c/2),  v2 = (-a/2,b/2,c/2),  v3 = (-a/2,-b/2,c/2)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>   <span class="n">bb</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>  <span class="n">cc</span><span class="o">/</span><span class="mf">2.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="o">-</span><span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>   <span class="n">bb</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>  <span class="n">cc</span><span class="o">/</span><span class="mf">2.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="o">-</span><span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>  <span class="o">-</span><span class="n">bb</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>  <span class="n">cc</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">12</span><span class="p">:</span>
        <span class="c1"># Monoclinic P, monoclinic (p)</span>
        <span class="c1"># v1 = (a,0,0), v2= (b*cos(gamma), b*sin(gamma), 0),  v3 = (0, 0, c)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">aa</span><span class="p">,</span>             <span class="mi">0</span><span class="p">,</span>              <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="n">bb</span><span class="o">*</span><span class="n">cos_gamma</span><span class="p">,</span>  <span class="n">bb</span><span class="o">*</span><span class="n">sin_gamma</span><span class="p">,</span>  <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span>              <span class="mi">0</span><span class="p">,</span>              <span class="n">cc</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">13</span><span class="p">:</span>
        <span class="c1"># Monoclinic base-centered, base centered monoclinic</span>
        <span class="c1"># v1 = (a/2,0,-c/2), v2 = (b*cos(gamma),b*sin(gamma), 0), v3 = (a/2,0,c/2)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>             <span class="o">-</span><span class="n">cc</span><span class="o">/</span><span class="mf">2.0</span><span class="p">],</span>
                         <span class="p">[</span><span class="n">bb</span><span class="o">*</span><span class="n">cos_gamma</span><span class="p">,</span>   <span class="n">bb</span><span class="o">*</span><span class="n">sin_gamma</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
                         <span class="p">[</span><span class="n">aa</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>              <span class="n">cc</span><span class="o">/</span><span class="mf">2.0</span><span class="p">]])</span>
    <span class="k">elif</span> <span class="n">ibrav</span> <span class="o">==</span> <span class="mi">14</span><span class="p">:</span>
        <span class="c1"># Triclinic</span>
        <span class="c1"># v1 = (a, 0, 0),</span>
        <span class="c1"># v2 = (b*cos(gamma), b*sin(gamma), 0)</span>
        <span class="c1"># v3 = (c*cos(beta),  c*(cos(alpha)-cos(beta)cos(gamma))/sin(gamma),</span>
        <span class="c1"># c*sqrt( 1 + 2*cos(alpha)cos(beta)cos(gamma)</span>
        <span class="c1">#           - cos(alpha)^2-cos(beta)^2-cos(gamma)^2 )/sin(gamma)</span>
        <span class="n">v1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">aa</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bb</span><span class="o">*</span><span class="n">cos_gamma</span><span class="p">,</span> <span class="n">bb</span><span class="o">*</span><span class="n">sin_gamma</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">v3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cc</span><span class="o">*</span><span class="n">cos_beta</span><span class="p">,</span>
                       <span class="n">cc</span><span class="o">*</span><span class="p">(</span><span class="n">cos_alpha</span> <span class="o">-</span> <span class="n">cos_beta</span><span class="o">*</span><span class="n">cos_gamma</span><span class="p">)</span><span class="o">/</span><span class="n">sin_gamma</span><span class="p">,</span>
                       <span class="n">cc</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">cos_alpha</span><span class="o">*</span><span class="n">cos_beta</span><span class="o">*</span><span class="n">cos_gamma</span> <span class="o">-</span> \
                       <span class="n">cos_alpha</span><span class="o">**</span><span class="mf">2.0</span><span class="o">-</span><span class="n">cos_beta</span><span class="o">**</span><span class="mf">2.0</span><span class="o">-</span><span class="n">cos_gamma</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">/</span><span class="n">sin_gamma</span><span class="p">])</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">v3</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;illegal ibrav: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">ibrav</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cell</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;2023, Steve Schmerler.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>