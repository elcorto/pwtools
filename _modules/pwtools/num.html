
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pwtools.num &#8212; pwtools  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">pwtools</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=elcorto&repo=pwtools&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/index.html">API Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../written/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/background/index.html">Background, details, special topics</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pwtools.num</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">radians</span><span class="p">,</span> <span class="n">pi</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">optimize</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">bisplrep</span><span class="p">,</span> <span class="n">bisplev</span><span class="p">,</span> <span class="n">splev</span><span class="p">,</span> <span class="n">splrep</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="k">import</span> <span class="n">simps</span>
<span class="kn">from</span> <span class="nn">pwtools</span> <span class="k">import</span> <span class="n">_flib</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="c1">##warnings.simplefilter(&#39;always&#39;)</span>

<span class="c1"># Hack for older scipy versions.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="p">(</span>
        <span class="n">CloughTocher2DInterpolator</span><span class="p">,</span>
        <span class="n">NearestNDInterpolator</span><span class="p">,</span>
        <span class="n">LinearNDInterpolator</span><span class="p">,</span>
    <span class="p">)</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Don&#39;t throw a warning here b/c (1) this module is imported often and that</span>
    <span class="c1"># would annoy anyone to no end and (2) this interpolator isn&#39;t used much,</span>
    <span class="c1"># only for experimentation. It&#39;s enough to fail inside Interpol2D() if</span>
    <span class="c1"># needed.</span>
    <span class="n">CloughTocher2DInterpolator</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">NearestNDInterpolator</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">LinearNDInterpolator</span> <span class="o">=</span> <span class="kc">None</span>

<span class="c1"># constants</span>
<span class="n">EPS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>


<div class="viewcode-block" id="normalize"><a class="viewcode-back" href="../../generated/api/pwtools.num.normalize.html#pwtools.num.normalize">[docs]</a><span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize array by it&#39;s max value. Works also for complex arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a=np.array([3+4j, 5+4j])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([ 3.+4.j,  5.+4.j])</span>
<span class="sd">    &gt;&gt;&gt; a.max()</span>
<span class="sd">    (5.0+4.0j)</span>
<span class="sd">    &gt;&gt;&gt; a/a.max()</span>
<span class="sd">    array([ 0.75609756+0.19512195j,  1.00000000+0.j ])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">a</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div>


<div class="viewcode-block" id="vlinspace"><a class="viewcode-back" href="../../generated/api/pwtools.num.vlinspace.html#pwtools.num.vlinspace">[docs]</a><span class="k">def</span> <span class="nf">vlinspace</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Like numpy.linspace, but for 1d arrays. Generate uniformly spaced points</span>
<span class="sd">    (vectors) along the distance vector connecting a and b.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : 1d arrays</span>
<span class="sd">    num : int</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array (num, len(a)), each row is a &quot;point&quot; between `a` and `b`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;expect 1d arrays&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="s2">&quot;`a` and `b` must have equal length&quot;</span>
    <span class="k">assert</span> <span class="n">num</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;`num` must be &gt;= 1&quot;</span>
    <span class="c1"># distance vec connecting a and b</span>
    <span class="n">dv</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">a</span>
    <span class="k">if</span> <span class="n">endpoint</span><span class="p">:</span>
        <span class="c1"># If num == 1, then the value of `ddv` doesn&#39;t matter b/c ret == a.</span>
        <span class="n">ddv</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">dv</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ddv</span> <span class="o">=</span> <span class="n">dv</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dv</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">ret</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">ddv</span>
    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="norm_int"><a class="viewcode-back" href="../../generated/api/pwtools.num.norm_int.html#pwtools.num.norm_int">[docs]</a><span class="k">def</span> <span class="nf">norm_int</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">area</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">simps</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Normalize integral area of y(x) to `area`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x,y : numpy 1d arrays</span>
<span class="sd">    area : float</span>
<span class="sd">    scale : bool, optional</span>
<span class="sd">        Scale x and y to the same order of magnitude before integration.</span>
<span class="sd">        This may be necessary to avoid numerical trouble if x and y have very</span>
<span class="sd">        different scales.</span>
<span class="sd">    func : callable</span>
<span class="sd">        Function to do integration (like scipy.integrate.{simps,trapz,...}</span>
<span class="sd">        Called as ``func(y,x)``. Default: simps</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scaled y</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The argument order y,x might be confusing. x,y would be more natural but we</span>
<span class="sd">    stick to the order used in the scipy.integrate routines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="n">fx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">fy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">sx</span> <span class="o">=</span> <span class="n">x</span> <span class="o">/</span> <span class="n">fx</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">fy</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fx</span> <span class="o">=</span> <span class="n">fy</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>
    <span class="c1"># Area under unscaled y(x).</span>
    <span class="n">_area</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">sy</span><span class="p">,</span> <span class="n">sx</span><span class="p">)</span> <span class="o">*</span> <span class="n">fx</span> <span class="o">*</span> <span class="n">fy</span>
    <span class="k">return</span> <span class="n">y</span> <span class="o">*</span> <span class="n">area</span> <span class="o">/</span> <span class="n">_area</span></div>


<div class="viewcode-block" id="deriv_spl"><a class="viewcode-back" href="../../generated/api/pwtools.num.deriv_spl.html#pwtools.num.deriv_spl">[docs]</a><span class="k">def</span> <span class="nf">deriv_spl</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xnew</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">fullout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">splrep_kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;n-th derivative for 1d arrays of possibly nonuniformly sampled data.</span>
<span class="sd">    Returns matching x-axis for plotting. Splines are used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x,y : 1d arrays of same length</span>
<span class="sd">        if x=None, then x=arange(len(y)) is used</span>
<span class="sd">    xnew : {None, 1d array)</span>
<span class="sd">        x-axis to evaluate the derivative, if None then xnew=x</span>
<span class="sd">    n : int</span>
<span class="sd">        order of the derivative, can only be &lt;= k</span>
<span class="sd">    fullout : bool</span>
<span class="sd">        return xd, yd or just yd</span>
<span class="sd">    splrep_kwargs : keyword args to scipy.interpolate.splrep, default: k=3, s=0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    if fullout:</span>
<span class="sd">        xd, yd</span>
<span class="sd">    else:</span>
<span class="sd">        yd</span>
<span class="sd">    xd : 1d array, (len(x) or len(xnew),)</span>
<span class="sd">    yd : 1d array, (len(x) or len(xnew),)</span>
<span class="sd">        n-th derivative of y at points xd</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    xd is actually == x or xnew (if x is not None). xd can be returned to match</span>
<span class="sd">    the function signature of deriv_fd.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;n &lt;= 0 makes no sense&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">xnew</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xnew</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">splrep_kwargs</span><span class="p">:</span>
            <span class="n">splrep_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="n">yd</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">splrep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">splrep_kwargs</span><span class="p">),</span> <span class="n">der</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fullout</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xnew</span><span class="p">,</span> <span class="n">yd</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">yd</span></div>


<div class="viewcode-block" id="findmin"><a class="viewcode-back" href="../../generated/api/pwtools.num.findmin.html#pwtools.num.findmin">[docs]</a><span class="k">def</span> <span class="nf">findmin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find minimum of x-y curve by searching for the root of the 1st</span>
<span class="sd">    derivative of a spline thru x,y. `x` must be sorted min -&gt; max and the</span>
<span class="sd">    interval [x[0], x[-1]] must contain the minimum.</span>

<span class="sd">    This is intended for quick interactive work. For working with</span>
<span class="sd">    pre-calculated splines, see :class:`Spline`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x,y : 1d arrays</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array([x0, y(x0)])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;use Spline(x,y).get_min()&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="n">spl</span> <span class="o">=</span> <span class="n">Spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">get_min</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">spl</span><span class="p">(</span><span class="n">x0</span><span class="p">)])</span></div>


<div class="viewcode-block" id="findroot"><a class="viewcode-back" href="../../generated/api/pwtools.num.findroot.html#pwtools.num.findroot">[docs]</a><span class="k">def</span> <span class="nf">findroot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find root of x-y curve by searching for the root of a spline thru x,y.</span>
<span class="sd">    `x` must be sorted min -&gt; max and the interval [x[0], x[-1]] must contain</span>
<span class="sd">    the root.</span>

<span class="sd">    This is intended for quick interactive work. For working with</span>
<span class="sd">    pre-calculated splines, see :class:`Spline`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x,y : 1d arrays</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array([x0, y(x0)])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;use Spline(x,y).get_root()&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="n">spl</span> <span class="o">=</span> <span class="n">Spline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">get_root</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">spl</span><span class="p">(</span><span class="n">x0</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Fit1D"><a class="viewcode-back" href="../../generated/api/pwtools.num.Fit1D.html#pwtools.num.Fit1D">[docs]</a><span class="k">class</span> <span class="nc">Fit1D</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Base class for 1D data fit/interpolation classes (:class:`Spline`,</span>
<span class="sd">    :class:`PolyFit1D`). It provides :meth:`get_min`, :meth:`get_max`,</span>
<span class="sd">    :meth:`get_root`, :meth:`is_mono`.</span>

<span class="sd">    The assumed API is that the ``__call__`` method has a kwd `der` which</span>
<span class="sd">    causes it to calculate derivatives, i.e. ``__call__(x, der=1)`` is the</span>
<span class="sd">    first deriv.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Fit1D.__init__"><a class="viewcode-back" href="../../generated/api/pwtools.num.Fit1D.html#pwtools.num.Fit1D.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span></div>

    <span class="c1"># XXX once the now deprecated module-level findroot() is gone, we can turn</span>
    <span class="c1"># this into a new module-level findroot(), with another API however.</span>
    <span class="k">def</span> <span class="nf">_findroot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find root of `func` by Newton&#39;s method if `x0` is given or Brent&#39;s</span>
<span class="sd">        method if `xab` is given. If neither is given, then</span>
<span class="sd">        ``xab=[self.x[0],self.x[-1]]`` and Brent&#39;s method is used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable, must accept a scalar and retun a scalar</span>
<span class="sd">        x0 : float</span>
<span class="sd">            start guess for Newton&#39;s secant method</span>
<span class="sd">        xab : sequence of length 2</span>
<span class="sd">            start bracket for Brent&#39;s method, root must lie in between</span>
<span class="sd">        **kwds :</span>
<span class="sd">            passed to scipy root finder (newton() or brentq())</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xx : scalar</span>
<span class="sd">            the root of func(x)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xx</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xab</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">xab</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">xx</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">xab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xx</span>

<div class="viewcode-block" id="Fit1D.is_mono"><a class="viewcode-back" href="../../generated/api/pwtools.num.Fit1D.is_mono.html#pwtools.num.Fit1D.is_mono">[docs]</a>    <span class="k">def</span> <span class="nf">is_mono</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the curve described by the fit function f(x) is</span>
<span class="sd">        monotonic.&quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">))))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span></div>

<div class="viewcode-block" id="Fit1D.get_min"><a class="viewcode-back" href="../../generated/api/pwtools.num.Fit1D.get_min.html#pwtools.num.Fit1D.get_min">[docs]</a>    <span class="k">def</span> <span class="nf">get_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return x where y(x) = min(y) by calculating the root of the</span>
<span class="sd">        fit&#39;s 1st derivative (by calling ``self(x, der=1)``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x0 or xab :</span>
<span class="sd">            see :meth:`_findroot`</span>
<span class="sd">        **kwds :</span>
<span class="sd">            passed to :meth:`_findroot`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xx : scalar</span>
<span class="sd">            min(y) = y(xx)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findroot</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="n">xab</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit1D.get_max"><a class="viewcode-back" href="../../generated/api/pwtools.num.Fit1D.get_max.html#pwtools.num.Fit1D.get_max">[docs]</a>    <span class="k">def</span> <span class="nf">get_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Convenience method. Same as :meth:`get_min`, just for local maxima,</span>
<span class="sd">        simply using ``-self(x, der=1)``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findroot</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="n">xab</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Fit1D.get_root"><a class="viewcode-back" href="../../generated/api/pwtools.num.Fit1D.get_root.html#pwtools.num.Fit1D.get_root">[docs]</a>    <span class="k">def</span> <span class="nf">get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return x where y(x) = 0 by calculating the root of the fit function.</span>

<span class="sd">        In :class:`Spline`, this is the same as ``Spline.invsplev(0.0, ...)``,</span>
<span class="sd">        i.e. lookup x where y=0, which is exactly the root.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x0 or xab :</span>
<span class="sd">            see :meth:`_findroot`</span>
<span class="sd">        **kwds :</span>
<span class="sd">            passed to :meth:`_findroot`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xx : scalar</span>
<span class="sd">            y(xx) = 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findroot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="n">xab</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Spline"><a class="viewcode-back" href="../../generated/api/pwtools.num.Spline.html#pwtools.num.Spline">[docs]</a><span class="k">class</span> <span class="nc">Spline</span><span class="p">(</span><span class="n">Fit1D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;:class:`Fit1D`-based spline interpolator.</span>

<span class="sd">    Like ``scipy.interpolate.UnivariateSpline``, this is a wrapper around</span>
<span class="sd">    ``scipy.interpolate.splrep/splev`` with some nice features like y-&gt;x lookup</span>
<span class="sd">    and interpolation accuracy check etc. It basically simplifies setting up a</span>
<span class="sd">    spline interpolation and holds x-y data plus the spline knots</span>
<span class="sd">    (``self.tck``) together in one place. You can work with the methods here,</span>
<span class="sd">    but you can also use the normal tck (``self.tck``) in</span>
<span class="sd">    ``scipy.interpolate.splev()`` etc.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import splev</span>
<span class="sd">    &gt;&gt;&gt; from pwtools import num</span>
<span class="sd">    &gt;&gt;&gt; x = linspace(0,10,100)</span>
<span class="sd">    &gt;&gt;&gt; y = sin(x)</span>
<span class="sd">    &gt;&gt;&gt; sp = num.Spline(x,y)</span>
<span class="sd">    &gt;&gt;&gt; plot(x,y)</span>
<span class="sd">    &gt;&gt;&gt; plot(x, sp(x))</span>
<span class="sd">    &gt;&gt;&gt; plot(x, splev(x, sp.tck)) # the same</span>
<span class="sd">    &gt;&gt;&gt; plot(x, sp(x, der=1), label=&#39;1st derivative&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xx = sp.invsplev(0.5, xab=[0, pi/2])</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;at %f degrees, sin(x) = 0.5&quot; %(xx/pi*180))</span>
<span class="sd">    &gt;&gt;&gt;</span>
<span class="sd">    &gt;&gt;&gt; y = x**2 - 5</span>
<span class="sd">    &gt;&gt;&gt; sp = num.Spline(x,y)</span>
<span class="sd">    &gt;&gt;&gt; print(&quot;the root is at x=%f&quot; %sp.invsplev(0.0))</span>
<span class="sd">    &gt;&gt;&gt; legend()</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Spline.__init__"><a class="viewcode-back" href="../../generated/api/pwtools.num.Spline.html#pwtools.num.Spline.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">checkeps</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">splrep_kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : numpy 1d arrays</span>
<span class="sd">        eps : float</span>
<span class="sd">            Accuracy threshold. Spline must interpolate points with an error</span>
<span class="sd">            less then eps. Useless if you use splrep(...,s=..) with &quot;s&quot; (the</span>
<span class="sd">            smoothing factor) much bigger than 0. See `ckeckeps`.</span>
<span class="sd">        checkeps : bool</span>
<span class="sd">            Whether to use `eps` to ckeck interpolation accuracy.</span>
<span class="sd">        **splrep_kwargs : keywords args to splrep(), default: k=3, s=0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Spline</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arr_zero_dim_t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;x wronly ordered&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splrep_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">splrep_kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">splrep_kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tck</span> <span class="o">=</span> <span class="n">splrep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">splrep_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">checkeps</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">err</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
            <span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;spline not accurate to eps=</span><span class="si">%e</span><span class="s2">, max(error)=</span><span class="si">%e</span><span class="s2">, raise eps&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
                <span class="n">err</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Spline.__call__"><a class="viewcode-back" href="../../generated/api/pwtools.num.Spline.html#pwtools.num.Spline.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">splev</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tck</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># splev() retrns array(&lt;number&gt;) for scalar input, convert to scalar</span>
        <span class="c1"># float</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">arr_zero_dim_t</span> <span class="ow">and</span> <span class="n">ret</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Spline.splev"><a class="viewcode-back" href="../../generated/api/pwtools.num.Spline.splev.html#pwtools.num.Spline.splev">[docs]</a>    <span class="k">def</span> <span class="nf">splev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;use Spline(x,y)(new_x) instead of Spline.splev()&quot;</span><span class="p">,</span>
            <span class="ne">DeprecationWarning</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Spline.invsplev"><a class="viewcode-back" href="../../generated/api/pwtools.num.Spline.invsplev.html#pwtools.num.Spline.invsplev">[docs]</a>    <span class="k">def</span> <span class="nf">invsplev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lookup x for a given y, i.e. &quot;inverse spline evaluation&quot;, hence</span>
<span class="sd">        the name. Find x where y(x) == y0 by calculating the root of y(x) -</span>
<span class="sd">        y0. We can use Newton&#39;s (x0) or Brent&#39;s (xab) methods. Use only one of</span>
<span class="sd">        them. If neither is given, we use xab=[x[0], x[-1]] and Brent.</span>

<span class="sd">        There are a few caveats. The result depends the nature of the</span>
<span class="sd">        underlying x-y curve (is it strictly monotinic -&gt; hopefully one root or</span>
<span class="sd">        oscillating -&gt; possibly several roots) and on how good x0 or xab are.</span>
<span class="sd">        For instance, a bad x0 will cause the Newton method to converge to a</span>
<span class="sd">        different root (if there is one) or to converge not at all. Or an</span>
<span class="sd">        interval xab which contains no (or several) root(s) will cause the</span>
<span class="sd">        Brent method to error out or give wrong/unexpected results. Always plot</span>
<span class="sd">        you data before using.</span>

<span class="sd">        Works only for scalar input (one point lookup). For many points, try to</span>
<span class="sd">        construct an inverse spline: Spline(y,x).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x0 : float</span>
<span class="sd">            start guess for Newton&#39;s secant method</span>
<span class="sd">        xab : sequence of length 2</span>
<span class="sd">            start bracket for Brent&#39;s method, root must lie in between</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        xx : scalar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The other possibility to implement this is to construct an inverse</span>
        <span class="c1"># spline Spline(y,x) and do the lookup via splev(y0, ...). But this</span>
        <span class="c1"># requires the data x,y to be monotonic b/c otherwise, the lookup y-&gt;x</span>
        <span class="c1"># is not unique. Here, the user is responsible for providing a</span>
        <span class="c1"># meaningful x0 / xab, which is more flexible and generic.</span>
        <span class="n">ymn</span><span class="p">,</span> <span class="n">ymx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">assert</span> <span class="n">ymn</span> <span class="o">&lt;=</span> <span class="n">y0</span> <span class="o">&lt;=</span> <span class="n">ymx</span><span class="p">,</span> <span class="s2">&quot;y0 (</span><span class="si">%e</span><span class="s2">) outside y data range [</span><span class="si">%e</span><span class="s2">, </span><span class="si">%e</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="n">y0</span><span class="p">,</span>
            <span class="n">ymn</span><span class="p">,</span>
            <span class="n">ymx</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">y0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findroot</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">xab</span><span class="o">=</span><span class="n">xab</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="slicetake"><a class="viewcode-back" href="../../generated/api/pwtools.num.slicetake.html#pwtools.num.slicetake">[docs]</a><span class="k">def</span> <span class="nf">slicetake</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The equivalent of numpy.take(a, ..., axis=&lt;axis&gt;), but accepts slice</span>
<span class="sd">    objects instead of an index array. Also by default, it returns a *view* and</span>
<span class="sd">    no copy.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : numpy ndarray</span>
<span class="sd">    sl : slice object, list or tuple of slice objects</span>
<span class="sd">        axis=&lt;int&gt;</span>
<span class="sd">            one slice object for *that* axis</span>
<span class="sd">        axis=None</span>
<span class="sd">            `sl` is a list or tuple of slice objects, one for each axis.</span>
<span class="sd">            It must index the whole array, i.e. len(sl) == len(a.shape).</span>
<span class="sd">    axis : {None, int}</span>
<span class="sd">    copy : bool, return a copy instead of a view</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A view into `a` or copy of a slice of `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import s_</span>
<span class="sd">    &gt;&gt;&gt; a = np.random.rand(20,20,20)</span>
<span class="sd">    &gt;&gt;&gt; b1 = a[:,:,10:]</span>
<span class="sd">    &gt;&gt;&gt; # single slice for axis 2</span>
<span class="sd">    &gt;&gt;&gt; b2 = slicetake(a, s_[10:], axis=2)</span>
<span class="sd">    &gt;&gt;&gt; # tuple of slice objects</span>
<span class="sd">    &gt;&gt;&gt; b3 = slicetake(a, s_[:,:,10:])</span>
<span class="sd">    &gt;&gt;&gt; (b2 == b1).all()</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; (b3 == b1).all()</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; # simple extraction too, sl = integer</span>
<span class="sd">    &gt;&gt;&gt; (a[...,5] == slicetake(a, 5, axis=-1))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The long story</span>
    <span class="c1"># --------------</span>
    <span class="c1">#</span>
    <span class="c1"># 1) Why do we need that:</span>
    <span class="c1">#</span>
    <span class="c1"># # no problem</span>
    <span class="c1"># a[5:10:2]</span>
    <span class="c1">#</span>
    <span class="c1"># # the same, more general</span>
    <span class="c1"># sl = slice(5,10,2)</span>
    <span class="c1"># a[sl]</span>
    <span class="c1">#</span>
    <span class="c1"># But we want to:</span>
    <span class="c1">#  - Define (type in) a slice object only once.</span>
    <span class="c1">#  - Take the slice of different arrays along different axes.</span>
    <span class="c1"># Since numpy.take() and a.take() don&#39;t handle slice objects, one would</span>
    <span class="c1"># have to use direct slicing and pay attention to the shape of the array:</span>
    <span class="c1">#</span>
    <span class="c1">#     a[sl], b[:,:,sl,:], etc ...</span>
    <span class="c1">#</span>
    <span class="c1"># We want to use an &#39;axis&#39; keyword instead. np.r_() generates index arrays</span>
    <span class="c1"># from slice objects (e.g r_[1:5] == r_[s_[1:5] ==r_[slice(1,5,None)]).</span>
    <span class="c1"># Since we need index arrays for numpy.take(), maybe we can use that? Like</span>
    <span class="c1"># so:</span>
    <span class="c1">#</span>
    <span class="c1">#     a.take(r_[sl], axis=0)</span>
    <span class="c1">#     b.take(r_[sl], axis=2)</span>
    <span class="c1">#</span>
    <span class="c1"># Here we have what we want: slice object + axis kwarg.</span>
    <span class="c1"># But r_[slice(...)] does not work for all slice types. E.g. not for</span>
    <span class="c1">#</span>
    <span class="c1">#     r_[s_[::5]] == r_[slice(None, None, 5)] == array([], dtype=int32)</span>
    <span class="c1">#     r_[::5]                                 == array([], dtype=int32)</span>
    <span class="c1">#     r_[s_[1:]]  == r_[slice(1, None, None)] == array([0])</span>
    <span class="c1">#     r_[1:]</span>
    <span class="c1">#         ValueError: dimensions too large.</span>
    <span class="c1">#</span>
    <span class="c1"># The returned index arrays are wrong (or we even get an exception).</span>
    <span class="c1"># The reason is given below.</span>
    <span class="c1"># Bottom line: We need this function.</span>
    <span class="c1">#</span>
    <span class="c1"># The reason for r_[slice(...)] gererating sometimes wrong index arrays is</span>
    <span class="c1"># that s_ translates a fancy index (1:, ::5, 1:10:2, ...) to a slice</span>
    <span class="c1"># object. This *always* works. But since take() accepts only index arrays,</span>
    <span class="c1"># we use r_[s_[&lt;fancy_index&gt;]], where r_ translates the slice object</span>
    <span class="c1"># prodced by s_ to an index array. THAT works only if start and stop of the</span>
    <span class="c1"># slice are known. r_ has no way of knowing the dimensions of the array to</span>
    <span class="c1"># be sliced and so it can&#39;t transform a slice object into a correct index</span>
    <span class="c1"># array in case of slice(&lt;number&gt;, None, None) or slice(None, None,</span>
    <span class="c1"># &lt;number&gt;).</span>
    <span class="c1">#</span>
    <span class="c1"># 2) Slice vs. copy</span>
    <span class="c1">#</span>
    <span class="c1"># numpy.take(a, array([0,1,2,3])) or a[array([0,1,2,3])] return a copy of</span>
    <span class="c1"># `a` b/c that&#39;s &quot;fancy indexing&quot;. But a[slice(0,4,None)], which is the</span>
    <span class="c1"># same as indexing (slicing) a[:4], return *views*.</span>

    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="n">sl</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Note that these are equivalent:</span>
        <span class="c1">#   a[:]</span>
        <span class="c1">#   a[s_[:]]</span>
        <span class="c1">#   a[slice(None)]</span>
        <span class="c1">#   a[slice(None, None, None)]</span>
        <span class="c1">#   a[slice(0, None, None)]</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">slices</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span>
    <span class="c1"># a[...] can take a tuple or list of slice objects</span>
    <span class="c1"># a[x:y:z, i:j:k] is the same as</span>
    <span class="c1"># a[(slice(x,y,z), slice(i,j,k))] == a[[slice(x,y,z), slice(i,j,k)]]</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span></div>


<div class="viewcode-block" id="sliceput"><a class="viewcode-back" href="../../generated/api/pwtools.num.sliceput.html#pwtools.num.sliceput">[docs]</a><span class="k">def</span> <span class="nf">sliceput</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">sl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;The equivalent of a[&lt;slice or index&gt;]=b, but accepts slices objects</span>
<span class="sd">    instead of array indices or fancy indexing (e.g. a[:,1:]).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : numpy ndarray</span>
<span class="sd">    sl : slice object, list or tuple of slice objects</span>
<span class="sd">        axis=&lt;int&gt;</span>
<span class="sd">            one slice object for *that* axis</span>
<span class="sd">        axis=None</span>
<span class="sd">            `sl` is a list or tuple of slice objects, one for each axis.</span>
<span class="sd">            It must index the whole array, i.e. len(sl) == len(a.shape).</span>
<span class="sd">    axis : {None, int}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    The modified `a`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import s_</span>
<span class="sd">    &gt;&gt;&gt; a=np.arange(12).reshape((2,6))</span>
<span class="sd">    &gt;&gt;&gt; a[:,1:3] = 100</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[  0, 100, 100,   3,   4,   5],</span>
<span class="sd">           [  6, 100, 100,   9,  10,  11]])</span>
<span class="sd">    &gt;&gt;&gt; sliceput(a, 200, s_[1:3], axis=1)</span>
<span class="sd">    array([[  0, 200, 200,   3,   4,   5],</span>
<span class="sd">           [  6, 200, 200,   9,  10,  11]])</span>
<span class="sd">    &gt;&gt;&gt; sliceput(a, 300, s_[:,1:3])</span>
<span class="sd">    array([[  0, 300, 300,   3,   4,   5],</span>
<span class="sd">           [  6, 300, 300,   9,  10,  11]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># silce(...) or (slice(...), slice(...), ...)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">sl</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># [slice(...), slice(...), ...]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">tmp</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sl</span>
    <span class="n">a</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">return</span> <span class="n">a</span></div>


<div class="viewcode-block" id="extend_array"><a class="viewcode-back" href="../../generated/api/pwtools.num.extend_array.html#pwtools.num.extend_array">[docs]</a><span class="k">def</span> <span class="nf">extend_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">nstep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repeat an array along ``axis`` by inserting a new axis (dimension)</span>
<span class="sd">    before ``axis``. Use this to &quot;broadcast&quot; e.g. a 2d array (3,3) -&gt;</span>
<span class="sd">    (3,3,nstep).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">    nstep : int, number of times to repeat</span>
<span class="sd">    axis : axis to add</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a=arange(4)</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 0)</span>
<span class="sd">    array([[0, 1, 2, 3],</span>
<span class="sd">           [0, 1, 2, 3],</span>
<span class="sd">           [0, 1, 2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 0).shape</span>
<span class="sd">    (3, 4)</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 1)</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [1, 1, 1],</span>
<span class="sd">           [2, 2, 2],</span>
<span class="sd">           [3, 3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 1).shape</span>
<span class="sd">    (4, 3)</span>
<span class="sd">    &gt;&gt;&gt; a=arange(4).reshape(2,2)</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 0).shape</span>
<span class="sd">    (3, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 1).shape</span>
<span class="sd">    (2, 3, 2)</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 2).shape</span>
<span class="sd">    (2, 2, 3)</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 2)[...,0]</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 2)[...,1]</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; extend_array(a, 3, 2)[...,2]</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [2, 3]])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`numpy.repeat`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># XXX Make more effective by using stride_tricks, see</span>
    <span class="c1"># http://thread.gmane.org/gmane.comp.python.numeric.general/48096 .</span>
    <span class="c1"># Test if this survives pickle / unpickle. Probably not.</span>
    <span class="c1">#</span>
    <span class="c1"># Also, maybe add attr &#39;extended&#39; to tha array. setattr() doesn&#39;t work,</span>
    <span class="c1"># however.</span>
    <span class="c1">#</span>
    <span class="c1"># (3,3) -&gt; max_axis = 2</span>
    <span class="n">max_axis</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">assert</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;=</span> <span class="n">max_axis</span><span class="p">,</span> <span class="s2">&quot;axis out of bound&quot;</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">max_axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># e.g: [:,:,np.newaxis,...]</span>
    <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)],</span> <span class="n">nstep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="sum"><a class="viewcode-back" href="../../generated/api/pwtools.num.sum.html#pwtools.num.sum">[docs]</a><span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This numpy.sum() with some features implemented which can be found in</span>
<span class="sd">    numpy v1.7 and later: `axis` can be a tuple to select arbitrary axes to sum</span>
<span class="sd">    over.</span>

<span class="sd">    We also have a `keepdims` keyword, which however works completely different</span>
<span class="sd">    from numpy. Docstrings shamelessly stolen from numpy and adapted here</span>
<span class="sd">    and there.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : nd array</span>
<span class="sd">    axis : None or int or tuple of ints, optional</span>
<span class="sd">        Axis or axes along which a sum is performed. The default (`axis` =</span>
<span class="sd">        `None`) is to perform a sum over all the dimensions of the input array.</span>
<span class="sd">        `axis` may be negative, in which case it counts from the last to the</span>
<span class="sd">        first axis.</span>
<span class="sd">        If this is a tuple of ints, a sum is performed on multiple</span>
<span class="sd">        axes, instead of a single axis or all the axes as before.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes from `axis` are left in the result</span>
<span class="sd">        and the reduction (sum) is performed for all remaining axes. Therefore,</span>
<span class="sd">        it reverses the `axis` to be summed over.</span>
<span class="sd">    **kwds : passed to np.sum().</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a=rand(2,3,4)</span>
<span class="sd">    &gt;&gt;&gt; num.sum(a)</span>
<span class="sd">    12.073636268676152</span>
<span class="sd">    &gt;&gt;&gt; a.sum()</span>
<span class="sd">    12.073636268676152</span>
<span class="sd">    &gt;&gt;&gt; num.sum(a, axis=1).shape</span>
<span class="sd">    (2, 4)</span>
<span class="sd">    &gt;&gt;&gt; num.sum(a, axis=(1,)).shape</span>
<span class="sd">    (2, 4)</span>
<span class="sd">    &gt;&gt;&gt; # same as axis=1, i.e. it inverts the axis over which we sum</span>
<span class="sd">    &gt;&gt;&gt; num.sum(a, axis=(0,2), keepdims=True).shape</span>
<span class="sd">    (2, 4)</span>
<span class="sd">    &gt;&gt;&gt; # numpy&#39;s keepdims has another meaning: it leave the summed axis (0,2)</span>
<span class="sd">    &gt;&gt;&gt; # as dimension of size 1 to allow broadcasting</span>
<span class="sd">    &gt;&gt;&gt; numpy.sum(a, axis=(0,2), keepdims=True).shape</span>
<span class="sd">    (1, 3, 1)</span>
<span class="sd">    &gt;&gt;&gt; num.sum(a, axis=(1,)) - num.sum(a, axis=1)</span>
<span class="sd">    array([[ 0.,  0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; num.sum(a, axis=(0,2)).shape</span>
<span class="sd">    (3,)</span>
<span class="sd">    &gt;&gt;&gt; num.sum(a, axis=(0,2)) - a.sum(axis=0).sum(axis=1)</span>
<span class="sd">    array([ 0.,  0.,  0.])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Recursion rocks!</span>
    <span class="k">def</span> <span class="nf">_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">tosum</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tosum</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Choose axis to sum over, remove from list w/ remaining axes.</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">tosum</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">_arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="c1"># arr has one dim less now. Rename remaining axes accordingly.</span>
            <span class="n">_tosum</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">xx</span> <span class="o">&gt;</span> <span class="n">axis</span> <span class="k">else</span> <span class="n">xx</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">tosum</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">_sum</span><span class="p">(</span><span class="n">_arr</span><span class="p">,</span> <span class="n">_tosum</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arr</span>

    <span class="n">axis_is_int</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;axis=None + keepdims=True makes no sense&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">axis_is_int</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis_is_int</span><span class="p">:</span>
            <span class="n">tosum</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">tosum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;illegal type for axis: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">axis</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="n">alldims</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
            <span class="n">tosum</span> <span class="o">=</span> <span class="p">[</span><span class="n">xx</span> <span class="k">for</span> <span class="n">xx</span> <span class="ow">in</span> <span class="n">alldims</span> <span class="k">if</span> <span class="n">xx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tosum</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">tosum</span><span class="p">)</span></div>


<div class="viewcode-block" id="Interpol2D"><a class="viewcode-back" href="../../generated/api/pwtools.num.Interpol2D.html#pwtools.num.Interpol2D">[docs]</a><span class="k">class</span> <span class="nc">Interpol2D</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Common 2D interpolator API.</span>

<span class="sd">    The API is the same as in ``scipy.interpolate``, e.g.</span>

<span class="sd">    &gt;&gt;&gt; inter = scipy.interpolate.SomeInterpolatorClass(points, values)</span>
<span class="sd">    &gt;&gt;&gt; new_values = inter(new_points)</span>

<span class="sd">    This is for easy testing of multiple interpolators on a surface z = f(x,y),</span>
<span class="sd">    which is given as an unordered set of points.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Interpol2D.__init__"><a class="viewcode-back" href="../../generated/api/pwtools.num.Interpol2D.html#pwtools.num.Interpol2D.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">xx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">yy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">dd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">what</span><span class="o">=</span><span class="s2">&quot;rbf_inv_multi&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">initkwds</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : (npoints, 2)</span>
<span class="sd">        values : (npoints, 1)</span>
<span class="sd">        xx,yy : (npoints, 1)</span>
<span class="sd">            Use either `points` + `values` or `xx` + `yy` + `values` or `dd`.</span>
<span class="sd">        dd : pwtools.mpl.Data2D instance</span>
<span class="sd">        what : str, optional</span>
<span class="sd">            which interpolator to use</span>

<span class="sd">            * &#39;rbf_multi&#39; : RBFN w/ multiquadric rbf, see :class:`~pwtools.rbf.Rbf`</span>
<span class="sd">            * &#39;rbf_inv_multi&#39; : RBFN w/ inverse multiquadric rbf</span>
<span class="sd">            * &#39;rbf_gauss&#39; : RBFN w/ gaussian rbf</span>
<span class="sd">            * &#39;poly&#39;      : :class:`PolyFit`</span>
<span class="sd">            * &#39;bispl&#39;     : scipy.interpolate.bispl{rep,ev}</span>
<span class="sd">            * &#39;ct&#39;        : scipy.interpolate.CloughTocher2DInterpolator</span>
<span class="sd">            * &#39;linear&#39;    : scipy.interpolate.LinearNDInterpolator</span>
<span class="sd">            * &#39;nearest&#39;   : scipy.interpolate.NearestNDInterpolator</span>
<span class="sd">        **initkwds :</span>
<span class="sd">            keywords passed on to the interpolator&#39;s constructor or</span>
<span class="sd">            fit() method (RBF case)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Despite the name &quot;Interpol2D&quot;, the RBF methods &#39;rbf_*&#39; as well as</span>
<span class="sd">        &#39;poly&#39; are actually regression methods. You can force interpolation</span>
<span class="sd">        with the RBF methods using the ``r=0`` keyword (see</span>
<span class="sd">        :class:`~pwtools.rbf.core.Rbf`), which will use ``scipy.linalg.solve``</span>
<span class="sd">        without regularization.</span>

<span class="sd">        The methods &#39;ct&#39;, &#39;linear&#39; and of course &#39;nearest&#39; can be inaccurate</span>
<span class="sd">        (see also ``test/test_interpol.py``). Use only for plotting, not for</span>
<span class="sd">        data evaluation, i.e. accurate minimas etc.</span>

<span class="sd">        Except for &#39;bispl&#39;, all interpolators do actually work in ND as well, as</span>
<span class="sd">        does :meth:`get_min`.</span>

<span class="sd">        Possible keywords (examples):</span>

<span class="sd">        * rbf</span>

<span class="sd">          * p=&#39;mean&#39;, r=0 (default)    # linalg.solve w/o regularization</span>
<span class="sd">          * p=3.5, r=0                 # linalg.solve w/o regularization</span>
<span class="sd">          * p=&#39;scipy&#39;, r=1e-8          # linalg.solve w/ regularization</span>

<span class="sd">        * ct</span>

<span class="sd">          * tol = 1e-6 (default)</span>

<span class="sd">        * bispl</span>

<span class="sd">            * kx = 3, ky = 3 (default)</span>
<span class="sd">            * s = 1e-4</span>
<span class="sd">            * nxest, nyest</span>

<span class="sd">        * poly</span>

<span class="sd">          * deg = 5</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; from pwtools import num, mpl</span>
<span class="sd">        &gt;&gt;&gt; x=linspace(-5,5,20)</span>
<span class="sd">        &gt;&gt;&gt; y=x</span>
<span class="sd">        &gt;&gt;&gt; X,Y=np.meshgrid(x,y); X=X.T; Y=Y.T</span>
<span class="sd">        &gt;&gt;&gt; Z=(X+3)**2+(Y+4)**2 + 5</span>
<span class="sd">        &gt;&gt;&gt; dd=mpl.Data2D(X=X,Y=Y,Z=Z)</span>
<span class="sd">        &gt;&gt;&gt; fmt=&quot;what: {:15} target: [5,30] result: {}&quot;</span>
<span class="sd">        &gt;&gt;&gt; for method in [(&#39;rbf_multi&#39;, dict(r=1e-10)),</span>
<span class="sd">        ...                (&#39;rbf_inv_multi&#39;, dict(r=1e-10)),</span>
<span class="sd">        ...                (&#39;rbf_gauss&#39;, dict(r=1e-10)),</span>
<span class="sd">        ...                (&#39;poly&#39;, {&#39;deg&#39;: 5}),</span>
<span class="sd">        ...                &#39;ct&#39;, &#39;bispl&#39;, &#39;linear&#39;, &#39;nearest&#39;]:</span>
<span class="sd">        ...     if isinstance(method, tuple):</span>
<span class="sd">        ...         what = method[0]</span>
<span class="sd">        ...         kwds = method[1]</span>
<span class="sd">        ...     else:</span>
<span class="sd">        ...         what = method</span>
<span class="sd">        ...         kwds = {}</span>
<span class="sd">        ...     inter=num.Interpol2D(dd=dd, what=what, **kwds)</span>
<span class="sd">        ...     print(fmt.format(what, inter([[-3,-4],[0,0]])))</span>
<span class="sd">        what: rbf_multi       target: [5,30] result: [  5.00000005  29.99999959]</span>
<span class="sd">        what: rbf_inv_multi   target: [5,30] result: [  4.99999808  29.99999798]</span>
<span class="sd">        what: rbf_gauss       target: [5,30] result: [  5.00000051  30.00000352]</span>
<span class="sd">        what: poly            target: [5,30] result: [  5.  30.]</span>
<span class="sd">        what: ct              target: [5,30] result: [  4.99762256  30.010856  ]</span>
<span class="sd">        what: bispl           target: [5,30] result: [  5.  30.]</span>
<span class="sd">        what: linear          target: [5,30] result: [  5.06925208  30.13850416]</span>
<span class="sd">        what: nearest         target: [5,30] result: [  5.01385042  33.82271468]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">xx</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">yy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xx</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yy</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
            <span class="k">elif</span> <span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xx</span> <span class="o">=</span> <span class="n">xx</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">yy</span> <span class="o">=</span> <span class="n">yy</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;use points+values or xx+yy+values as input&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">dd</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span>
                <span class="n">dd</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span>
                <span class="n">dd</span><span class="o">.</span><span class="n">zz</span><span class="p">,</span>
                <span class="n">dd</span><span class="o">.</span><span class="n">XY</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># need to import here b/c of circular dependency rbf.py &lt;-&gt; num.py</span>
        <span class="k">if</span> <span class="n">what</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;rbf_&quot;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">pwtools</span> <span class="k">import</span> <span class="n">rbf</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;rbf_multi&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inter</span> <span class="o">=</span> <span class="n">rbf</span><span class="o">.</span><span class="n">Rbf</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rbf</span><span class="o">=</span><span class="s2">&quot;multi&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">initkwds</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;rbf_inv_multi&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inter</span> <span class="o">=</span> <span class="n">rbf</span><span class="o">.</span><span class="n">Rbf</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rbf</span><span class="o">=</span><span class="s2">&quot;inv_multi&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">initkwds</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;rbf_gauss&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inter</span> <span class="o">=</span> <span class="n">rbf</span><span class="o">.</span><span class="n">Rbf</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">rbf</span><span class="o">=</span><span class="s2">&quot;gauss&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">initkwds</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;poly&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inter</span> <span class="o">=</span> <span class="n">PolyFit</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">initkwds</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_poly_format_return</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;ct&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">CloughTocher2DInterpolator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;could not import &quot;</span>
                    <span class="s2">&quot;scipy.interpolate.CloughTocher2DInterpolator&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inter</span> <span class="o">=</span> <span class="n">CloughTocher2DInterpolator</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">initkwds</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">NearestNDInterpolator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;could not import &quot;</span>
                    <span class="s2">&quot;scipy.interpolate.NearestNDInterpolator&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inter</span> <span class="o">=</span> <span class="n">NearestNDInterpolator</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">initkwds</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">LinearNDInterpolator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
                    <span class="s2">&quot;could not import &quot;</span>
                    <span class="s2">&quot;scipy.interpolate.LinearNDInterpolator&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inter</span> <span class="o">=</span> <span class="n">LinearNDInterpolator</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">initkwds</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inter</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;bispl&quot;</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="p">))))</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yy</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">yy</span><span class="p">))))</span>
            <span class="n">_initkwds</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;kx&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;ky&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;nxest&quot;</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">nx</span><span class="p">,</span> <span class="s2">&quot;nyest&quot;</span><span class="p">:</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">ny</span><span class="p">}</span>
            <span class="n">_initkwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">initkwds</span><span class="p">)</span>
            <span class="n">bispl</span> <span class="o">=</span> <span class="n">bisplrep</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">**</span><span class="n">_initkwds</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">bispl</span><span class="o">=</span><span class="n">bispl</span><span class="p">,</span> <span class="o">**</span><span class="n">callkwds</span><span class="p">):</span>
                <span class="c1"># For unordered points, we need to loop.</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">bisplev</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">bispl</span><span class="p">,</span> <span class="o">**</span><span class="n">callkwds</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="p">]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">inter</span> <span class="o">=</span> <span class="n">_call</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">call</span> <span class="o">=</span> <span class="n">_call</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unknown interpolator type: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">what</span><span class="p">)</span></div>

    <span class="c1"># See pwtools.test.test_polyfit.test_api: work around subtle PolyFit API</span>
    <span class="c1"># difference to all other interpolators w/o breaking neither Interpol2D&#39;s</span>
    <span class="c1"># nor PolyFit&#39;s API</span>
    <span class="k">def</span> <span class="nf">_poly_format_return</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">))</span>

<div class="viewcode-block" id="Interpol2D.__call__"><a class="viewcode-back" href="../../generated/api/pwtools.num.Interpol2D.html#pwtools.num.Interpol2D.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">callkwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : 2d (M,2) or 1d (N,)</span>
<span class="sd">            M points in 2-dim space where to evalutae the interpolator</span>
<span class="sd">            (only one in 1d case)</span>
<span class="sd">        **callkwds : keywords passed to the interpolator&#39;s __call__ method</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Y : 1d array (M,)</span>
<span class="sd">            interpolated values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">callkwds</span><span class="p">)</span></div>

<div class="viewcode-block" id="Interpol2D.get_min"><a class="viewcode-back" href="../../generated/api/pwtools.num.Interpol2D.get_min.html#pwtools.num.Interpol2D.get_min">[docs]</a>    <span class="k">def</span> <span class="nf">get_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return [x,y] where z(x,y) = min(z) by minimizing z(x,y) w/</span>
<span class="sd">        scipy.optimize.fmin().</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x0 : sequence, length (2,), optional</span>
<span class="sd">            Initial guess. If None then use the data grid point with the</span>
<span class="sd">            smallest `z` value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        [xmin, ymin]: 1d array (2,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mf">1e4</span><span class="p">)</span>
        <span class="n">_kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">xx</span><span class="p">[</span><span class="n">idx0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">yy</span><span class="p">[</span><span class="n">idx0</span><span class="p">]]</span>
        <span class="n">xopt</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xopt</span></div></div>


<div class="viewcode-block" id="fempty"><a class="viewcode-back" href="../../generated/api/pwtools.num.fempty.html#pwtools.num.fempty">[docs]</a><span class="k">def</span> <span class="nf">fempty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="distsq"><a class="viewcode-back" href="../../generated/api/pwtools.num.distsq.html#pwtools.num.distsq">[docs]</a><span class="k">def</span> <span class="nf">distsq</span><span class="p">(</span><span class="n">arrx</span><span class="p">,</span> <span class="n">arry</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Squared distances between all points in `arrx` and `arry`:</span>

<span class="sd">    .. math::</span>

<span class="sd">        r_{ij}^2 = \sum_k (\texttt{arrx}[i,k] - \texttt{arry}[j,k])^2 \\</span>
<span class="sd">        i = 1..M_x \\</span>
<span class="sd">        j = 1..M_y \\</span>
<span class="sd">        k = 1..N</span>

<span class="sd">    This is like</span>
<span class="sd">        scipy.spatial.distance.cdist(arrx, arry)**2.0</span>

<span class="sd">    This is a wrapper for :func:`pwtools._flib.distsq`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrx, arry : ndarray (Mx,N), (My,N)</span>
<span class="sd">        Mx (My) points in N-dim space</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    2d array (Mx,My)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">arrx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">arrx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ndimx</span><span class="p">,</span> <span class="n">ndimy</span> <span class="o">=</span> <span class="n">arrx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arry</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">ndimx</span> <span class="o">==</span> <span class="n">ndimy</span><span class="p">,</span> <span class="s2">&quot;ndimx (</span><span class="si">%s</span><span class="s2">, shape: </span><span class="si">%s</span><span class="s2">) != ndimy (</span><span class="si">%s</span><span class="s2">, shape: </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">ndimx</span><span class="p">),</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">arrx</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">ndimy</span><span class="p">),</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">arry</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="c1"># Allocating in F-order is essential for speed! For many points, this step</span>
    <span class="c1"># is actually the bottleneck, NOT the Fortran code! This is b/c if `dist`</span>
    <span class="c1"># is order=&#39;C&#39; (numpy default), then the f2py wrapper makes a copy of the</span>
    <span class="c1"># array before starting to crunch numbers.</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arrx</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_flib</span><span class="o">.</span><span class="n">distsq</span><span class="p">(</span><span class="n">arrx</span><span class="p">,</span> <span class="n">arry</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">ndim</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataND"><a class="viewcode-back" href="../../generated/api/pwtools.num.DataND.html#pwtools.num.DataND">[docs]</a><span class="k">class</span> <span class="nc">DataND</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform 2d array `a2` to nd array `an`. The 2d array&#39;s last column are</span>
<span class="sd">    values on a grid represented by the nd array. The 2d array is the</span>
<span class="sd">    &quot;flattened&quot; version of the nd array. Works only for ordered axes where `a2`</span>
<span class="sd">    was generated by a nested loop over ordered 1d sequences, i.e.</span>

<span class="sd">    &gt;&gt;&gt; nx,ny,nz = len(x),len(y),len(z)</span>
<span class="sd">    &gt;&gt;&gt; for ii in range(nx):</span>
<span class="sd">    ...     for jj in range(ny):</span>
<span class="sd">    ...         for kk in range(nz):</span>
<span class="sd">    ...             idx = ii*ny*nz + jj*nz + kk</span>
<span class="sd">    ...             a2[idx,0] = x[ii]</span>
<span class="sd">    ...             a2[idx,1] = y[jj]</span>
<span class="sd">    ...             a2[idx,2] = z[kk]</span>
<span class="sd">    ...             a2[idx,3] = &lt;some value&gt;</span>
<span class="sd">    &gt;&gt;&gt; axes = [x,y,z]</span>

<span class="sd">    The `axes` are also extracted by numpy.unique() from `a2`&#39;s columns,</span>
<span class="sd">    therefore only ordered axes work.</span>

<span class="sd">    The reverse operation `an` -&gt; `a2` is not implemented ATM.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pwtools import num</span>
<span class="sd">    &gt;&gt;&gt; # something to create grid values</span>
<span class="sd">    &gt;&gt;&gt; a=iter(arange(1,100))</span>
<span class="sd">    &gt;&gt;&gt; # Nested loop</span>
<span class="sd">    &gt;&gt;&gt; a2=array([[x,y,z,a.next()] for x in [0,1,2] for y in [0,1] for z in [0,1,2,3]])</span>
<span class="sd">    &gt;&gt;&gt; nd=num.DataND(a2=a2)</span>
<span class="sd">    &gt;&gt;&gt; nd.an.shape</span>
<span class="sd">    (3,2,4)</span>
<span class="sd">    &gt;&gt;&gt; # nd array an[ii,jj,kk]</span>
<span class="sd">    &gt;&gt;&gt; nd.an</span>
<span class="sd">    array([[[ 1,  2,  3,  4],</span>
<span class="sd">            [ 5,  6,  7,  8]],</span>
<span class="sd">           [[ 9, 10, 11, 12],</span>
<span class="sd">            [13, 14, 15, 16]],</span>
<span class="sd">           [[17, 18, 19, 20],</span>
<span class="sd">            [21, 22, 23, 24]]])</span>
<span class="sd">    &gt;&gt;&gt; nd.axes</span>
<span class="sd">    [array([0, 1, 2]), array([0, 1]), array([0, 1, 2, 3])]</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DataND.__init__"><a class="viewcode-back" href="../../generated/api/pwtools.num.DataND.html#pwtools.num.DataND.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">an</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        arr : 2d array (nrows, ncols)</span>

<span class="sd">        Attributes</span>
<span class="sd">        -------</span>
<span class="sd">        nd : nd arry</span>
<span class="sd">        axes : list of 1d arrays</span>
<span class="sd">            The axes of the grid from np.unique()&#39;ed ``ncols-1`` columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">an</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">an</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2_to_an</span><span class="p">()</span></div>

<div class="viewcode-block" id="DataND.a2_to_an"><a class="viewcode-back" href="../../generated/api/pwtools.num.DataND.a2_to_an.html#pwtools.num.DataND.a2_to_an">[docs]</a>    <span class="k">def</span> <span class="nf">a2_to_an</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">colidx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="p">[:,</span> <span class="n">colidx</span><span class="p">])</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">dims</span><span class="p">)))</span>
        <span class="n">an</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># an[1,2,3] == an[(1,2,3)], need way to eliminate loop over index array</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="n">an</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_idx</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">an</span><span class="p">,</span> <span class="n">axes</span></div></div>


<div class="viewcode-block" id="rms"><a class="viewcode-back" href="../../generated/api/pwtools.num.rms.html#pwtools.num.rms">[docs]</a><span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">nitems</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RMS of all elements in a ndarray.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">    nitems : {&#39;all&#39;, float}</span>
<span class="sd">        normalization constant, the sum of squares is divided by this number,</span>
<span class="sd">        set to unity for no normalization, if &#39;all&#39; then use nitems = number of</span>
<span class="sd">        elements in the array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rms : scalar</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nitems</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">nitems</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="n">arr</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nitems</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nitems</span><span class="p">)</span>
    <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">arr</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">nitems</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rms</span></div>


<div class="viewcode-block" id="rms3d"><a class="viewcode-back" href="../../generated/api/pwtools.num.rms3d.html#pwtools.num.rms3d">[docs]</a><span class="k">def</span> <span class="nf">rms3d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">nitems</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;RMS of 3d array along `axis`. Sum all elements of all axes != axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : 3d array</span>
<span class="sd">    axis : int</span>
<span class="sd">        The axis along which the RMS of all sub-arrays is to be computed</span>
<span class="sd">        (usually time axis in MD).</span>
<span class="sd">    nitems : {&#39;all&#39;, float}</span>
<span class="sd">        normalization constant, the sum of squares is divided by this number,</span>
<span class="sd">        set to unity for no normalization, if &#39;all&#39; then use nitems = number of</span>
<span class="sd">        elements in each sub-array along `axis`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rms : 1d array, (arr.shape[axis],)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We could use num.sum() and would be able to generalize to nd arrays. But</span>
    <span class="c1"># not needed now.</span>
    <span class="k">assert</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">axis</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;allowed axis values: -1,0,1,2&quot;</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;arr must be 3d array&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">nitems</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># pick out 1st sub-array along axis</span>
        <span class="n">nitems</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="n">arr</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nitems</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">nitems</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">arr</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nitems</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">arr</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">nitems</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">arr</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">nitems</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rms</span></div>


<div class="viewcode-block" id="inner_points_mask"><a class="viewcode-back" href="../../generated/api/pwtools.num.inner_points_mask.html#pwtools.num.inner_points_mask">[docs]</a><span class="k">def</span> <span class="nf">inner_points_mask</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mask array into `points` where ``points[msk]`` are all &quot;inner&quot; points,</span>
<span class="sd">    i.e. `points` with one level of edge points removed. For 1D, this is simply</span>
<span class="sd">    points[1:-1,:] (assuming ordered points). For ND, we calculate and remove</span>
<span class="sd">    the convex hull.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : nd array (npoints, ndim)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    msk : (npoints, ndim)</span>
<span class="sd">        Bool array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="s2">&quot;points not monotonic&quot;</span>
        <span class="n">msk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">msk</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="k">import</span> <span class="n">Delaunay</span>

        <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">edge_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">tri</span><span class="o">.</span><span class="n">convex_hull</span><span class="p">)</span>
        <span class="n">msk</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">edge_idx</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">msk</span></div>


<div class="viewcode-block" id="poly_str"><a class="viewcode-back" href="../../generated/api/pwtools.num.poly_str.html#pwtools.num.poly_str">[docs]</a><span class="k">def</span> <span class="nf">poly_str</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;String representation of a `ndim`-poly of degree `deg`.&quot;&quot;&quot;</span>
    <span class="n">st</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">pwr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poly_powers</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">deg</span><span class="p">)):</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;x</span><span class="si">%i</span><span class="s2">^</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">pwr</span><span class="p">))</span>
        <span class="n">term</span> <span class="o">=</span> <span class="s2">&quot;a</span><span class="si">%i</span><span class="s2">*&quot;</span> <span class="o">%</span> <span class="n">ii</span> <span class="o">+</span> <span class="n">xx</span>
        <span class="k">if</span> <span class="n">st</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">=</span> <span class="n">term</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st</span> <span class="o">+=</span> <span class="s2">&quot; + </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">term</span>
    <span class="k">return</span> <span class="n">st</span></div>


<div class="viewcode-block" id="poly_powers"><a class="viewcode-back" href="../../generated/api/pwtools.num.poly_powers.html#pwtools.num.poly_powers">[docs]</a><span class="k">def</span> <span class="nf">poly_powers</span><span class="p">(</span><span class="n">ndim</span><span class="p">,</span> <span class="n">deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Powers for building a n-dim polynomial and columns of the n-dim</span>
<span class="sd">    Vandermonde matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ndim : number of dimensions of the poly (e.g. 2 for f(x1,x2))</span>
<span class="sd">    deg : degree of the poly</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    powers : 2d array ``((deg+1)**ndim, ndim)``</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    For one dim, we have data points (x_i,y_i) and the to-be-fitted poly of order</span>
<span class="sd">    k is::</span>

<span class="sd">        f(x) = a0*x^0 + a1*x^1 + a2*x^2 + ... + ak*x^k</span>

<span class="sd">    The Vandermonde matrix A consists of all powers of x (cols) for all data</span>
<span class="sd">    points (rows) and each row has the form of the poly::</span>

<span class="sd">        [[x_0^0 x_0^1 ... x_0^k],</span>
<span class="sd">         [x_1^0 x_1^1 ... x_1^k],</span>
<span class="sd">         ...</span>
<span class="sd">         [x_n^0 x_n^1 ... x_n^k]]</span>

<span class="sd">    To fit, we solve A . a = y, where a = [a0,...,ak].</span>

<span class="sd">    The returned array `powers` has k rows, where each row holds the powers for</span>
<span class="sd">    one term in the poly. For ndim=1 and poly order k, we have::</span>

<span class="sd">        [[0],</span>
<span class="sd">         [1],</span>
<span class="sd">         ...</span>
<span class="sd">         [k]]</span>

<span class="sd">    and::</span>

<span class="sd">        [0] -&gt; x^0</span>
<span class="sd">        [1] -&gt; x^1</span>
<span class="sd">        ...</span>
<span class="sd">        [k] -&gt; x^k</span>

<span class="sd">    Now, suppose we have 2 dims, thus data points (x0_i,x1_i,y_i) and a poly</span>
<span class="sd">    of order 2::</span>

<span class="sd">        f(x0,x1) = a0*x0^0*x1^0 + a1*x0^0*x1^1 + a2*x0^0*x1^2 + a3*x0^1*x1^0 +</span>
<span class="sd">                   a4*x0^1*x1^1 + a5*x0^1*x1^2 + a6*x0^2*x1^0 + a7*x0^2*x1^1 +</span>
<span class="sd">                   a8*x0^2*x1^2</span>

<span class="sd">    with 9 coeffs a = [a0,...,a8]. Therefore, ``powers.shape = (9,2)``::</span>

<span class="sd">        [[0, 0],</span>
<span class="sd">         [0, 1],</span>
<span class="sd">         [0, 2],</span>
<span class="sd">         [1, 0],</span>
<span class="sd">         [1, 1],</span>
<span class="sd">         [1, 2],</span>
<span class="sd">         [2, 0],</span>
<span class="sd">         [2, 1],</span>
<span class="sd">         [2, 2]]</span>

<span class="sd">    and::</span>

<span class="sd">        [0,0] -&gt; x0^0*x1^0</span>
<span class="sd">        [1,2] -&gt; x0^1*x1^2</span>
<span class="sd">        ...</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="n">ndim</span><span class="p">)))</span></div>


<div class="viewcode-block" id="vander"><a class="viewcode-back" href="../../generated/api/pwtools.num.vander.html#pwtools.num.vander">[docs]</a><span class="k">def</span> <span class="nf">vander</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;N-dim Vandermonde matrix for data `points` and a polynomial of degree</span>
<span class="sd">    `deg`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : see polyfit()</span>
<span class="sd">    deg : int</span>
<span class="sd">        Degree of the poly (e.g. 3 for cubic).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    vander : 2d array (npoints, (deg+1)**ndim)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">powers</span> <span class="o">=</span> <span class="n">poly_powers</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">deg</span><span class="p">)</span>
    <span class="c1"># low memory version, slower</span>
    <span class="c1">##npoints = points.shape[0]</span>
    <span class="c1">##vand = np.empty((npoints, (deg+1)**ndim), dtype=float)</span>
    <span class="c1">##for ipoint in range(npoints):</span>
    <span class="c1">##    vand[ipoint,:] = (points[ipoint]**powers).prod(axis=1)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">powers</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="polyfit"><a class="viewcode-back" href="../../generated/api/pwtools.num.polyfit.html#pwtools.num.polyfit">[docs]</a><span class="k">def</span> <span class="nf">polyfit</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale_vand</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fit nd polynomial of dregree `deg`. The dimension is ``points.shape[1]``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : nd array (npoints,ndim)</span>
<span class="sd">        `npoints` points in `ndim`-space, to be fitted by a `ndim` polynomial</span>
<span class="sd">        f(x0,x1,...,x{ndim-1}).</span>
<span class="sd">    values : 1d array</span>
<span class="sd">    deg : int</span>
<span class="sd">        Degree of the poly (e.g. 3 for cubic).</span>
<span class="sd">    scale: bool, optional</span>
<span class="sd">        Scale `points` and `values` to unity internally before fitting.</span>
<span class="sd">        ``fit[&#39;coeffs&#39;]`` are for scaled data. ``polyval`` handles that</span>
<span class="sd">        transparently.</span>
<span class="sd">    scale_vand : bool, optional</span>
<span class="sd">        scale Vandermonde matrix as in numpy.polyfit (devide by column norms to</span>
<span class="sd">        improve condition number)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fit : dict</span>
<span class="sd">        {coeffs, deg, pscale, vscale, pmin, vmin} where coeffs = 1d array</span>
<span class="sd">        ((deg+1)**ndim,) with poly coefficients and `*min` and `*scale` are for</span>
<span class="sd">        data scaling. Input for polyval().</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `scale`: `numpy.polyfit` does only `scale_vand` by default, which seems to be</span>
<span class="sd">    enough for most real world data. The new `np.polynomial.Polynomial.fit`</span>
<span class="sd">    now does the equivalent of what we do here with `scale`, **but they do it</span>
<span class="sd">    only for `points`, not `values`**. They map to [-1,1], we use [0,1].</span>

<span class="sd">    In most tests so far, `scale_vand` and `scale` have pretty much the same</span>
<span class="sd">    effect: enable fitting data with very different scales on x and y.</span>

<span class="sd">    Because ``fit[&#39;coeffs&#39;]`` are w.r.t. scaled data, you cannot compare them</span>
<span class="sd">    to the result of `np.polyfit` directly. Only with `scale=False` you can</span>
<span class="sd">    compare the coeffs, which should be the same up to numerical noise.</span>
<span class="sd">    However, you may simply compare the resulting fits, evaluated at the same</span>
<span class="sd">    points.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`PolyFit`, :class:`PolyFit1D`, :func:`polyval`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;points must be 2d array&quot;</span>
    <span class="k">assert</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;values must be 1d array&quot;</span>
    <span class="k">assert</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">),</span> <span class="s2">&quot;points and values must have same length&quot;</span>
    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="n">pmin</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">pscale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">points</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">pmin</span>
        <span class="n">vscale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">values</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">vmin</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pscale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">vscale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">pmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">vand</span> <span class="o">=</span> <span class="n">vander</span><span class="p">((</span><span class="n">points</span> <span class="o">-</span> <span class="n">pmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">pscale</span><span class="p">,</span> <span class="n">deg</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">scale_vand</span><span class="p">:</span>
        <span class="n">sv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">vand</span> <span class="o">*</span> <span class="n">vand</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">vand</span> <span class="o">/</span> <span class="n">sv</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">vand</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span> <span class="p">(</span><span class="n">values</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">vscale</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">scale_vand</span><span class="p">:</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coeffs</span> <span class="o">/</span> <span class="n">sv</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;coeffs&quot;</span><span class="p">:</span> <span class="n">coeffs</span><span class="p">,</span>
        <span class="s2">&quot;deg&quot;</span><span class="p">:</span> <span class="n">deg</span><span class="p">,</span>
        <span class="s2">&quot;pscale&quot;</span><span class="p">:</span> <span class="n">pscale</span><span class="p">,</span>
        <span class="s2">&quot;vscale&quot;</span><span class="p">:</span> <span class="n">vscale</span><span class="p">,</span>
        <span class="s2">&quot;pmin&quot;</span><span class="p">:</span> <span class="n">pmin</span><span class="p">,</span>
        <span class="s2">&quot;vmin&quot;</span><span class="p">:</span> <span class="n">vmin</span><span class="p">,</span>
        <span class="s2">&quot;ndim&quot;</span><span class="p">:</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="polyval"><a class="viewcode-back" href="../../generated/api/pwtools.num.polyval.html#pwtools.num.polyval">[docs]</a><span class="k">def</span> <span class="nf">polyval</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">der</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Evaluate polynomial generated by :func:`polyfit` on `points`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fit, points : see :func:`polyfit`</span>
<span class="sd">    der : int, optional</span>
<span class="sd">        Derivative order. Only for 1D, uses np.polyder().</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For 1D we provide &quot;analytic&quot; derivatives using np.polyder(). For ND, we</span>
<span class="sd">    didn&#39;t implement an equivalent machinery. For 2D, you might get away with</span>
<span class="sd">    fitting a bispline (see Interpol2D) and use it&#39;s derivs. For ND, try rbf.py&#39;s RBF</span>
<span class="sd">    interpolator which has at least 1st derivatives for arbitrary dimensions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :class:`PolyFit`, :class:`PolyFit1D`, :func:`polyfit`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;points must be 2d array&quot;</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">p_ndim</span> <span class="p">:</span><span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="p">(</span>
        <span class="n">f_ndim</span> <span class="p">:</span><span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;ndim&quot;</span><span class="p">]</span>
    <span class="p">),</span> <span class="n">f</span><span class="s2">&quot;points have wrong ndim: </span><span class="si">{p_ndim}</span><span class="s2">, expect </span><span class="si">{f_ndim}</span><span class="s2">&quot;</span>
    <span class="n">pscale</span><span class="p">,</span> <span class="n">pmin</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;pscale&quot;</span><span class="p">],</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;pmin&quot;</span><span class="p">]</span>
    <span class="n">vscale</span><span class="p">,</span> <span class="n">vmin</span> <span class="o">=</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;vscale&quot;</span><span class="p">],</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;vmin&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">der</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;deriv only for 1d poly (ndim=1)&quot;</span>
        <span class="c1"># ::-1 b/c numpy stores poly coeffs in reversed order</span>
        <span class="n">dcoeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="s2">&quot;coeffs&quot;</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="o">=</span><span class="n">der</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">dcoeffs</span><span class="p">,</span> <span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pmin</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">pscale</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="o">/</span> <span class="n">pscale</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="n">der</span>
            <span class="o">*</span> <span class="n">vscale</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vand</span> <span class="o">=</span> <span class="n">vander</span><span class="p">((</span><span class="n">points</span> <span class="o">-</span> <span class="n">pmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">pscale</span><span class="p">,</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;deg&quot;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vand</span><span class="p">,</span> <span class="n">fit</span><span class="p">[</span><span class="s2">&quot;coeffs&quot;</span><span class="p">])</span> <span class="o">*</span> <span class="n">vscale</span> <span class="o">+</span> <span class="n">vmin</span></div>


<div class="viewcode-block" id="PolyFit"><a class="viewcode-back" href="../../generated/api/pwtools.num.PolyFit.html#pwtools.num.PolyFit">[docs]</a><span class="k">class</span> <span class="nc">PolyFit</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;High level interface to poly{fit,val}, similar to :class:`Spline`</span>
<span class="sd">    and :class:`Interpol2D`.</span>

<span class="sd">    Arguments and keywords to :meth:`__init__` are the same as for</span>
<span class="sd">    :func:`polyfit`. Keywords to :meth:`__call__` are same as for</span>
<span class="sd">    :func:`polyval`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    points : nd array (npoints,ndim)</span>
<span class="sd">        `npoints` points in `ndim`-space, to be fitted by a `ndim` polynomial</span>
<span class="sd">        f(x0,x1,...,x{ndim-1}).</span>
<span class="sd">    values : 1d array</span>
<span class="sd">    deg : int</span>
<span class="sd">        Degree of the poly (e.g. 3 for cubic).</span>
<span class="sd">    scale: bool, optional</span>
<span class="sd">        Scale `points` and `values` to unity internally before fitting.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    | __init__: `points` must be (npoints,ndim) even if ndim=1.</span>
<span class="sd">    | __call__: `points` can be (ndim,) instead of (1,ndim), need this if called in</span>
<span class="sd">                fmin()</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; fit1=polyfit(points, values, deg=3); polyval(fit1, new_points)</span>
<span class="sd">    &gt;&gt;&gt; # the same</span>
<span class="sd">    &gt;&gt;&gt; f1=PolyFit(points, values, 3); f1(new_points)</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PolyFit.__init__"><a class="viewcode-back" href="../../generated/api/pwtools.num.PolyFit.html#pwtools.num.PolyFit.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        points : nd array (npoints, ndim)</span>
<span class="sd">        values : 1d array (npoints,)</span>
<span class="sd">        **kwds : keywords to polyfit()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_shape_init</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;points is not 2d array&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitfunc</span> <span class="o">=</span> <span class="n">polyfit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">evalfunc</span> <span class="o">=</span> <span class="n">polyval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_fix_shape_init</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">points</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_fix_shape_call</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="n">points</span><span class="p">,</span> <span class="s2">&quot;ndim&quot;</span>
        <span class="p">),</span> <span class="s2">&quot;points must be an array with ndim attr&quot;</span>
        <span class="c1"># (ndim,) -&gt; (1,ndim) -&gt; 1 point in ndim space</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">points</span>

<div class="viewcode-block" id="PolyFit.__call__"><a class="viewcode-back" href="../../generated/api/pwtools.num.PolyFit.html#pwtools.num.PolyFit.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="n">_got_single_point</span><span class="p">,</span> <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fix_shape_call</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">evalfunc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">_got_single_point</span> <span class="k">else</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="PolyFit.get_min"><a class="viewcode-back" href="../../generated/api/pwtools.num.PolyFit.get_min.html#pwtools.num.PolyFit.get_min">[docs]</a>    <span class="k">def</span> <span class="nf">get_min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Minimize fit function by `scipy.optimize.fmin()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x0 : 1d array, optional</span>
<span class="sd">            Initial guess. If not given then `points[i,...]` at the min of</span>
<span class="sd">            `values` is used.</span>
<span class="sd">        **kwds : keywords to fmin()</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        1d array (ndim,)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_kwds</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">disp</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span> <span class="n">ftol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">maxfun</span><span class="o">=</span><span class="mf">1e4</span><span class="p">,</span> <span class="n">maxiter</span><span class="o">=</span><span class="mf">1e4</span><span class="p">)</span>
        <span class="n">_kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
        <span class="n">xopt</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="o">**</span><span class="n">_kwds</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xopt</span></div></div>


<span class="c1"># Need to inherit first Fit1D such that Fit1D.get_min() is used instead of</span>
<span class="c1"># PolyFit.get_min().</span>
<div class="viewcode-block" id="PolyFit1D"><a class="viewcode-back" href="../../generated/api/pwtools.num.PolyFit1D.html#pwtools.num.PolyFit1D">[docs]</a><span class="k">class</span> <span class="nc">PolyFit1D</span><span class="p">(</span><span class="n">Fit1D</span><span class="p">,</span> <span class="n">PolyFit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;1D special case version of :class:`PolyFit` which handles 1d and scalar</span>
<span class="sd">    `points` Also :meth:`get_min()` uses the root of the poly&#39;s 1st derivative</span>
<span class="sd">    instead of ``fmin()``.</span>

<span class="sd">    | __init__: points (npoints,1) or (npoints,)</span>
<span class="sd">    | __call__: points (npoints,1) or (npoints,) or scalar</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x=np.linspace(-5,5,10); y=(x-1)**2+1</span>
<span class="sd">    &gt;&gt;&gt; f=num.PolyFit1D(x,y,2)</span>
<span class="sd">    &gt;&gt;&gt; f(0)</span>
<span class="sd">    2.0000000000000009</span>
<span class="sd">    &gt;&gt;&gt; f.get_min()</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; xx = linspace(x[0],x[-1],50)</span>
<span class="sd">    &gt;&gt;&gt; plot(x,y,&#39;o&#39;, label=&#39;data&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plot(xx, f(xx), label=&#39;poly&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plot(xx, f(xx,der=1), label=&#39;d(poly)/dx&#39;)</span>
<span class="sd">    &gt;&gt;&gt; legend()</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PolyFit1D.__init__"><a class="viewcode-back" href="../../generated/api/pwtools.num.PolyFit1D.html#pwtools.num.PolyFit1D.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        See PolyFit</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to exec PolyFit.__init__() here expliclity. Using super(...)</span>
        <span class="c1"># would call Fit1D.__init__().</span>
        <span class="n">PolyFit</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">),</span> <span class="s2">&quot;points has wrong shape: </span><span class="si">%s</span><span class="s2">, expect (npoints,1)&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span>
        <span class="p">)</span>
        <span class="c1"># set self.x, self.y, need that in Fit1D._findroot()</span>
        <span class="n">Fit1D</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">values</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_fix_shape_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># 1 -&gt; (1,1)</span>
        <span class="k">if</span> <span class="n">pp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">pp</span><span class="p">]])</span>
        <span class="c1"># (M,) -&gt; (M,1)</span>
        <span class="k">elif</span> <span class="n">pp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pp</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="c1"># (M,N)</span>
        <span class="k">elif</span> <span class="n">pp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">pp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">[</span><span class="s2">&quot;ndim&quot;</span><span class="p">],</span> <span class="s2">&quot;points have wrong ndim&quot;</span>
            <span class="k">return</span> <span class="n">pp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;points has wrong shape or dim&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_fix_shape_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">pp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="c1"># 1 -&gt; (1,1)</span>
        <span class="k">if</span> <span class="n">pp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">pp</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">[</span><span class="s2">&quot;ndim&quot;</span><span class="p">]:</span>
                    <span class="c1"># (N,) -&gt; (1,N)</span>
                    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">pp</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># (M,) -&gt; (M,1)</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">pp</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">pp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span>
                    <span class="n">pp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit</span><span class="p">[</span><span class="s2">&quot;ndim&quot;</span><span class="p">]</span>
                <span class="p">),</span> <span class="s2">&quot;points have wrong ndim&quot;</span>
                <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">pp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;points has wrong shape or dim&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="match_mask"><a class="viewcode-back" href="../../generated/api/pwtools.num.match_mask.html#pwtools.num.match_mask">[docs]</a><span class="k">def</span> <span class="nf">match_mask</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">fullout</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bool array of ``len(arr)`` which is True if ``arr[i] == values[j],</span>
<span class="sd">    j=0..len(values)``.</span>

<span class="sd">    This is the same as creating bool arrays like ``arr == some_value`` just</span>
<span class="sd">    that `some_value` can be an array (numpy can only do `some_value` =</span>
<span class="sd">    scalar). By default we assume integer arrays, unless `eps` is used.</span>

<span class="sd">    With `eps=None` and `fullout=False`, it behaves like ``numpy.in1d``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : 1d array</span>
<span class="sd">    values : 1d array</span>
<span class="sd">        Values to be found in `arr`.</span>
<span class="sd">    fullout : bool</span>
<span class="sd">    eps : float</span>
<span class="sd">        Use this threshold to compare array values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : fullout = False</span>
<span class="sd">    ret, idx_lst : fullout = True</span>
<span class="sd">    ret : 1d array, bool, len(arr)</span>
<span class="sd">        Bool mask array for indexing `arr`. ``arr[ret]`` pulls out all values</span>
<span class="sd">        which are also in `values`.</span>
<span class="sd">    idx_lst : 1d array</span>
<span class="sd">        Indices for which ``arr[idx_lst[i]]`` equals some value in `values`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; arr=array([1,2,3,4,5]); values=array([1,3])</span>
<span class="sd">    &gt;&gt;&gt; num.match_mask(arr, values)</span>
<span class="sd">    array([ True, False,  True, False, False], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; num.match_mask(arr, values, fullout=True)</span>
<span class="sd">    (array([ True, False,  True, False, False], dtype=bool), array([0, 2]))</span>
<span class="sd">    &gt;&gt;&gt; arr[num.match_mask(arr, values)]</span>
<span class="sd">    array([1, 3])</span>
<span class="sd">    &gt;&gt;&gt; # handle cases where len(values) &gt; len(arr) and values not contained in arr</span>
<span class="sd">    &gt;&gt;&gt; arr=array([1,2,3,4,5]); values=array([1,3,3,3,7,9,-3,-4,-5])</span>
<span class="sd">    &gt;&gt;&gt; num.match_mask(arr, values, fullout=True)</span>
<span class="sd">    (array([ True, False,  True, False, False], dtype=bool), array([0, 2]))</span>
<span class="sd">    &gt;&gt;&gt; # float values: use eps</span>
<span class="sd">    &gt;&gt;&gt; num.match_mask(arr+0.1, values, fullout=True, eps=0.2)</span>
<span class="sd">    (array([ True, False,  True, False, False], dtype=bool), array([0, 2]))</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.in1d</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;arr must be 1d array&quot;</span>
    <span class="k">if</span> <span class="n">eps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assume integer array</span>
        <span class="n">idx_lst</span> <span class="o">=</span> <span class="p">((</span><span class="n">arr</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">values</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">idx_lst</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">values</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">idx_lst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idx_lst</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">idx_lst</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fullout</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">,</span> <span class="n">idx_lst</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="order_similar"><a class="viewcode-back" href="../../generated/api/pwtools.num.order_similar.html#pwtools.num.order_similar">[docs]</a><span class="k">def</span> <span class="nf">order_similar</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Band ordering algorithm. Uses up to quadradic extrapolation. Handles</span>
<span class="sd">    crossing points.</span>

<span class="sd">    This can be used to order dispersion plots, for instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : 2d array (npoints, ndim)</span>
<span class="sd">        `ndim` 1d data streams with `npoints` each.</span>
<span class="sd">    repeat : int</span>
<span class="sd">        1: run 1 time, N: run recursively N times</span>
<span class="sd">    order : int</span>
<span class="sd">        Order of extrapolation: 0 = next similar point, 1 = linear using the</span>
<span class="sd">        two last points, 2 = quadratic using the 3 last points</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    arr2 : like `arr`</span>
<span class="sd">        Array with ordered data series.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The more points, the better. The first 1-2 steps should start smoothly or</span>
<span class="sd">    the algo will get confused. If you don&#39;t get all crossing points resolved,</span>
<span class="sd">    try ``repeat &gt; 1``. But if the algo placed points from different data</span>
<span class="sd">    streams into one, you are lost. Then you can only use more points to make</span>
<span class="sd">    the extrapolation more precise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pwtools import mpl, num</span>
<span class="sd">    &gt;&gt;&gt; plt = mpl.plt</span>
<span class="sd">    &gt;&gt;&gt; x = np.linspace(0,10,200)</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([np.sin(0.5*x),</span>
<span class="sd">    ...               1.2*np.cos(2*x),</span>
<span class="sd">    ...               np.sin(2.5*(x-1.5)),</span>
<span class="sd">    ...               0.2*np.sin(x-1.1),</span>
<span class="sd">    ...               0.3*np.sin(x-1.1),</span>
<span class="sd">    ...               ]).T</span>
<span class="sd">    &gt;&gt;&gt; for ai in a:</span>
<span class="sd">    ...     np.random.shuffle(ai)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(); plt.plot(a); plt.title(&#39;raw data&#39;)</span>
<span class="sd">    &gt;&gt;&gt; aa = num.order_similar(a, repeat=1, order=2)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(); plt.plot(aa); plt.title(&#39;sorted, repeat=1, order=2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; aa = num.order_similar(a, repeat=2, order=1)</span>
<span class="sd">    &gt;&gt;&gt; plt.figure(); plt.plot(aa); plt.title(&#39;sorted, repeat=2, order=1&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">order</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;order must be 0,1,2&quot;</span>
    <span class="k">assert</span> <span class="n">repeat</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;repeat must be &gt;= 1&quot;</span>
    <span class="n">_o_zero</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_o_one</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_o_two</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">_o_zero</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">_o_one</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">_o_two</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">repeat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">ni</span><span class="p">,</span> <span class="n">nj</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">arr2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ni</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nj</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ii</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_o_zero</span><span class="p">:</span>
                    <span class="c1"># 1st row: choose next similar point</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">ii</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_o_one</span><span class="p">:</span>
                    <span class="c1"># 2 rows: linear extrapolation</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">arr2</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">-</span> <span class="n">arr2</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">ii</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_o_two</span><span class="p">:</span>
                    <span class="c1"># &gt; 2 rows: quadradic extrapolation</span>
                    <span class="c1">#</span>
                    <span class="c1"># Calling polyfit is pretty slow and could be</span>
                    <span class="c1"># optimized. For 3 points in x,y, we can write the</span>
                    <span class="c1"># expressions for the coeffs by hand, yes?</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">arr2</span><span class="p">[</span><span class="n">ii</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">:</span> <span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">dif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">ref</span><span class="p">)</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dif</span><span class="p">)</span>
                <span class="n">arr2</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">ii</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arr2</span> <span class="o">=</span> <span class="n">order_similar</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">repeat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr2</span></div>


<div class="viewcode-block" id="round_up_next_multiple"><a class="viewcode-back" href="../../generated/api/pwtools.num.round_up_next_multiple.html#pwtools.num.round_up_next_multiple">[docs]</a><span class="k">def</span> <span class="nf">round_up_next_multiple</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mult</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Round integer `x` up to the next possible multiple of `mult`.&quot;&quot;&quot;</span>
    <span class="n">rem</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">mult</span>
    <span class="k">if</span> <span class="n">rem</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="n">rem</span> <span class="o">+</span> <span class="n">mult</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../generated/api/pwtools.num.norm.html#pwtools.num.norm">[docs]</a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;2-norm for real vectors.&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;input must be 1d array&quot;</span>
    <span class="c1"># math.sqrt is faster than np.sqrt for scalar args</span>
    <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span></div>


<div class="viewcode-block" id="meshgridt"><a class="viewcode-back" href="../../generated/api/pwtools.num.meshgridt.html#pwtools.num.meshgridt">[docs]</a><span class="k">def</span> <span class="nf">meshgridt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shortcut for ``numpy.meshgrid(x, y, indexing=&quot;ij&quot;)``</span>

<span class="sd">    A version of ``X,Y = numpy.meshgrid(x,y)`` which returns X and Y</span>
<span class="sd">    transposed, i.e. (nx, ny) instead (ny, nx) where nx,ny = len(x),len(y).</span>

<span class="sd">    This is useful for dealing with 2D splines in</span>
<span class="sd">    scipy.interpolate.bisplev(), which also returns a (nx,ny) array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x,y : 1d arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">##X,Y = np.meshgrid(x,y)</span>
    <span class="c1">##return X.T, Y.T</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s2">&quot;ij&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="euler_matrix"><a class="viewcode-back" href="../../generated/api/pwtools.num.euler_matrix.html#pwtools.num.euler_matrix">[docs]</a><span class="k">def</span> <span class="nf">euler_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Euler&#39;s rotation matrix.</span>

<span class="sd">    We use the x-convention, as in [1]_.</span>

<span class="sd">    .. math::</span>
<span class="sd">        (\phi, \theta, \psi)        \\</span>
<span class="sd">        A = B\,C\,D                 \\</span>
<span class="sd">        D: \phi = 0,...,2\,\pi      \\</span>
<span class="sd">        C: \theta = 0,...,\pi       \\</span>
<span class="sd">        B: \psi = 0,...,2\,\pi      \\</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    phi, theta, psi : float</span>
<span class="sd">        angles</span>
<span class="sd">    deg : bool</span>
<span class="sd">        angles in degree (True) or radians (False, default)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] http://mathworld.wolfram.com/EulerAngles.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">radians</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">pi</span>
    <span class="k">assert</span> <span class="nb">abs</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span>
    <span class="n">sin_a</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">sin_b</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">sin_c</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
    <span class="n">cos_a</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
    <span class="n">cos_b</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">cos_c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
    <span class="c1"># fmt: off</span>
    <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="n">cos_a</span><span class="p">,</span>  <span class="n">sin_a</span><span class="p">,</span>      <span class="mi">0</span><span class="p">],</span>
                  <span class="p">[</span><span class="o">-</span><span class="n">sin_a</span><span class="p">,</span>  <span class="n">cos_a</span><span class="p">,</span>      <span class="mi">0</span><span class="p">],</span>
                  <span class="p">[</span>     <span class="mi">0</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>      <span class="mi">1</span><span class="p">]])</span><span class="o">*</span><span class="mf">1.0</span>

    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span>     <span class="mi">1</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>      <span class="mi">0</span><span class="p">],</span>
                  <span class="p">[</span>     <span class="mi">0</span><span class="p">,</span>  <span class="n">cos_b</span><span class="p">,</span>  <span class="n">sin_b</span><span class="p">],</span>
                  <span class="p">[</span>     <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">sin_b</span><span class="p">,</span>  <span class="n">cos_b</span><span class="p">]])</span><span class="o">*</span><span class="mf">1.0</span>

    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="n">cos_c</span><span class="p">,</span>  <span class="n">sin_c</span><span class="p">,</span>      <span class="mi">0</span><span class="p">],</span>
                  <span class="p">[</span><span class="o">-</span><span class="n">sin_c</span><span class="p">,</span>  <span class="n">cos_c</span><span class="p">,</span>      <span class="mi">0</span><span class="p">],</span>
                  <span class="p">[</span>     <span class="mi">0</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>      <span class="mi">1</span><span class="p">]])</span><span class="o">*</span><span class="mf">1.0</span>
    <span class="c1"># fmt: on</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">))</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2022, Steve Schmerler.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>