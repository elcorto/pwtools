<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pwtools.signal &#8212; pwtools  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=9121de03" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo"/>
    
    <h1 class="logo logo-name">pwtools</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=elcorto&repo=pwtools&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/index.html">API Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../written/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/background/index.html">Background, details, special topics</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pwtools.signal</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Some general signal procressing tools (FFT, correlation). Mostly textbook and</span>
<span class="sd">reference implementations plus some utilities.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">fft</span><span class="p">,</span> <span class="n">ifft</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">fftconvolve</span><span class="p">,</span> <span class="n">gaussian</span><span class="p">,</span> <span class="n">kaiserord</span><span class="p">,</span> <span class="n">firwin</span><span class="p">,</span> <span class="n">lfilter</span><span class="p">,</span> <span class="n">freqz</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">trapz</span>
<span class="kn">from</span> <span class="nn">pwtools</span> <span class="kn">import</span> <span class="n">_flib</span><span class="p">,</span> <span class="n">num</span>


<div class="viewcode-block" id="fftsample">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.fftsample.html#pwtools.signal.fftsample">[docs]</a>
<span class="k">def</span> <span class="nf">fftsample</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="n">mirr</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert size and resolution between frequency and time domain.</span>

<span class="sd">    Convert between maximal frequency to sample (fmax) + desired frequency</span>
<span class="sd">    resolution (df) and the needed number of sample points (N) + time</span>
<span class="sd">    step (dt).</span>

<span class="sd">    The maximal frequency is also called the Nyquist frequency and is</span>
<span class="sd">    1/2*samplerate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b: float</span>
<span class="sd">        | mode=&#39;f&#39;: a=fmax  b=df</span>
<span class="sd">        | mode=&#39;t&#39;: a=dt    b=N</span>
<span class="sd">    mode : string, {&#39;f&#39;, &#39;t&#39;}</span>
<span class="sd">        | f : frequency mode</span>
<span class="sd">        | t : time mode</span>
<span class="sd">    mirr: bool</span>
<span class="sd">        consider mirroring of the signal at t=0 before Fourier transform</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mode=&#39;f&#39;: array([dt,   N])</span>
<span class="sd">    mode=&#39;t&#39;: array([fmax, df])</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # fmax = 100 Hz, df = 1 Hz -&gt; you need 200 steps with dt=0.005 sec</span>
<span class="sd">    &gt;&gt;&gt; fftsample(100, 1, mode=&#39;f&#39;)</span>
<span class="sd">    array([  5.00000000e-03,   2.00000000e+03])</span>
<span class="sd">    &gt;&gt;&gt; fftsample(5e-3, 2e3, mode=&#39;t&#39;)</span>
<span class="sd">    array([ 100. ,    1.])</span>
<span class="sd">    # If you mirror, you only need 100 steps</span>
<span class="sd">    &gt;&gt;&gt; fftsample(100, 1, mode=&#39;f&#39;, mirr=True)</span>
<span class="sd">    array([  5.00000000e-03,   1.00000000e+02])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    These relations hold:</span>

<span class="sd">    ===========         ===========</span>
<span class="sd">    size                resolution</span>
<span class="sd">    ===========         ===========</span>
<span class="sd">    N [t] up            df [f] down</span>
<span class="sd">    fmax [f] up         dt [t] down</span>
<span class="sd">    ===========         ===========</span>

<span class="sd">    If you know that the signal in the time domain will be mirrored before FFT</span>
<span class="sd">    (N -&gt; 2*N), you will get 1/2*df (double fine resolution), so 1/2*N is</span>
<span class="sd">    sufficient to get the desired df.</span>

<span class="sd">    Units:</span>
<span class="sd">    In general frequency_unit = 1/time_unit, need not be Hz and s.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
        <span class="n">fmax</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span>
        <span class="k">if</span> <span class="n">mirr</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">fmax</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">df</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
        <span class="n">dt</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
        <span class="k">if</span> <span class="n">mirr</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="n">fmax</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">/</span><span class="n">dt</span>
        <span class="n">df</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fmax</span><span class="p">,</span> <span class="n">df</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;illegal mode, allowed: t, f&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="dft">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.dft.html#pwtools.signal.dft">[docs]</a>
<span class="k">def</span> <span class="nf">dft</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;loop&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple straightforward complex DFT algo.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : numpy 1d array</span>
<span class="sd">    method : string, {&#39;matmul&#39;, &#39;loop&#39;}</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    (len(a),) array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.fftpack import fft</span>
<span class="sd">    &gt;&gt;&gt; a=np.random.rand(100)</span>
<span class="sd">    &gt;&gt;&gt; sfft=fft(a)</span>
<span class="sd">    &gt;&gt;&gt; dfft1=dft(a, method=&#39;loop&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dfft2=dft(a, method=&#39;matmul&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.testing.assert_array_almost_equal(sfft, dfft1)</span>
<span class="sd">    &gt;&gt;&gt; np.testing.assert_array_almost_equal(sfft, dfft2)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is only a reference implementation and has it&#39;s limitations.</span>
<span class="sd">        | &#39;loop&#39;: runs looong</span>
<span class="sd">        | &#39;matmul&#39;: memory limit</span>
<span class="sd">        | =&gt; use only with medium size arrays</span>

<span class="sd">    N = len(a)</span>
<span class="sd">    sqrt(complex(-1)) = np.sqrt(-1 + 0*j) = 1j</span>

<span class="sd">    Forward DFT, see [2]_ and [3]_ , scipy.fftpack.fft():</span>
<span class="sd">        y[k] = sum(n=0...N-1) a[n] * exp(-2*pi*n*k*j/N)</span>
<span class="sd">        k = 0 ... N-1</span>

<span class="sd">    Backward DFT, see [1]_ eq. 12.1.6, 12.2.2:</span>
<span class="sd">        y[k] = sum(n=0...N-1) a[n] * exp(2*pi*n*k*j/N)</span>
<span class="sd">        k = 0 ... N-1</span>

<span class="sd">    The algo for method==&#39;matmul&#39; is the matrix mult from [1]_, but as Forward</span>
<span class="sd">    DFT for comparison with scipy. The difference between FW and BW DFT is that</span>
<span class="sd">    the imaginary parts are mirrored at y=0.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Numerical Recipes in Fortran, Second Edition, 1992</span>
<span class="sd">    .. [2] http://www.fftw.org/doc/The-1d-Real_002ddata-DFT.html</span>
<span class="sd">    .. [3] http://mathworld.wolfram.com/FourierTransform.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># n and k run from 0 ... N-1</span>
    <span class="n">nk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;loop&#39;</span><span class="p">:</span>
        <span class="n">fta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nk</span><span class="p">):</span>
            <span class="n">fta</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">nk</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;matmul&#39;</span><span class="p">:</span>
        <span class="c1"># `mat` is the matrix with elements W**(n*k) in [1], eq. 12.2.2</span>
        <span class="n">nkmat</span> <span class="o">=</span> <span class="n">nk</span><span class="o">*</span><span class="n">nk</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="mf">1.0</span><span class="n">j</span><span class="o">*</span><span class="n">nkmat</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="n">fta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;illegal method &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span><span class="n">method</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fta</span></div>



<div class="viewcode-block" id="ezfft">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.ezfft.html#pwtools.signal.ezfft">[docs]</a>
<span class="k">def</span> <span class="nf">ezfft</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple FFT function for interactive use.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : 1d array to fft</span>
<span class="sd">    dt : float</span>
<span class="sd">        time step</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    faxis, fft(y)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; t = linspace(0,1,200)</span>
<span class="sd">    &gt;&gt;&gt; x = sin(2*pi*10*t) + sin(2*pi*20*t)</span>
<span class="sd">    &gt;&gt;&gt; f,d = signal.ezfft(x, dt=t[1]-t[0])</span>
<span class="sd">    &gt;&gt;&gt; plot(f,abs(d))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">faxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftfreq</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">dt</span><span class="p">)</span>
    <span class="n">split_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">faxis</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">faxis</span><span class="p">[:</span><span class="n">split_idx</span><span class="p">],</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span><span class="p">)[:</span><span class="n">split_idx</span><span class="p">]</span></div>



<div class="viewcode-block" id="fft_1d_loop">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.fft_1d_loop.html#pwtools.signal.fft_1d_loop">[docs]</a>
<span class="k">def</span> <span class="nf">fft_1d_loop</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Like scipy.fft.pack.fft and numpy.fft.fft, perform fft along an axis.</span>
<span class="sd">    Here do this by looping over remaining axes and perform 1D FFTs.</span>

<span class="sd">    This was implemented as a low-memory version like</span>
<span class="sd">    :func:`~pwtools.crys.smooth` to be used in :func:`~pwtools.pydos.pdos`,</span>
<span class="sd">    which fills up the memory for big MD data. But actually it has the same</span>
<span class="sd">    memory footprint as the plain scipy fft routine. Keep it here anyway as a</span>
<span class="sd">    nice reference for how to loop over remaining axes in the ndarray case.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">]</span>
    <span class="c1"># tuple here is 3x faster than generator expression</span>
    <span class="c1">#   idxs = (range(arr.shape[ax]) for ax in axes)</span>
    <span class="n">idxs</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">])</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idx_tup</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">idxs</span><span class="p">):</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span><span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx_tup</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">tsl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="n">out</span><span class="p">[</span><span class="n">tsl</span><span class="p">]</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">tsl</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">out</span></div>




<div class="viewcode-block" id="pad_zeros">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.pad_zeros.html#pwtools.signal.pad_zeros">[docs]</a>
<span class="k">def</span> <span class="nf">pad_zeros</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="n">nadd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">upto</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tonext</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">tonext_min</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pad an nd-array with zeros. Default is to append an array of zeros of</span>
<span class="sd">    the same shape as `arr` to arr&#39;s end along `axis`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr :  nd array</span>
<span class="sd">    axis : the axis along which to pad</span>
<span class="sd">    where : string {&#39;end&#39;, &#39;start&#39;}, pad at the end (&quot;append to array&quot;) or</span>
<span class="sd">        start (&quot;prepend to array&quot;) of `axis`</span>
<span class="sd">    nadd : number of items to padd (i.e. nadd=3 means padd w/ 3 zeros in case</span>
<span class="sd">        of an 1d array)</span>
<span class="sd">    upto : pad until arr.shape[axis] == upto</span>
<span class="sd">    tonext : bool, pad up to the next power of two (pad so that the padded</span>
<span class="sd">        array has a length of power of two)</span>
<span class="sd">    tonext_min : int, when using `tonext`, pad the array to the next possible</span>
<span class="sd">        power of two for which the resulting array length along `axis` is at</span>
<span class="sd">        least `tonext_min`; the default is tonext_min = arr.shape[axis]</span>

<span class="sd">    Use only one of nadd, upto, tonext.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    padded array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # 1d</span>
<span class="sd">    &gt;&gt;&gt; pad_zeros(a)</span>
<span class="sd">    array([1, 2, 3, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; pad_zeros(a, nadd=3)</span>
<span class="sd">    array([1, 2, 3, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; pad_zeros(a, upto=6)</span>
<span class="sd">    array([1, 2, 3, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; pad_zeros(a, nadd=1)</span>
<span class="sd">    array([1, 2, 3, 0])</span>
<span class="sd">    &gt;&gt;&gt; pad_zeros(a, nadd=1, where=&#39;start&#39;)</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; # 2d</span>
<span class="sd">    &gt;&gt;&gt; a=arange(9).reshape(3,3)</span>
<span class="sd">    &gt;&gt;&gt; pad_zeros(a, nadd=1, axis=0)</span>
<span class="sd">    array([[0, 1, 2],</span>
<span class="sd">           [3, 4, 5],</span>
<span class="sd">           [6, 7, 8],</span>
<span class="sd">           [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; pad_zeros(a, nadd=1, axis=1)</span>
<span class="sd">    array([[0, 1, 2, 0],</span>
<span class="sd">           [3, 4, 5, 0],</span>
<span class="sd">           [6, 7, 8, 0]])</span>
<span class="sd">    &gt;&gt;&gt; # up to next power of two</span>
<span class="sd">    &gt;&gt;&gt; 2**arange(10)</span>
<span class="sd">    array([  1,   2,   4,   8,  16,  32,  64, 128, 256, 512])</span>
<span class="sd">    &gt;&gt;&gt; pydos.pad_zeros(arange(9), tonext=True).shape</span>
<span class="sd">    (16,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tonext</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">tonext</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="p">[</span><span class="n">nadd</span><span class="p">,</span> <span class="n">upto</span><span class="p">,</span> <span class="n">tonext</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">lst</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;`nadd`, `upto` and `tonext` must be &quot;</span> <span class="o">+</span>\
           <span class="s2">&quot;all None or only one of them not None&quot;</span>
    <span class="k">if</span> <span class="n">nadd</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">upto</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">tonext</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">tonext</span><span class="p">):</span>
                <span class="c1"># default</span>
                <span class="n">nadd</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tonext_min</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">tonext_min</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> \
                             <span class="k">else</span> <span class="n">tonext_min</span>
                <span class="c1"># beware of int overflows starting w/ 2**arange(64), but we</span>
                <span class="c1"># will never have such long arrays anyway</span>
                <span class="n">two_powers</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">30</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">tonext_min</span> <span class="o">&lt;=</span> <span class="n">two_powers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="s2">&quot;tonext_min exceeds &quot;</span>
                    <span class="s2">&quot;max power of 2&quot;</span><span class="p">)</span>
                <span class="n">power</span> <span class="o">=</span> <span class="n">two_powers</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">two_powers</span><span class="p">,</span>
                                                  <span class="n">tonext_min</span><span class="p">)]</span>
                <span class="n">nadd</span> <span class="o">=</span> <span class="n">power</span> <span class="o">-</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nadd</span> <span class="o">=</span> <span class="n">upto</span> <span class="o">-</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">nadd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">add_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">add_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">nadd</span>
    <span class="n">add_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">add_shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">where</span> <span class="o">==</span> <span class="s1">&#39;end&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">add_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">where</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">add_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;illegal `where` arg: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">where</span><span class="p">)</span></div>



<div class="viewcode-block" id="welch">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.welch.html#pwtools.signal.welch">[docs]</a>
<span class="k">def</span> <span class="nf">welch</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Welch window. Function skeleton shamelessly stolen from</span>
<span class="sd">    scipy.signal.bartlett() and others.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="n">M</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">odd</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">-</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span><span class="o">**</span><span class="mf">2.0</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">odd</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">w</span></div>


<div class="viewcode-block" id="lorentz">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.lorentz.html#pwtools.signal.lorentz">[docs]</a>
<span class="k">def</span> <span class="nf">lorentz</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Lorentz window (same as Cauchy function). Function skeleton stolen from</span>
<span class="sd">    scipy.signal.gaussian().</span>

<span class="sd">    The Lorentz function is</span>

<span class="sd">    .. math::</span>

<span class="sd">        L(x) = \frac{\Gamma}{(x-x_0)^2 + \Gamma^2}</span>

<span class="sd">    Here :math:`x_0 = 0` and `std` = :math:`\Gamma`.</span>
<span class="sd">    Some definitions use :math:`1/2\,\Gamma` instead of :math:`\Gamma`, but</span>
<span class="sd">    without 1/2 we get comparable peak width to Gaussians when using this</span>
<span class="sd">    window in convolutions, thus ``scipy.signal.gaussian(M, std=5)`` is similar</span>
<span class="sd">    to ``lorentz(M, std=5)``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : int</span>
<span class="sd">        number of points</span>
<span class="sd">    std : float</span>
<span class="sd">        spread parameter :math:`\Gamma`</span>
<span class="sd">    sym : bool</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (M,)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="n">M</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">odd</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">std</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">std</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">/=</span> <span class="n">w</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">odd</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">w</span></div>


<span class="n">cauchy</span> <span class="o">=</span> <span class="n">lorentz</span>


<div class="viewcode-block" id="mirror">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.mirror.html#pwtools.signal.mirror">[docs]</a>
<span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mirror array `arr` at index 0 along `axis`.</span>
<span class="sd">    The length of the returned array is 2*arr.shape[axis]-1 .&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">arr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<span class="c1"># XXX</span>
<span class="c1"># Check f2py wrapper of _flib.acorr(): The signature is:</span>
<span class="c1">#       In [13]: num._flib.acorr?</span>
<span class="c1">#       Type:           fortran</span>
<span class="c1">#       String form:    &lt;fortran object&gt;</span>
<span class="c1">#       Docstring:</span>
<span class="c1">#       c = acorr(v,c,method,norm,[nstep])</span>
<span class="c1">#</span>
<span class="c1">#       Wrapper for ``acorr``.</span>
<span class="c1">#</span>
<span class="c1">#       Parameters</span>
<span class="c1">#       ----------</span>
<span class="c1">#       v : input rank-1 array(&#39;d&#39;) with bounds (nstep)</span>
<span class="c1">#       c : input rank-1 array(&#39;d&#39;) with bounds (nstep)</span>
<span class="c1">#       method : input int</span>
<span class="c1">#       norm : input int</span>
<span class="c1">#</span>
<span class="c1">#       Other Parameters</span>
<span class="c1">#       ----------------</span>
<span class="c1">#       nstep : input int, optional</span>
<span class="c1">#           Default: len(v)</span>
<span class="c1">#</span>
<span class="c1">#       Returns</span>
<span class="c1">#       -------</span>
<span class="c1">#       c : rank-1 array(&#39;d&#39;) with bounds (nstep)</span>
<span class="c1">#</span>
<span class="c1"># We need to pass in a result array &#39;c&#39; which gets overwritten, but this also</span>
<span class="c1"># gets returned. Check f2py docs for wrapping such that c generated on the</span>
<span class="c1"># Fortran side.</span>
<span class="c1">#</span>
<div class="viewcode-block" id="acorr">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.acorr.html#pwtools.signal.acorr">[docs]</a>
<span class="k">def</span> <span class="nf">acorr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;(Normalized) autocorrelation function (ACF) for 1d arrays.</span>

<span class="sd">    Without normalization</span>
<span class="sd">        c(t) = &lt;v(0) v(t)&gt;</span>
<span class="sd">    and with</span>
<span class="sd">        c(t) = &lt;v(0) v(t)&gt; / &lt;v(0)**2&gt;</span>

<span class="sd">    The x-axis is the offset &quot;t&quot; (or &quot;lag&quot; in Digital Signal Processing lit.).</span>
<span class="sd">    Since the ACF is symmetric around t=0, we return only t=0...len(v)-1 .</span>

<span class="sd">    Several Python and Fortran implememtations. The Python versions are mostly</span>
<span class="sd">    for reference and are slow, except for fft-based, which is by far the</span>
<span class="sd">    fastet.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    v : 1d array</span>
<span class="sd">    method : int</span>
<span class="sd">        | 1: Python loops</span>
<span class="sd">        | 2: Python loops, zero-padded</span>
<span class="sd">        | 3: method 1, numpy vectorized</span>
<span class="sd">        | 4: uses numpy.correlate()</span>
<span class="sd">        | 5: Fortran version of 1</span>
<span class="sd">        | 6: Fortran version of 3</span>
<span class="sd">        | 7: fft, Wiener-Khinchin Theorem</span>
<span class="sd">    norm : bool</span>
<span class="sd">        normalize or not</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : numpy 1d array</span>
<span class="sd">        | c[0]  &lt;=&gt; lag = 0</span>
<span class="sd">        | c[-1] &lt;=&gt; lag = len(v)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Generalization of this function to correlation corr(v,w) should be</span>
<span class="sd">    straightforward. Autocorrelation is then corr(v,v).</span>

<span class="sd">    speed:</span>
<span class="sd">        methods 1 ...  are loosely ordered slow ... fast</span>
<span class="sd">    methods:</span>
<span class="sd">       All methods, besides the FFT, are &quot;exact&quot;, they use variations of loops</span>
<span class="sd">       in the time domain, i.e. norm(acorr(v,1) - acorr(v,6)) = 0.0.</span>
<span class="sd">       The FFT method introduces small numerical noise, norm(acorr(v,1) -</span>
<span class="sd">       acorr(v,4)) = O(1e-16) or so.</span>

<span class="sd">    signature of the Fortran extension _flib.acorr::</span>

<span class="sd">        acorr - Function signature:</span>
<span class="sd">          c = acorr(v,c,method,[nstep])</span>
<span class="sd">        Required arguments:</span>
<span class="sd">          v : input rank-1 array(&#39;d&#39;) with bounds (nstep)</span>
<span class="sd">          c : input rank-1 array(&#39;d&#39;) with bounds (nstep)</span>
<span class="sd">          method : input int</span>
<span class="sd">        Optional arguments:</span>
<span class="sd">          nstep := len(v) input int</span>
<span class="sd">        Return objects:</span>
<span class="sd">          c : rank-1 array(&#39;d&#39;) with bounds (nstep)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Numerical Recipes in Fortran, 2nd ed., ch. 13.2</span>
<span class="sd">    .. [2] http://mathworld.wolfram.com/FourierTransform.html</span>
<span class="sd">    .. [3] http://mathworld.wolfram.com/Cross-CorrelationTheorem.html</span>
<span class="sd">    .. [4] http://mathworld.wolfram.com/Wiener-KhinchinTheorem.html</span>
<span class="sd">    .. [5] http://mathworld.wolfram.com/Autocorrelation.html</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nstep</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstep</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">_norm</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">norm</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="o">-</span><span class="n">t</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">t</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstep</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
                <span class="n">c</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">vv</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">t</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
            <span class="n">c</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="p">[:(</span><span class="n">nstep</span><span class="o">-</span><span class="n">t</span><span class="p">)]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="n">t</span><span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)[</span><span class="n">nstep</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_flib</span><span class="o">.</span><span class="n">acorr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_norm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_flib</span><span class="o">.</span><span class="n">acorr</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">_norm</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="c1"># Correlation via fft. After ifft, the imaginary part is (in theory) =</span>
        <span class="c1"># 0, in practise &lt; 1e-16, so we are safe to return the real part only.</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstep</span><span class="p">,),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)))</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fft</span><span class="p">(</span><span class="n">vv</span><span class="p">))</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)[:</span><span class="n">nstep</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unknown method: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">method</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">c</span></div>



<div class="viewcode-block" id="gauss">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.gauss.html#pwtools.signal.gauss">[docs]</a>
<span class="k">def</span> <span class="nf">gauss</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gaussian function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : 1d array</span>
<span class="sd">    std : float</span>
<span class="sd">        sigma</span>
<span class="sd">    norm : bool</span>
<span class="sd">        Norm such that integrate(gauss(x),x=-inf,inf) = 1, i.e. normalize and</span>
<span class="sd">        return a PDF.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array_like(x)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">std</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">std</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mf">2.0</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">std</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span></div>



<div class="viewcode-block" id="find_peaks">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.find_peaks.html#pwtools.signal.find_peaks">[docs]</a>
<span class="k">def</span> <span class="nf">find_peaks</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">spread</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple peak finding algorithm.</span>

<span class="sd">    Find all peaks where ``y &gt; ymin``. If `x` given, also extract peak maxima</span>
<span class="sd">    positions by fitting a spline of order `k` to each found peak. To find</span>
<span class="sd">    minima, just use ``-y``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    y : 1d array_like</span>
<span class="sd">        data with peaks</span>
<span class="sd">    x : 1d array_like, optional, len(y)</span>
<span class="sd">        x axis</span>
<span class="sd">    k : int</span>
<span class="sd">        order of spline</span>
<span class="sd">    spread : int</span>
<span class="sd">        Use ``2*spread+1`` points around each peak to fit a spline. Note that</span>
<span class="sd">        we need ``2*spread+1 &gt; k``.</span>
<span class="sd">    ymin : float, optional</span>
<span class="sd">        Find all peaks above that value.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    idx0, pos0</span>
<span class="sd">    idx0 : indices of peaks from finite diffs, each peak is at ``x[idx0[i]]``</span>
<span class="sd">    pos0 : refined `x`-positions of peaks if `x` given, else None</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pwtools.signal import gauss, find_peaks</span>
<span class="sd">    &gt;&gt;&gt; from pwtools import num</span>
<span class="sd">    &gt;&gt;&gt; x=linspace(0,10,300); y=0.2*gauss(x-0.5,.1) + gauss(x-2,.1) + 0.7*gauss(x-3,0.1) + gauss(x-6,1)</span>
<span class="sd">    &gt;&gt;&gt; # ymin=0.4: ignore first peak at x=0.5</span>
<span class="sd">    &gt;&gt;&gt; find_peaks(y,x, ymin=0.4)</span>
<span class="sd">    ([60, 90, 179], [2.000231296097065, 3.0007122565950572, 5.999998055132549])</span>
<span class="sd">    &gt;&gt;&gt; idx0, pos0=find_peaks(y,x, ymin=0.4)</span>
<span class="sd">    &gt;&gt;&gt; spl=num.Spline(x,y)</span>
<span class="sd">    &gt;&gt;&gt; plot(x,y)</span>
<span class="sd">    &gt;&gt;&gt; for x0 in pos0:</span>
<span class="sd">    ...    plot([x0], [spl(x0)], &#39;ro&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="k">if</span> <span class="n">ymin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">ymin</span>
    <span class="n">idx0</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">dfy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dfy</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dfy</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dfy</span><span class="p">[</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ymin</span><span class="p">:</span>
            <span class="n">idx0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">pos0</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pos0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i0</span> <span class="ow">in</span> <span class="n">idx0</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i0</span><span class="o">-</span><span class="n">spread</span><span class="p">,</span><span class="n">i0</span><span class="o">+</span><span class="mi">1</span><span class="o">+</span><span class="n">spread</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
            <span class="n">yy</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
            <span class="n">spl</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">Spline</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span><span class="o">-</span><span class="n">yy</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">spl</span><span class="o">.</span><span class="n">get_min</span><span class="p">()</span>
                <span class="n">pos0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;error calculating spline maximum at idx=</span><span class="si">%i</span><span class="s2">, x=</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">i0</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">idx0</span><span class="p">,</span> <span class="n">pos0</span></div>



<div class="viewcode-block" id="smooth">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.smooth.html#pwtools.signal.smooth">[docs]</a>
<span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">kern</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Smooth N-dim `data` by convolution with a kernel `kern`.</span>

<span class="sd">    Uses scipy.signal.fftconvolve().</span>

<span class="sd">    Note that due to edge effect handling (padding) and kernal normalization,</span>
<span class="sd">    the convolution identity convolve(data,kern) == convolve(kern,data) doesn&#39;t</span>
<span class="sd">    apply here. We always return an array of ``data.shape``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : nd array</span>
<span class="sd">        The data to smooth. Example: 1d (N,) or (N,K,3)</span>
<span class="sd">        for trajectory</span>
<span class="sd">    kern : nd array</span>
<span class="sd">        Convolution kernel. Example: 1d (M,) or (M,1,1)</span>
<span class="sd">        for trajectory along axis=0 (data length N)</span>
<span class="sd">    axis : int</span>
<span class="sd">        Axis along which to do the smoothing. That is actually not needed for</span>
<span class="sd">        the convolution ``fftconvolve(data, kern)`` but is used for padding the</span>
<span class="sd">        data along `axis` to handle edge effects before convolution.</span>
<span class="sd">    edge : str</span>
<span class="sd">        Method for edge effect handling.</span>
<span class="sd">            | &#39;m&#39; : pad with mirror signal</span>
<span class="sd">            | &#39;c&#39; : pad with constant values (i.e. ``data[0]`` and</span>
<span class="sd">            |       ``data[-1]`` in the 1d case)</span>
<span class="sd">    norm : bool</span>
<span class="sd">        Normalize kernel. Default is True. This assures that the smoothed</span>
<span class="sd">        signal lies within the data. Note that this is not True for kernels</span>
<span class="sd">        with very big spread (i.e. ``hann(N*10)`` or ``gaussian(N/2,</span>
<span class="sd">        std=N*10)``. Then the kernel is effectively a constant.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : data.shape</span>
<span class="sd">        Convolved signal.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pwtools.signal import welch</span>
<span class="sd">    &gt;&gt;&gt; from numpy.random import rand</span>
<span class="sd">    &gt;&gt;&gt; x = linspace(0,2*pi,500); a=cos(x)+rand(500)</span>
<span class="sd">    &gt;&gt;&gt; plot(a, color=&#39;0.7&#39;)</span>
<span class="sd">    &gt;&gt;&gt; k=scipy.signal.hann(21)</span>
<span class="sd">    &gt;&gt;&gt; plot(signal.smooth(a,k), &#39;r&#39;, label=&#39;hann&#39;)</span>
<span class="sd">    &gt;&gt;&gt; k=scipy.signal.gaussian(21, 3)</span>
<span class="sd">    &gt;&gt;&gt; plot(signal.smooth(a,k), &#39;g&#39;, label=&#39;gauss&#39;)</span>
<span class="sd">    &gt;&gt;&gt; k=welch(21)</span>
<span class="sd">    &gt;&gt;&gt; plot(signal.smooth(a,k), &#39;y&#39;, label=&#39;welch&#39;)</span>
<span class="sd">    &gt;&gt;&gt; legend()</span>
<span class="sd">    &gt;&gt;&gt; # odd kernel [0,1,0] reproduces data exactly, i.e. convolution with</span>
<span class="sd">    &gt;&gt;&gt; # delta peak</span>
<span class="sd">    &gt;&gt;&gt; figure(); title(&#39;smooth with delta [0,1,0]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x=linspace(0,2*pi,15); k=scipy.signal.hann(3)</span>
<span class="sd">    &gt;&gt;&gt; plot(cos(x))</span>
<span class="sd">    &gt;&gt;&gt; plot(signal.smooth(cos(x),k), &#39;r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; legend()</span>
<span class="sd">    &gt;&gt;&gt; # edge effects with normal convolution</span>
<span class="sd">    &gt;&gt;&gt; figure(); title(&#39;edge effects&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x=rand(20)+10; k=scipy.signal.hann(11);</span>
<span class="sd">    &gt;&gt;&gt; plot(x); plot(signal.smooth(x,k),label=&quot;smooth&quot;);</span>
<span class="sd">    &gt;&gt;&gt; plot(scipy.signal.convolve(x,k/k.sum(),&#39;same&#39;), label=&#39;convolve&#39;)</span>
<span class="sd">    &gt;&gt;&gt; legend()</span>
<span class="sd">    &gt;&gt;&gt; # edge effect methods</span>
<span class="sd">    &gt;&gt;&gt; figure(); title(&#39;edge effect methods&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x=rand(20)+10; k=scipy.signal.hann(20);</span>
<span class="sd">    &gt;&gt;&gt; plot(x); plot(signal.smooth(x,k,edge=&#39;m&#39;),label=&quot;edge=&#39;m&#39;&quot;);</span>
<span class="sd">    &gt;&gt;&gt; plot(signal.smooth(x,k,edge=&#39;c&#39;),label=&quot;edge=&#39;c&#39;&quot;);</span>
<span class="sd">    &gt;&gt;&gt; legend()</span>
<span class="sd">    &gt;&gt;&gt; # smooth a trajectory of atomic coordinates</span>
<span class="sd">    &gt;&gt;&gt; figure(); title(&#39;trajectory&#39;)</span>
<span class="sd">    &gt;&gt;&gt; x = linspace(0,2*pi,500)</span>
<span class="sd">    &gt;&gt;&gt; a = rand(500,2,3) # (nstep, natoms, 3)</span>
<span class="sd">    &gt;&gt;&gt; a[:,0,:] += cos(x)[:,None]</span>
<span class="sd">    &gt;&gt;&gt; a[:,1,:] += sin(x)[:,None]</span>
<span class="sd">    &gt;&gt;&gt; k=scipy.signal.hann(21)[:,None,None]</span>
<span class="sd">    &gt;&gt;&gt; y = signal.smooth(a,k)</span>
<span class="sd">    &gt;&gt;&gt; plot(a[:,0,0], color=&#39;0.7&#39;); plot(y[:,0,0],&#39;b&#39;,</span>
<span class="sd">    ...                                   label=&#39;atom1 x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plot(a[:,1,0], color=&#39;0.7&#39;); plot(y[:,1,0],&#39;r&#39;,</span>
<span class="sd">    ...                                   label=&#39;atom2 x&#39;)</span>
<span class="sd">    &gt;&gt;&gt; legend()</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] http://wiki.scipy.org/Cookbook/SignalSmooth</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`welch`</span>
<span class="sd">    :func:`lorentz`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Kernels:</span>

<span class="sd">    Even kernels result in shifted signals, odd kernels are better.</span>
<span class="sd">    However, for N &gt;&gt; M, it doesn&#39;t make a difference really.</span>

<span class="sd">    Usual kernels (window functions) are created by e.g.</span>
<span class="sd">    ``scipy.signal.hann(M)``. For ``kern=scipy.signal.gaussian(M,</span>
<span class="sd">    std)``, two values are needed, namely `M` and `std`, where  `M`</span>
<span class="sd">    determines the number of points calculated for the convolution kernel, as</span>
<span class="sd">    in the other cases. But what is actually important is `std`, which</span>
<span class="sd">    determines the &quot;used width&quot; of the gaussian. Say we use N=100</span>
<span class="sd">    and M=50. That would be a massively wide window and we would</span>
<span class="sd">    smooth away all details. OTOH, using ``gaussian(50,3)`` would generate a</span>
<span class="sd">    kernel with the same number `M` of data points, but the gauss peak which is</span>
<span class="sd">    effectively used for convolution is much smaller. For ``gaussian()``,</span>
<span class="sd">    `M` should be bigger then `std`. The convolved signal will converge</span>
<span class="sd">    with increasing `M`. Good values are `M=6*std` and bigger. For</span>
<span class="sd">    :func:`lorentz`, much wider kernels are needed such as `M=100*std` b/c</span>
<span class="sd">    of the long tails of the Lorentz function. Testing is mandatory!</span>

<span class="sd">    Edge effects:</span>

<span class="sd">    We use padding of the signal with ``M=len(kern)`` values at both ends such</span>
<span class="sd">    that the convolution with `kern` doesn&#39;t zero the `data` at the signal</span>
<span class="sd">    edges. We have two methods. `edge=&#39;m&#39;`: padd with the signal mirrored at 0</span>
<span class="sd">    and -1 or `edge=&#39;c&#39;`: use the constant values ``data[0]`` and ``data[-1]``.</span>
<span class="sd">    Many more of these variants may be thought of. The choice of how to extend</span>
<span class="sd">    the data essentially involves an assumption about how the signal *would*</span>
<span class="sd">    continue, which is signal-dependent. In practice, we usually have ``M &lt;&lt;</span>
<span class="sd">    N`` (e.g. ``scipy.signal.hann(M)``) or ``std &lt;&lt; N``</span>
<span class="sd">    (``scipy.signal.gaussian(M, std``). Then, both methods are identical in the</span>
<span class="sd">    middle and show only very small differences at the edges. Essentially, edge</span>
<span class="sd">    effect handling shall only ensure that the smoothed signal doesn&#39;t go to</span>
<span class="sd">    zero and that must be independent of the method, which is the case.</span>

<span class="sd">    Memory:</span>

<span class="sd">    For big data, fftconvolve() can easily eat up all your memory, for</span>
<span class="sd">    example::</span>

<span class="sd">    &gt;&gt;&gt; # assume axis=0 is the axis along which to convolve</span>
<span class="sd">    &gt;&gt;&gt; arr = ones((1e5,200,3))</span>
<span class="sd">    &gt;&gt;&gt; kern = scipy.signal.hann(101)</span>
<span class="sd">    &gt;&gt;&gt; ret = scipy.signal.fftconvolve(arr, kern[:,None,None])</span>

<span class="sd">    Then it is better to loop over some or all of the remaing dimensions::</span>

<span class="sd">    &gt;&gt;&gt; ret = np.empty_like(arr)</span>
<span class="sd">    &gt;&gt;&gt; for jj in range(arr.shape[1]):</span>
<span class="sd">    &gt;&gt;&gt;     ret[:,jj,:] = smooth(arr[:,jj,:], kern[:,None])</span>

<span class="sd">    or::</span>

<span class="sd">    &gt;&gt;&gt; for jj in range(arr.shape[1]):</span>
<span class="sd">    &gt;&gt;&gt;     for kk in range(arr.shape[2]):</span>
<span class="sd">    &gt;&gt;&gt;         ret[:,jj,kk] = smooth(arr[:,jj,kk], kern)</span>

<span class="sd">    The size of the chunk over which you explicitely loop depends on the data</span>
<span class="sd">    of course. We do exactly this in :func:`pwtools.crys.smooth`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># edge = &#39;m&#39;</span>
    <span class="c1"># ----------</span>
    <span class="c1">#</span>
    <span class="c1"># Add mirror of the signal left and right to handle edge effects, up to</span>
    <span class="c1"># signal length N on both ends. If M &gt; N then fill padding regions up with</span>
    <span class="c1"># zeros until we have sig = [(M,), (N,), (M,)]. fftconvolve(..., &#39;valid&#39;)</span>
    <span class="c1"># always returns only the signal length where sig and kern overlap</span>
    <span class="c1"># completely. Therefore, data at the far end doesn&#39;t influence the edge and</span>
    <span class="c1"># we can safely put zeros (or anything else) there. The returned length is</span>
    <span class="c1"># always N+M+1.</span>
    <span class="c1">#</span>
    <span class="c1"># example (M &lt; N), add M=3 data parts left and right</span>
    <span class="c1"># npad   = 3</span>
    <span class="c1"># data   =                 [1,2,3,4,5,6]</span>
    <span class="c1"># dleft  =           [4,3,2]</span>
    <span class="c1"># dright =                             [5,4,3]</span>
    <span class="c1"># sig    =           [4,3,2,1,2,3,4,5,6,5,4,3]</span>
    <span class="c1"># If M = 8 &gt; N, then:</span>
    <span class="c1"># dleft  =       [6,5,4,3,2]</span>
    <span class="c1"># dright =                             [5,4,3,2,1]</span>
    <span class="c1"># sig    = [0,0,0,6,5,4,3,2,1,2,3,4,5,6,5,4,3,2,1,0,0,0]</span>
    <span class="c1">#</span>
    <span class="c1"># edge = &#39;c&#39;</span>
    <span class="c1"># ----------</span>
    <span class="c1"># The same, but all padded values are the first (left) and last (right)</span>
    <span class="c1"># data value.</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">kern</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">edge</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
        <span class="n">npad</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
        <span class="n">sleft</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">npad</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sright</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="n">npad</span><span class="o">+</span><span class="mi">2</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dleft</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">slicetake</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sl</span><span class="o">=</span><span class="n">sleft</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">dright</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">slicetake</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sl</span><span class="o">=</span><span class="n">sright</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">dleft</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">dright</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">K</span> <span class="o">=</span> <span class="n">dleft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">K</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">:</span>
            <span class="n">dleft</span>  <span class="o">=</span> <span class="n">pad_zeros</span><span class="p">(</span><span class="n">dleft</span><span class="p">,</span>  <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="n">nadd</span><span class="o">=</span><span class="n">M</span><span class="o">-</span><span class="n">K</span><span class="p">)</span>
            <span class="n">dright</span> <span class="o">=</span> <span class="n">pad_zeros</span><span class="p">(</span><span class="n">dright</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;end&#39;</span><span class="p">,</span>   <span class="n">nadd</span><span class="o">=</span><span class="n">M</span><span class="o">-</span><span class="n">K</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">edge</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tsl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="n">dleft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">slicetake</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">tsl</span><span class="p">],</span> <span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">dright</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">slicetake</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sl</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)[</span><span class="n">tsl</span><span class="p">],</span> <span class="n">M</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">dleft</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">dright</span><span class="o">.</span><span class="n">shape</span>
        <span class="c1"># 1d special case: (M,1) -&gt; (M,)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dleft</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">dleft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dleft</span> <span class="o">=</span> <span class="n">dleft</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dright</span> <span class="o">=</span> <span class="n">dright</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unknown value for edge&quot;</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">dleft</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">dright</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">kk</span> <span class="o">=</span> <span class="n">kern</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">kern</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="k">if</span> <span class="n">norm</span> <span class="k">else</span> <span class="n">kern</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">fftconvolve</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">kk</span><span class="p">,</span> <span class="s1">&#39;valid&#39;</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">N</span><span class="o">+</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;unexpected convolve result shape&quot;</span>
    <span class="k">del</span> <span class="n">sig</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1">##sl = slice(M//2+1,-(M//2)) # even kernel, shift result to left</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># even kernel, shift result to right</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="p">(</span><span class="n">M</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">slicetake</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">sl</span><span class="o">=</span><span class="n">sl</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ret</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;ups, ret.shape (</span><span class="si">%s</span><span class="s2">)!= data.shape (</span><span class="si">%s</span><span class="s2">)&quot;</span>
                                      <span class="o">%</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="odd">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.odd.html#pwtools.signal.odd">[docs]</a>
<span class="k">def</span> <span class="nf">odd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return next odd integer to `n`.</span>

<span class="sd">    Can be used to construt odd smoothing kernels in :func:`smooth`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">    add : int</span>
<span class="sd">        number to add if `n` is even, +1 or -1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">add</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;add must be -1 or 1&quot;</span>
    <span class="k">return</span> <span class="n">n</span> <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">n</span> <span class="o">+</span> <span class="n">add</span></div>



<div class="viewcode-block" id="scale">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.scale.html#pwtools.signal.scale">[docs]</a>
<span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Scale `x` to unity.</span>

<span class="sd">    Subtract min and divide by (max-min).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">    copy : bool</span>
<span class="sd">        copy `x` before scaling</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x_scaled</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">x</span>
    <span class="n">xx</span> <span class="o">=</span> <span class="n">xx</span> <span class="o">-</span> <span class="n">xx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">xx</span> <span class="o">/=</span> <span class="n">xx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">xx</span></div>



<div class="viewcode-block" id="FIRFilter">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.FIRFilter.html#pwtools.signal.FIRFilter">[docs]</a>
<span class="k">class</span> <span class="nc">FIRFilter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build and apply a digital FIR filter (low-, high-, band-pass,</span>
<span class="sd">    band-stop). Uses firwin() and in some cases kaiserord().</span>

<span class="sd">    Doc strings stolen from scipy.signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    To plot the frequency response (the frequency bands), use::</span>

<span class="sd">        &gt;&gt;&gt; f = Filter(...)</span>
<span class="sd">        &gt;&gt;&gt; plot(f.w, abs(f.h))</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    .. literalinclude:: ../../../../examples/filter_example.py</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] http://www.scipy.org/Cookbook/FIRFilter</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FIRFilter.__init__">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.FIRFilter.html#pwtools.signal.FIRFilter.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">nyq</span><span class="p">,</span> <span class="n">ntaps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ripple</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;lowpass&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cutoff : float or 1D array_like</span>
<span class="sd">            Cutoff frequency of filter (expressed in the same units as `nyq`)</span>
<span class="sd">            OR an array of cutoff frequencies (that is, band edges). In the</span>
<span class="sd">            latter case, the frequencies in `cutoff` should be positive and</span>
<span class="sd">            monotonically increasing between 0 and `nyq`.  The values 0 and</span>
<span class="sd">            `nyq` must not be included in `cutoff`.</span>
<span class="sd">        nyq : float</span>
<span class="sd">            Nyquist frequency [Hz].  Each frequency in `cutoff` must be between 0</span>
<span class="sd">            and `nyq`.</span>
<span class="sd">        ntaps : int</span>
<span class="sd">            Length of the filter (number of coefficients, i.e. the filter</span>
<span class="sd">            order + 1).  `ntaps` must be even if a passband includes the</span>
<span class="sd">            Nyquist frequency. Use either `ntaps` or `ripple` + `width` for a</span>
<span class="sd">            Kaiser window.</span>
<span class="sd">        ripple : float</span>
<span class="sd">            Positive number specifying maximum ripple in passband (dB) and</span>
<span class="sd">            minimum ripple in stopband. Large values (like 1000) remove the</span>
<span class="sd">            &quot;rippling&quot; in the pass band almost completely and make frequency</span>
<span class="sd">            response almost &quot;square&quot; (if `width` is small) but also</span>
<span class="sd">            lead to a large number of filter coeffs (ntaps).</span>
<span class="sd">        width : float</span>
<span class="sd">            Width of transition region (same unit as `nyq`, e.g. Hz).</span>
<span class="sd">        window : string or tuple of string and parameter values</span>
<span class="sd">            Desired window to use. See `scipy.signal.get_window` for a list</span>
<span class="sd">            of windows and required parameters. Default is &quot;hamming&quot;. Ignored</span>
<span class="sd">            if `width` and `ripple` givem b/c then ``kaiserord`` is used to</span>
<span class="sd">            build a Kaiser window.</span>
<span class="sd">        mode : str</span>
<span class="sd">            &#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandpass&#39;, &#39;bandstop&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ntaps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">[</span><span class="n">ripple</span><span class="p">,</span> <span class="n">width</span><span class="p">]</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;ntaps is None, we need &quot;</span>
                <span class="s2">&quot;ripple and width for a Kaiser window&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ntaps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">kaiserord</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ripple</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="n">nyq</span><span class="p">)</span>
            <span class="n">window</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;kaiser&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ntaps</span> <span class="o">=</span> <span class="n">ntaps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window</span> <span class="o">=</span> <span class="n">window</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;lowpass&#39;</span><span class="p">:</span>
            <span class="n">pass_zero</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;highpass&#39;</span><span class="p">:</span>
            <span class="n">pass_zero</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bandpass&#39;</span><span class="p">:</span>
            <span class="n">pass_zero</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;bandstop&#39;</span><span class="p">:</span>
            <span class="n">pass_zero</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;unknown mode&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taps</span> <span class="o">=</span> <span class="n">firwin</span><span class="p">(</span><span class="n">numtaps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ntaps</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window</span><span class="p">,</span> <span class="n">nyq</span><span class="o">=</span><span class="n">nyq</span><span class="p">,</span>
                           <span class="n">pass_zero</span><span class="o">=</span><span class="n">pass_zero</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">)</span>
        <span class="n">w</span><span class="p">,</span><span class="n">h</span> <span class="o">=</span> <span class="n">freqz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="n">nyq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span></div>


<div class="viewcode-block" id="FIRFilter.__call__">
<a class="viewcode-back" href="../../generated/api/pwtools.signal.FIRFilter.html#pwtools.signal.FIRFilter.__call__">[docs]</a>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply filter to signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : 1d array</span>
<span class="sd">        axis : int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">lfilter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taps</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>
</div>

</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;2023, Steve Schmerler.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
    </div>

    

    
  </body>
</html>