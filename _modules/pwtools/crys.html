<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pwtools.crys &#8212; pwtools  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=3b47c8d5" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo" />
    
    <h1 class="logo logo-name">pwtools</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=elcorto&repo=pwtools&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/api/index.html">API Reference</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../written/features.html">Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../written/background/index.html">Background, details, special topics</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pwtools.crys</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">acos</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sqrt</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>

<span class="kn">from</span> <span class="nn">pwtools</span> <span class="kn">import</span> <span class="n">common</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">atomic_data</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">_flib</span>
<span class="kn">from</span> <span class="nn">pwtools.common</span> <span class="kn">import</span> <span class="n">assert_cond</span>
<span class="kn">from</span> <span class="nn">pwtools.decorators</span> <span class="kn">import</span> <span class="n">crys_add_doc</span>
<span class="kn">from</span> <span class="nn">pwtools.base</span> <span class="kn">import</span> <span class="n">FlexibleGetters</span>
<span class="kn">from</span> <span class="nn">pwtools.constants</span> <span class="kn">import</span> <span class="n">Angstrom</span>
<span class="kn">from</span> <span class="nn">pwtools.num</span> <span class="kn">import</span> <span class="n">fempty</span><span class="p">,</span> <span class="n">rms3d</span><span class="p">,</span> <span class="n">match_mask</span><span class="p">,</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="c1">##warnings.simplefilter(&#39;always&#39;)</span>


<span class="c1">#-----------------------------------------------------------------------------</span>
<span class="c1"># misc math</span>
<span class="c1">#-----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="angle">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.angle.html#pwtools.crys.angle">[docs]</a>
<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Angle between vectors `x` and `y` in degrees.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x,y : 1d numpy arrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Numpy&#39;s `acos&#39; is &quot;acrcos&quot;, but we take the one from math for scalar</span>
    <span class="c1"># args.</span>
    <span class="k">return</span> <span class="n">acos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">*</span><span class="mf">180.0</span><span class="o">/</span><span class="n">pi</span></div>



<span class="c1">#-----------------------------------------------------------------------------</span>
<span class="c1"># crystallographic constants and basis vectors</span>
<span class="c1">#-----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="volume_cell">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.volume_cell.html#pwtools.crys.volume_cell">[docs]</a>
<span class="nd">@crys_add_doc</span>
<span class="k">def</span> <span class="nf">volume_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Volume of the unit cell from cell vectors. Calculates the triple</span>
<span class="sd">    product::</span>

<span class="sd">        np.dot(np.cross(a,b), c) == det(cell)</span>

<span class="sd">    of the basis vectors a,b,c contained in `cell`. Note that (mathematically)</span>
<span class="sd">    the vectors can be either the rows or the cols of `cell`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(cell_doc)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    volume, unit: [a]**3</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = [1,0,0]; b = [2,3,0]; c = [1,2,3.];</span>
<span class="sd">    &gt;&gt;&gt; m = np.array([a,b,c])</span>
<span class="sd">    &gt;&gt;&gt; volume_cell(m)</span>
<span class="sd">    9.0</span>
<span class="sd">    &gt;&gt;&gt; volume_cell(m.T)</span>
<span class="sd">    9.0</span>
<span class="sd">    &gt;&gt;&gt; m = rand(3,3)</span>
<span class="sd">    &gt;&gt;&gt; volume_cell(m)</span>
<span class="sd">    0.11844733769775126</span>
<span class="sd">    &gt;&gt;&gt; volume_cell(m.T)</span>
<span class="sd">    0.11844733769775123</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.det(m)</span>
<span class="sd">    0.11844733769775125</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.det(m.T)</span>
<span class="sd">    0.11844733769775125</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">assert_cond</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;input must be (3,3) array&quot;</span><span class="p">)</span>
<span class="c1">##    return np.dot(np.cross(cell[0,:], cell[1,:]), cell[2,:])</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">cell</span><span class="p">))</span></div>



<div class="viewcode-block" id="volume_cell3d">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.volume_cell3d.html#pwtools.crys.volume_cell3d">[docs]</a>
<span class="k">def</span> <span class="nf">volume_cell3d</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as :func:`volume_cell` for 3d arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cell : 3d array</span>
<span class="sd">    axis : time axis (e.g. cell.shape = (100,3,3) -&gt; axis=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">cell</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">cell</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]):</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>



<div class="viewcode-block" id="volume_cc">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.volume_cc.html#pwtools.crys.volume_cc">[docs]</a>
<span class="nd">@crys_add_doc</span>
<span class="k">def</span> <span class="nf">volume_cc</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Volume of the unit cell from crystallographic constants [1]_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(cryst_const_doc)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    volume, unit: [a]**3</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] http://en.wikipedia.org/wiki/Parallelepiped</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;shape must be (6,)&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
           <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="volume_cc3d">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.volume_cc3d.html#pwtools.crys.volume_cc3d">[docs]</a>
<span class="k">def</span> <span class="nf">volume_cc3d</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as :func:`volume_cc` for 2d arrays (the name &quot;3d&quot; is just to indicate</span>
<span class="sd">    that we work w/ trajectories).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cryst_const : 2d array</span>
<span class="sd">    axis : time axis (e.g. cryst_const.shape = (100,6) -&gt; axis=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">cryst_const</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">cryst_const</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cryst_const</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]):</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">volume_cc</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>



<div class="viewcode-block" id="cell2cc">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.cell2cc.html#pwtools.crys.cell2cc">[docs]</a>
<span class="nd">@crys_add_doc</span>
<span class="k">def</span> <span class="nf">cell2cc</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From `cell` to crystallographic constants a, b, c, alpha, beta,</span>
<span class="sd">    gamma.</span>
<span class="sd">    This mapping is unique in the sense that multiple cells will have</span>
<span class="sd">    the same `cryst_const`, i.e. the representation of the cell in</span>
<span class="sd">    `cryst_const` is independent from the spacial orientation of the cell</span>
<span class="sd">    w.r.t. a cartesian coord sys.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(cell_doc)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    %(cryst_const_doc)s,</span>
<span class="sd">        unit: [a]**3</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="n">assert_cond</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;cell must be (3,3) array&quot;</span><span class="p">)</span>
    <span class="n">cryst_const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">6</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># a = |a|, b = |b|, c = |c|</span>
    <span class="n">cryst_const</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">cell</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">va</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">vb</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">vc</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>
    <span class="c1"># alpha</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span><span class="n">vc</span><span class="p">)</span>
    <span class="c1"># beta</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="n">vc</span><span class="p">)</span>
    <span class="c1"># gamma</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="n">vb</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cryst_const</span></div>



<div class="viewcode-block" id="cell2cc3d">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.cell2cc3d.html#pwtools.crys.cell2cc3d">[docs]</a>
<span class="k">def</span> <span class="nf">cell2cc3d</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as :func:`cell2cc` for 3d arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cell : 3d array</span>
<span class="sd">    axis : time axis (e.g. cell.shape = (100,3,3) -&gt; axis=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">cell</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">cell</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]):</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell2cc</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>



<div class="viewcode-block" id="cc2cell">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.cc2cell.html#pwtools.crys.cc2cell">[docs]</a>
<span class="nd">@crys_add_doc</span>
<span class="k">def</span> <span class="nf">cc2cell</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;From crystallographic constants a, b, c, alpha, beta,</span>
<span class="sd">    gamma to `cell`.</span>
<span class="sd">    This mapping not NOT unique in the sense that one set of `cryst_const` can</span>
<span class="sd">    have arbitrarily many representations in terms of cells. We stick to a</span>
<span class="sd">    common convention. See notes below.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(cryst_const_doc)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    %(cell_doc)s</span>
<span class="sd">        unit: [a]**3</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Basis vectors fulfilling the crystallographic constants are arbitrary</span>
<span class="sd">    w.r.t. their orientation in space. We choose the common convention that</span>

<span class="sd">    | va : along x axis</span>
<span class="sd">    | vb : in the x-y plane</span>

<span class="sd">    Then, vc is fixed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">beta</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">gamma</span> <span class="o">=</span> <span class="n">cryst_const</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">va</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">vb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="n">b</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">),</span> <span class="mi">0</span><span class="p">])</span>
    <span class="c1"># vc must be calculated:</span>
    <span class="c1"># cx: projection onto x axis (va)</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
    <span class="c1"># Now need cy and cz ...</span>
    <span class="c1">#</span>
    <span class="c1"># Maxima solution</span>
    <span class="c1">#</span>
    <span class="c1">## vol = volume_cc(cryst_const)</span>
    <span class="c1">## cz = vol / (a*b*sin(gamma))</span>
    <span class="c1">## cy = sqrt(a**2 * b**2 * c**2 * sin(beta)**2 * sin(gamma)**2 - \</span>
    <span class="c1">##     vol**2) / (a*b*sin(gamma))</span>
    <span class="c1">## cy2 = sqrt(c**2 - cx**2 - cz**2)</span>
    <span class="c1">#</span>
    <span class="c1"># PWscf , WIEN2K&#39;s sgroup, results are the same as with Maxima but the</span>
    <span class="c1"># formulas are shorter :)</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">-</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="p">))</span><span class="o">/</span><span class="n">sin</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
    <span class="n">cz</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cy</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">cx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">vc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cx</span><span class="p">,</span> <span class="n">cy</span><span class="p">,</span> <span class="n">cz</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">va</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">vc</span><span class="p">])</span></div>



<div class="viewcode-block" id="cc2cell3d">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.cc2cell3d.html#pwtools.crys.cc2cell3d">[docs]</a>
<span class="k">def</span> <span class="nf">cc2cell3d</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as :func:`cc2cell` for 2d arrays (the name &quot;3d&quot; is just to indicate</span>
<span class="sd">    that we work w/ trajectories).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cryst_const : 2d array</span>
<span class="sd">    axis : time axis (e.g. cryst_const.shape = (100,6) -&gt; axis=0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">cryst_const</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">cryst_const</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cryst_const</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]):</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cc2cell</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span></div>



<div class="viewcode-block" id="recip_cell">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.recip_cell.html#pwtools.crys.recip_cell">[docs]</a>
<span class="nd">@crys_add_doc</span>
<span class="k">def</span> <span class="nf">recip_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reciprocal lattice vectors ``{a,b,c}* = 2*pi / V * {b,c,a} x {c,a,b}``.</span>

<span class="sd">    The reciprocal volume is ``(2*pi)**3/V``. The length unit of the reciprocal</span>
<span class="sd">    vectors is 1/(length unit of `cell`), e.g. 1/Angstrom.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(cell_doc)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rcell : array (3,3)</span>
<span class="sd">        Reciprocal vectors as rows.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # the length of recip. cell vectors for a cubic cell of 1 Ang side</span>
<span class="sd">    &gt;&gt;&gt; # length is 2*pi -&gt; reciprocal length unit is 1/Ang</span>
<span class="sd">    &gt;&gt;&gt; crys.recip_cell(identity(3))/2/pi</span>
<span class="sd">    array([[ 1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; crys.recip_cell(identity(3)*2)/2/pi</span>
<span class="sd">    array([[ 0.5,  0. ,  0. ],</span>
<span class="sd">           [ 0. ,  0.5,  0. ],</span>
<span class="sd">           [ 0. ,  0. ,  0.5]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">assert_cond</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;cell must be (3,3) array&quot;</span><span class="p">)</span>
    <span class="n">rcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="n">vol</span> <span class="o">=</span> <span class="n">volume_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>
    <span class="n">rcell</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">vol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
    <span class="n">rcell</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">vol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
    <span class="n">rcell</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="n">vol</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rcell</span></div>



<div class="viewcode-block" id="grid_in_cell">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.grid_in_cell.html#pwtools.crys.grid_in_cell">[docs]</a>
<span class="k">def</span> <span class="nf">grid_in_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">minpoints</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">even</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fullout</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For a given cell, generate grid `size` from grid spacing `h` or vice</span>
<span class="sd">    versa.</span>

<span class="sd">    Usually used to calculate k-grids for reciprocal cells. See also `kgrid()`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cell : array (3,3)</span>
<span class="sd">        Cell with vectors as rows.</span>
<span class="sd">    h : float</span>
<span class="sd">        1d target grid spacing along a cell axis. Unit is that of the cell</span>
<span class="sd">        sides.</span>
<span class="sd">    size : sequence (3,)</span>
<span class="sd">        Use either `h` or `size`.</span>
<span class="sd">    minpoints : int</span>
<span class="sd">        Minimal number of grid points in each direction. May result in smaller</span>
<span class="sd">        effective `h`. `minpoints=1` (default) asserts that at least the</span>
<span class="sd">        Gamma point [1,1,1] is returned.  Otherwise, big cells or big `h`</span>
<span class="sd">        values will create zero grid points.</span>
<span class="sd">    even : bool</span>
<span class="sd">        Force even grid point numbers. Here, we add 1 to odd points, thus</span>
<span class="sd">        creating a grid more dense than requested by `h`.</span>
<span class="sd">    fullout : bool</span>
<span class="sd">        See below.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    size : if `h != None` + `fullout=False`</span>
<span class="sd">    size, spacing : if `h != None` + `fullout=True`</span>
<span class="sd">    spacing : if `size` != None and `h=None`</span>
<span class="sd">    size : array (3,) [nx, ny, nz]</span>
<span class="sd">        Integer numbers of grid points along each reciprocal axis.</span>
<span class="sd">    spacing : 1d array (3,)</span>
<span class="sd">        Result spacing along each reciprocal axis if `size` would be used.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * B/c an integer array is created by rounding, the effective grid spacing</span>
<span class="sd">      will mostly be slightly bigger/smaller then `h` (see `fullout`).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; crys.grid_in_cell(diag([1,2,3]), h=1)</span>
<span class="sd">    array([1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; crys.grid_in_cell(diag([1,2,3]), h=0.5)</span>
<span class="sd">    array([2, 4, 6])</span>
<span class="sd">    &gt;&gt;&gt; crys.grid_in_cell(diag([1,2,3]), h=0.5, fullout=True)</span>
<span class="sd">    (array([2, 4, 6]), array([ 0.5,  0.5,  0.5]))</span>
<span class="sd">    &gt;&gt;&gt; crys.grid_in_cell(diag([1,2,3]), size=[2,2,2])</span>
<span class="sd">    array([ 0.5,  1. ,  1.5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">spacing</span> <span class="o">=</span> <span class="n">h</span>
    <span class="k">assert</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="n">spacing</span><span class="p">,</span> <span class="n">size</span><span class="p">],</span> <span class="s2">&quot;use either `h` or `size`&quot;</span>
    <span class="k">assert</span> <span class="n">minpoints</span> <span class="o">&gt;=</span> <span class="mi">0</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">norms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">cell</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">norms</span> <span class="o">/</span> <span class="n">spacing</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">even</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">minpoints</span>
        <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">size</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">minpoints</span>
        <span class="c1"># only possible if minpoints=0</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;at least one point count is zero, decrease `spacing`, &quot;</span>
                            <span class="s2">&quot;size=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">fullout</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">size</span><span class="p">,</span> <span class="n">norms</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">size</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">norms</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">size</span></div>



<div class="viewcode-block" id="kgrid">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.kgrid.html#pwtools.crys.kgrid">[docs]</a>
<span class="k">def</span> <span class="nf">kgrid</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate k-point grid for given real-space cell or grid spacing from</span>
<span class="sd">    grid size.</span>

<span class="sd">    This is a convenience and backward compat function which does</span>
<span class="sd">    ``grid_in_cell(recip_cell(cell), **kwds)``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    cell : array (3,3)</span>
<span class="sd">        Real space unit cell.</span>
<span class="sd">    **kwds : See grid_in_cell()</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    See grid_in_cell().</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * Since the reciprocal cell is calculated with `recip_cell`, ``h=0.5``</span>
<span class="sd">      1/Ang seems to produce a sufficiently dense grid for insulators. Metals</span>
<span class="sd">      need a finer k-grid for electrons.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; from pwtools.crys import kgrid</span>
<span class="sd">    &gt;&gt;&gt; cell = np.diag([5,5,8])</span>
<span class="sd">    &gt;&gt;&gt; kgrid(cell, h=0.5)</span>
<span class="sd">    array([3, 3, 2])</span>
<span class="sd">    &gt;&gt;&gt; # see effective grid spacing</span>
<span class="sd">    &gt;&gt;&gt; kgrid(cell, h=0.5, fullout=True)</span>
<span class="sd">    (array([3, 3, 2]), array([ 0.41887902,  0.41887902,  0.39269908]))</span>
<span class="sd">    &gt;&gt;&gt; # reverse: effective grid spacing for given size</span>
<span class="sd">    &gt;&gt;&gt; kgrid(cell, size=[3,3,2])</span>
<span class="sd">    array([ 0.41887902,  0.41887902,  0.39269908])</span>
<span class="sd">    &gt;&gt;&gt; # even grid</span>
<span class="sd">    &gt;&gt;&gt; kgrid(cell, h=0.5, even=True)</span>
<span class="sd">    array([4, 4, 2])</span>
<span class="sd">    &gt;&gt;&gt; # big cell, at least Gamma with minpoints=1</span>
<span class="sd">    &gt;&gt;&gt; kgrid(cell*10, h=0.5)</span>
<span class="sd">    array([1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; # Create MP mesh</span>
<span class="sd">    &gt;&gt;&gt; ase.dft.monkhorst_pack(kgrid(cell, h=0.5))</span>
<span class="sd">    &gt;&gt;&gt; # cell: 1 Ang side length, recip cell 2*pi/Ang side length,</span>
<span class="sd">    &gt;&gt;&gt; # unit of h: 1/Ang</span>
<span class="sd">    &gt;&gt;&gt; crys.recip_cell(np.identity(3))</span>
<span class="sd">    array([[ 6.28318531,  0.        ,  0.        ],</span>
<span class="sd">           [ 0.        ,  6.28318531,  0.        ],</span>
<span class="sd">           [ 0.        ,  0.        ,  6.28318531]])</span>
<span class="sd">    &gt;&gt;&gt; kgrid(np.identity(3), h=pi, fullout=True)</span>
<span class="sd">    (array([2, 2, 2]), array([ 3.14159265,  3.14159265,  3.14159265]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s1">&#39;dk&#39;</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;`dk` is deprecated, use `h` instead&quot;</span><span class="p">,</span>
                      <span class="ne">DeprecationWarning</span><span class="p">)</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;h&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;dk&#39;</span><span class="p">]</span>
        <span class="n">kwds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;dk&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">grid_in_cell</span><span class="p">(</span><span class="n">recip_cell</span><span class="p">(</span><span class="n">cell</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>



<div class="viewcode-block" id="cc2celldm">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.cc2celldm.html#pwtools.crys.cc2celldm">[docs]</a>
<span class="nd">@crys_add_doc</span>
<span class="k">def</span> <span class="nf">cc2celldm</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert cryst_const to PWscf `celldm`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(cryst_const_doc)s</span>
<span class="sd">    fac : float, optional</span>
<span class="sd">        conversion a[any unit] -&gt; a[Bohr]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    %(celldm)s</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;cryst_const has length != 6&quot;</span><span class="p">)</span>
    <span class="n">celldm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">6</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cryst_const</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">celldm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">fac</span>
    <span class="n">celldm</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">/</span><span class="n">a</span>
    <span class="n">celldm</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">a</span>
    <span class="n">celldm</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span><span class="p">)</span>
    <span class="n">celldm</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">beta</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span><span class="p">)</span>
    <span class="n">celldm</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">gamma</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mf">180.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">celldm</span></div>



<div class="viewcode-block" id="celldm2cc">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.celldm2cc.html#pwtools.crys.celldm2cc">[docs]</a>
<span class="nd">@crys_add_doc</span>
<span class="k">def</span> <span class="nf">celldm2cc</span><span class="p">(</span><span class="n">celldm</span><span class="p">,</span> <span class="n">fac</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert PWscf celldm to cryst_const.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(celldm)s</span>
<span class="sd">    fac : float, optional</span>
<span class="sd">        conversion a[Bohr] -&gt; a[any unit]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">celldm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;celldm has length != 6&quot;</span><span class="p">)</span>
    <span class="n">cryst_const</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">6</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span><span class="n">ba</span><span class="p">,</span><span class="n">ca</span><span class="p">,</span><span class="n">cos_alpha</span><span class="p">,</span><span class="n">cos_beta</span><span class="p">,</span><span class="n">cos_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">celldm</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">*</span><span class="n">fac</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ba</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ca</span> <span class="o">*</span> <span class="n">a</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="n">cos_alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">180.0</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="n">cos_beta</span><span class="p">)</span> <span class="o">/</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">180.0</span>
    <span class="n">cryst_const</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="n">cos_gamma</span><span class="p">)</span> <span class="o">/</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">180.0</span>
    <span class="k">return</span> <span class="n">cryst_const</span></div>



<span class="c1">#-----------------------------------------------------------------------------</span>
<span class="c1"># super cell building</span>
<span class="c1">#-----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="scell_mask">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.scell_mask.html#pwtools.crys.scell_mask">[docs]</a>
<span class="k">def</span> <span class="nf">scell_mask</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span><span class="p">,</span> <span class="n">direc</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build a mask for the creation of a nx x ny x nz supercell (for 3d</span>
<span class="sd">    coordinates).</span>

<span class="sd">    Return all possible permutations with repitition of the integers ix, iy, iz</span>
<span class="sd">    = 0, ..., nx-1, ny-1, nz-1 . Dimensions can also be negative, in</span>
<span class="sd">    which case i = 0,-1,...,-n+1 . Parameter `direc` reverses the ordering.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nx, ny, nz : int</span>
<span class="sd">    direc : int</span>
<span class="sd">        1 or -1, order mask 0,...,n-1 (cells placed &quot;center to edge&quot;) or</span>
<span class="sd">        reverse n-1,...,0 (&quot;egde to center&quot;)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : 2d array, shape (nx*ny*nz, 3)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # 2x2x2 supercell</span>
<span class="sd">    &gt;&gt;&gt; scell_mask(2,2,2)</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 0.,  1.,  1.],</span>
<span class="sd">           [ 1.,  0.,  0.],</span>
<span class="sd">           [ 1.,  0.,  1.],</span>
<span class="sd">           [ 1.,  1.,  0.],</span>
<span class="sd">           [ 1.,  1.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; # 2x2x1 slab = &quot;plane&quot; of 4 cells</span>
<span class="sd">    &gt;&gt;&gt; scell_mask(2,2,1)</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 1.,  0.,  0.],</span>
<span class="sd">           [ 1.,  1.,  0.]])</span>
<span class="sd">    &gt;&gt;&gt; # direction reversed</span>
<span class="sd">    &gt;&gt;&gt; scell_mask(2,2,1,direc=-1)</span>
<span class="sd">    array([[ 1.,  1.,  0.],</span>
<span class="sd">           [ 1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">direc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">mkrange</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">direc</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">mkrange</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">mkrange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span> <span class="n">mkrange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span>
                                                  <span class="n">mkrange</span><span class="p">(</span><span class="n">nz</span><span class="p">))],</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></div>



<div class="viewcode-block" id="scell">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.scell.html#pwtools.crys.scell">[docs]</a>
<span class="k">def</span> <span class="nf">scell</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build supercell based on `dims`.</span>

<span class="sd">    Uses coords_frac and cell.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : Structure or Trajectory</span>
<span class="sd">    dims : tuple (nx, ny, nz) for a N = nx * ny * nz supercell</span>
<span class="sd">    method : int, optional</span>
<span class="sd">        Switch between numpy-ish (1) or loop (2) implementation. (2) should</span>
<span class="sd">        always produce correct results but is sublty slower. Only for</span>
<span class="sd">        Structure.</span>
<span class="sd">    **kwds : see :func:`scell_mask`</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The mask for the supercell is created by :func:`scell_mask` and applied to</span>
<span class="sd">    each atom in `obj` one after another, i.e. each atom is repeated nx*ny*nz</span>
<span class="sd">    times according to the mask pattern, independently of how the pattern looks</span>
<span class="sd">    like (e.g. the `direc` parameter in :func:`scell_mask`). So, just as rows</span>
<span class="sd">    in np.repeat(), we have:</span>

<span class="sd">    | original:     symbols=[A,B,C,D]</span>
<span class="sd">    | 2 x 1 x 1:    symbols=[A,A,B,B,C,C,D,D]</span>
<span class="sd">    | nx x ny x nz: symbols=[(nx*ny*nz) x A, (nx*ny*nz) x B, ...]</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scell : Structure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Place each atom N = nx*ny*nz times in the supercell, i.e. copy unit cell</span>
    <span class="c1"># N times. Actually, N-1, since ix=iy=iz=0 is the unit cell itself.</span>
    <span class="c1">#</span>
    <span class="c1"># Let k = {x,y,z}.</span>
    <span class="c1">#</span>
    <span class="c1"># mask[j,:] = [ix, iy, iz], ik = integers (floats actually, but</span>
    <span class="c1">#   mod(ik, floor(ik)) == 0.0)</span>
    <span class="c1">#</span>
    <span class="c1"># original cell:</span>
    <span class="c1"># coords_frac[i,:] = position vect of atom i in the unit cell in *crystal*</span>
    <span class="c1">#   coords!!</span>
    <span class="c1">#</span>
    <span class="c1"># super cell:</span>
    <span class="c1"># sc_coords_frac[i,:] = coords_frac[i,:] + [ix, iy, iz]</span>
    <span class="c1">#   for all permutations (see scell_mask()) of ix, iy, iz.</span>
    <span class="c1">#   ik = 0, ..., nk - 1</span>
    <span class="c1">#</span>
    <span class="c1"># sc_coords_frac : crystal coords w.r.t the *old* cell, i.e. the entries are in</span>
    <span class="c1"># [0,(max(dims))], not [0,1], is scaled below</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="s1">&#39;direc&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwds</span><span class="p">:</span>
        <span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;direc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">scell_mask</span><span class="p">(</span><span class="o">*</span><span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">nmask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
        <span class="n">sc_cell</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">cell</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dims</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">Structure</span>
    <span class="k">elif</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
        <span class="c1"># (nstep,3,3) * (1,3,1) -&gt; (nstep, 3,3)</span>
        <span class="n">sc_cell</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">cell</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dims</span><span class="p">)[</span><span class="kc">None</span><span class="p">,:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">Trajectory</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unknown input type&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">sc_symbols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">nmask</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">symbols</span>
                     <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="c1"># (natoms, 1, 3) + (1, nmask, 3) -&gt; (natoms, nmask, 3)</span>
            <span class="n">sc_coords_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,:]</span>
                              <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">natoms</span><span class="o">*</span><span class="n">nmask</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
            <span class="c1"># cool, eh?</span>
            <span class="c1"># (nstep, natoms, 1, 3) + (1, 1, nmask, 3) -&gt; (nstep, natoms, nmask, 3)</span>
            <span class="n">sc_coords_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span>
                              <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">nstep</span><span class="p">,</span><span class="n">obj</span><span class="o">.</span><span class="n">natoms</span><span class="o">*</span><span class="n">nmask</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;huh!?&quot;</span><span class="p">)</span>
    <span class="c1"># explicit loop version for testing, this is the reference implementation,</span>
    <span class="c1"># only for Structure</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="n">sc_symbols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">sc_coords_frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nmask</span><span class="o">*</span><span class="n">obj</span><span class="o">.</span><span class="n">natoms</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">iatom</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">natoms</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nmask</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">symbols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">sc_symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">iatom</span><span class="p">])</span>
                    <span class="n">sc_coords_frac</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">[</span><span class="n">iatom</span><span class="p">,:]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span>
                    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;method=2 only implemented for Structure&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unknown method: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="nb">repr</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>
    <span class="n">sc_coords_frac</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">sc_coords_frac</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sc_coords_frac</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">/=</span> <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">container</span><span class="p">(</span><span class="n">coords_frac</span><span class="o">=</span><span class="n">sc_coords_frac</span><span class="p">,</span>
                     <span class="n">cell</span><span class="o">=</span><span class="n">sc_cell</span><span class="p">,</span>
                     <span class="n">symbols</span><span class="o">=</span><span class="n">sc_symbols</span><span class="p">)</span></div>



<div class="viewcode-block" id="scell3d">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.scell3d.html#pwtools.crys.scell3d">[docs]</a>
<span class="k">def</span> <span class="nf">scell3d</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Supercell for Trajectory. Deprecated. Use :func:`scell` instead.&quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;scell3d() is deprecated, use scell() for Trajectory as well&quot;</span><span class="p">,</span>
                  <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scell</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>



<span class="c1">#-----------------------------------------------------------------------------</span>
<span class="c1"># atomic coords processing / evaluation, MD analysis</span>
<span class="c1">#-----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="velocity_traj">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.velocity_traj.html#pwtools.crys.velocity_traj">[docs]</a>
<span class="k">def</span> <span class="nf">velocity_traj</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">endpoints</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate velocity from `arr` (usually coordinates) along time`axis`</span>
<span class="sd">    using timestep `dt`.</span>

<span class="sd">    Central differences are used (example x-coord of atom 0:</span>
<span class="sd">    ``x=coords[:,0,0]``)::</span>

<span class="sd">        v[i] = [ x[i+1] - x[i-1] ] / (2*dt)</span>

<span class="sd">    which returns nstep-2 points belonging to the the middle of the</span>
<span class="sd">    trajectory x[1:-1]. To get an array which is `nstep` long, the fist and</span>
<span class="sd">    last velocity are set to the first and last calculated value (if</span>
<span class="sd">    ``endpoints=True``)::</span>

<span class="sd">        v[0,...] == v[1,...]</span>
<span class="sd">        v[-1,...] == v[-2,...]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Central diffs are more accurate than simple finite diffs</span>
    <span class="c1">#</span>
    <span class="c1">#   v[i] = [ x[i+1] - x[i] ] / dt</span>
    <span class="c1">#</span>
    <span class="c1"># These return nstep-1 points (one more then central diffs) but we</span>
    <span class="c1"># have the problem of assigning the velocity array to the time axis:</span>
    <span class="c1"># t[1:] or t[:-1] are both shifted w.r.t. to the real time axis</span>
    <span class="c1"># position -- the correct way would be to assign it to t[:-1] + 0.5*dt.</span>
    <span class="c1"># In contrast, central diffs belong to t[1:-1] by definition.</span>
    <span class="c1">#</span>
    <span class="c1"># If self.timestep is small (i.e. the trajectory is smooth), all this is</span>
    <span class="c1"># not really a problem, but central diffs are just better and more</span>
    <span class="c1"># consistent. Even forces calculated from these velocities (force =</span>
    <span class="c1"># mass * dv / dt) are reasonably accurate compared to the forces from</span>
    <span class="c1"># the MD trajectory input. One could implement get_forces() like that</span>
    <span class="c1"># if needed, but so far all MD codes provide us their forces, of</span>
    <span class="c1"># course. Also, one *could* create 3*natoms Spline objects thru coords</span>
    <span class="c1"># (splines along time axis) and calc 1st and 2nd deriv from that. But</span>
    <span class="c1"># that&#39;s probably very slow.</span>
    <span class="k">if</span> <span class="n">endpoints</span><span class="p">:</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="c1"># To support general axis stuff, use slice magic ala slicetake/sliceput</span>
    <span class="k">assert</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;only axis==0 implemented ATM&quot;</span><span class="p">)</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span><span class="o">...</span><span class="p">]</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">...</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="n">dt</span>
    <span class="k">if</span> <span class="n">endpoints</span><span class="p">:</span>
        <span class="n">vv</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="n">vv</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
        <span class="n">vv</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vv</span> <span class="o">=</span> <span class="n">tmp</span>
    <span class="k">return</span> <span class="n">vv</span></div>



<div class="viewcode-block" id="rmsd">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.rmsd.html#pwtools.crys.rmsd">[docs]</a>
<span class="k">def</span> <span class="nf">rmsd</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">ref_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Root mean square distance over an MD trajectory.</span>

<span class="sd">    The normalization constant is the number of atoms. Takes the RMS of the</span>
<span class="sd">    difference of *cartesian* coords at each time step. Only meaningful if</span>
<span class="sd">    ``tr.coords`` are *not* pbc-wrapped.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    traj : Trajectory object</span>
<span class="sd">    ref_idx : int, optional</span>
<span class="sd">        time index of the reference structure (i.e. 0 to compare with the</span>
<span class="sd">        start structure, -1 for the last along `axis`).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rmsd : 1d array (traj.nstep,)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # We only need traj.{coords,nstep,timeaxis}, no symbols, cell, ...</span>
<span class="sd">    &gt;&gt;&gt; traj = crys.Trajectory(coords=rand(500,10,3))</span>
<span class="sd">    &gt;&gt;&gt; # The RMSD w.r.t. the start structure. See when the structure starts to</span>
<span class="sd">    &gt;&gt;&gt; # &quot;converge&quot; to a stable mean configuration during an MD.</span>
<span class="sd">    &gt;&gt;&gt; rmsd(traj, ref_idx=0)</span>
<span class="sd">    &gt;&gt;&gt; # For a relaxation run, the RMSD w.r.t. the final converged structure. The</span>
<span class="sd">    &gt;&gt;&gt; # RMSD should converge to zero here.</span>
<span class="sd">    &gt;&gt;&gt; rmsd(traj, ref_idx=-1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># sl_ref : pull out 2d array of coords of the reference structure</span>
    <span class="c1"># sl_newaxis : slice to broadcast (newaxis) this 2d array to 3d for easy</span>
    <span class="c1">#     substraction</span>
    <span class="k">assert</span> <span class="n">traj</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">sl_ref</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">sl_ref</span><span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref_idx</span>
    <span class="n">sl_newaxis</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">sl_newaxis</span><span class="p">[</span><span class="n">traj</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl_ref</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">coords</span> <span class="o">-=</span> <span class="n">ref</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl_newaxis</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">rms3d</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">,</span> <span class="n">nitems</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">natoms</span><span class="p">))</span></div>



<div class="viewcode-block" id="pbc_wrap_coords">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.pbc_wrap_coords.html#pwtools.crys.pbc_wrap_coords">[docs]</a>
<span class="k">def</span> <span class="nf">pbc_wrap_coords</span><span class="p">(</span><span class="n">coords_frac</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="n">xyz_axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply periodic boundary conditions to array of fractional coords.</span>

<span class="sd">    Wrap atoms with fractional coords &gt; 1 or &lt; 0 into the cell.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords_frac : array 2d or 3d</span>
<span class="sd">        fractional coords, if 3d then one axis is assumed to be a time axis and</span>
<span class="sd">        the array is a MD trajectory or such</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Copy coords_frac before applying pbc.</span>
<span class="sd">    mask : sequence of bools, len = 3 for x,y,z</span>
<span class="sd">        Apply pbc only x, y or z. E.g. [True, True, False] would not wrap the z</span>
<span class="sd">        coordinate.</span>
<span class="sd">    xyz_axis : the axis of `coords_frac` where the indices 0,1,2 pull out the x,y,z</span>
<span class="sd">        coords. For a usual 2d array of coords with shape (natoms,3),</span>
<span class="sd">        xyz_axis=1 (= last axis = -1). For a 3d array (natoms, nstep, 3),</span>
<span class="sd">        xyz_axis=2 (also -1).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    coords_frac : array_like(coords_frac)</span>
<span class="sd">        Array with all values in [0,1] except for those where ``mask[i]=False``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    About the copy arg: If ``copy=False``, then this is an in-place operation</span>
<span class="sd">    and the array in the global scope is modified! In fact, then these do the</span>
<span class="sd">    same::</span>

<span class="sd">        &gt;&gt;&gt; a = pbc_wrap_coords(a, copy=False)</span>
<span class="sd">        &gt;&gt;&gt; pbc_wrap_coords(a, copy=False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">coords_frac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">xyz_axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;dim of xyz_axis of `coords_frac` must be == 3&quot;</span>
    <span class="n">ndim</span> <span class="o">=</span> <span class="n">coords_frac</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">assert</span> <span class="n">ndim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s2">&quot;coords_frac must be 2d or 3d array&quot;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">coords_frac</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">coords_frac</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">xyz_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">tsl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">tsl</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="n">tsl</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tmp</span></div>



<div class="viewcode-block" id="pbc_wrap">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.pbc_wrap.html#pwtools.crys.pbc_wrap">[docs]</a>
<span class="k">def</span> <span class="nf">pbc_wrap</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply periodic boundary conditions to fractional coords.</span>

<span class="sd">    Same as :func:`pbc_wrap_coords` but accepts a Structure or Trajectory</span>
<span class="sd">    instead of the array ``coords_frac``. Returns an object with atoms</span>
<span class="sd">    (coords_frac and coords) wrapped into the cell.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : Structure or Trajectory</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Return copy or in-place modified object.</span>
<span class="sd">    **kwds : keywords</span>
<span class="sd">        passed to :func:`pbc_wrap_coords`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">obj</span>
    <span class="c1"># set to None so that it will be re-calculated by set_all()</span>
    <span class="n">out</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># copy=False: in-place modify b/c we copied the whole object before if</span>
    <span class="c1"># requested by user</span>
    <span class="n">pbc_wrap_coords</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">set_all</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="coord_trans">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.coord_trans.html#pwtools.crys.coord_trans">[docs]</a>
<span class="k">def</span> <span class="nf">coord_trans</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;General-purpose n-dimensional coordinate transformation. `coords` can</span>
<span class="sd">    have arbitrary dimension, i.e. it can contain many vectors to be</span>
<span class="sd">    transformed at once. But `old` and `new` must have ndim=2, i.e. only one</span>
<span class="sd">    old and new coord sys for all vectors in `coords`.</span>

<span class="sd">    The most general case is that you want to transform an MD trajectory from a</span>
<span class="sd">    variable cell run, you have smth like this:</span>

<span class="sd">        | coords.shape = (nstep,natoms,3)</span>
<span class="sd">        | old.shape/new.shape = (nstep,3,3)</span>

<span class="sd">    You have a set of old and new coordinate systems at each step.</span>
<span class="sd">    Then, use a loop over all time steps and call this function nstep times.</span>
<span class="sd">    See also coord_trans3d().</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords : array (d0, d1, ..., M)</span>
<span class="sd">        Array of arbitrary rank with coordinates (length M vectors) in old</span>
<span class="sd">        coord sys `old`. The only shape resiriction is that the last dim must</span>
<span class="sd">        equal the number of coordinates (coords.shape[-1] == M == 3 for normal</span>
<span class="sd">        3-dim x,y,z).</span>

<span class="sd">        | 1d : trivial, transform that vector (length M)</span>
<span class="sd">        | 2d : The matrix must have shape (N,M), i.e. N vectors to be</span>
<span class="sd">        |      transformed are the *rows*.</span>
<span class="sd">        | 3d : coords must have shape (..., M)</span>

<span class="sd">        If `coords` has a different shape, use `axis` to define the M-axis.</span>
<span class="sd">    old, new : 2d arrays (M,M)</span>
<span class="sd">        Matrices with the old and new basis vectors as *rows*. Note that in the</span>
<span class="sd">        usual math literature, columns are used. In that case, use ``old.T`` and/or</span>
<span class="sd">        ``new.T``.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        True: overwrite `coords`</span>
<span class="sd">        False: return new array</span>
<span class="sd">    axis : the axis along which the length-M vectors are placed in `coords`,</span>
<span class="sd">        default is -1, i.e. coords.shape = (...,M)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array of shape = coords.shape, coordinates in system `new`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # Taken from [1]_.</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import math</span>
<span class="sd">    &gt;&gt;&gt; v_I = np.array([1.0,1.5])</span>
<span class="sd">    &gt;&gt;&gt; I = np.identity(2)</span>
<span class="sd">    &gt;&gt;&gt; X = math.sqrt(2)/2.0*np.array([[1,-1],[1,1]]).T</span>
<span class="sd">    &gt;&gt;&gt; Y = np.array([[1,1],[0,1]]).T</span>
<span class="sd">    &gt;&gt;&gt; coord_trans(v_I,I,I)</span>
<span class="sd">    array([ 1. ,  1.5])</span>
<span class="sd">    &gt;&gt;&gt; v_X = coord_trans(v,I,X)</span>
<span class="sd">    &gt;&gt;&gt; v_Y = coord_trans(v,I,Y)</span>
<span class="sd">    &gt;&gt;&gt; v_X</span>
<span class="sd">    array([ 1.76776695,  0.35355339])</span>
<span class="sd">    &gt;&gt;&gt; v_Y</span>
<span class="sd">    array([-0.5,  1.5])</span>
<span class="sd">    &gt;&gt;&gt; coord_trans(v_Y,Y,I)</span>
<span class="sd">    array([ 1. ,  1.5])</span>
<span class="sd">    &gt;&gt;&gt; coord_trans(v_X,X,I)</span>
<span class="sd">    array([ 1. ,  1.5])</span>
<span class="sd">    &gt;&gt;&gt; # 3d example</span>
<span class="sd">    &gt;&gt;&gt; c_old = np.random.rand(30,200,3)</span>
<span class="sd">    &gt;&gt;&gt; old = np.random.rand(3,3)</span>
<span class="sd">    &gt;&gt;&gt; new = np.random.rand(3,3)</span>
<span class="sd">    &gt;&gt;&gt; c_new = coord_trans(c_old, old=old, new=new)</span>
<span class="sd">    &gt;&gt;&gt; c_old2 = coord_trans(c_new, old=new, new=old)</span>
<span class="sd">    &gt;&gt;&gt; np.testing.assert_almost_equal(c_old, c_old2)</span>
<span class="sd">    &gt;&gt;&gt; # If you have an array of shape, say (10,3,100), i.e. the last</span>
<span class="sd">    &gt;&gt;&gt; # dimension is NOT 3, then use numpy.swapaxes() or axis:</span>
<span class="sd">    &gt;&gt;&gt; coord_trans(arr, old=..., new=..., axis=1)</span>
<span class="sd">    &gt;&gt;&gt; coord_trans(arr.swapaxes(1,2), old=..., new=...).swapaxes(1,2)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] http://www.mathe.tu-freiberg.de/~eiermann/Vorlesungen/HM/index_HM2.htm, Ch.6</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    coord_trans3d</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">common</span><span class="o">.</span><span class="n">assert_cond</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">new</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span>
                       <span class="s2">&quot;`old` and `new` must be rank 2 arrays&quot;</span><span class="p">)</span>
    <span class="n">common</span><span class="o">.</span><span class="n">assert_cond</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">new</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                       <span class="s2">&quot;`old` and `new` must have th same shape&quot;</span><span class="p">)</span>
    <span class="n">common</span><span class="o">.</span><span class="n">assert_cond</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                      <span class="s2">&quot;`old` and `new` must be square&quot;</span><span class="p">)</span>
    <span class="c1"># arr.T and arr.swapaxes() are no in-place operations, just views, input</span>
    <span class="c1"># arrays are not changed, but copy() b/c we can overwrite coords</span>
    <span class="n">_coords</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">coords</span>
    <span class="n">mx_axis</span> <span class="o">=</span> <span class="n">_coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">mx_axis</span> <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="n">axis</span>
    <span class="c1"># must use `coords[:] = ...`, just `coords = ...` is a new array</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="n">mx_axis</span><span class="p">:</span>
        <span class="c1"># bring xyz-axis to -1 for broadcasting</span>
        <span class="n">_coords</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">_trans</span><span class="p">(</span><span class="n">_coords</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">),</span>
                            <span class="n">old</span><span class="p">,</span>
                            <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_coords</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">_trans</span><span class="p">(</span><span class="n">_coords</span><span class="p">,</span>
                            <span class="n">old</span><span class="p">,</span>
                            <span class="n">new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_coords</span></div>



<div class="viewcode-block" id="_trans">
<a class="viewcode-back" href="../../generated/api/pwtools.crys._trans.html#pwtools.crys._trans">[docs]</a>
<span class="k">def</span> <span class="nf">_trans</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper for coord_trans().&quot;&quot;&quot;</span>
    <span class="n">common</span><span class="o">.</span><span class="n">assert_cond</span><span class="p">(</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="s2">&quot;last dim of `coords` must match first dim&quot;</span>
                       <span class="s2">&quot; of `old` and `new`&quot;</span><span class="p">)</span>
    <span class="c1"># The equation works for ``old.T`` and ``new.T`` = columns.</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">old</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>



<div class="viewcode-block" id="coord_trans3d">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.coord_trans3d.html#pwtools.crys.coord_trans3d">[docs]</a>
<span class="k">def</span> <span class="nf">coord_trans3d</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">new</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">timeaxis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Special case version for debugging mostly. It does the loop for the</span>
<span class="sd">    general case where coords+old+new are 3d arrays (e.g. variable cell MD</span>
<span class="sd">    trajectory).</span>

<span class="sd">    This may be be slow for large ``nstep``. All other cases (``coords`` has</span>
<span class="sd">    arbitrary many dimensions, i.e. ndarray + old/new are fixed) are covered</span>
<span class="sd">    by coord_trans(). Also some special cases may be possible to solve with</span>
<span class="sd">    np.dot() alone if the transformation simplifes. Check your math.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords : 3d array</span>
<span class="sd">        one axis (`axis`) must have length-M vectors, another (`timeaxis`) must</span>
<span class="sd">        be length `nstep`</span>
<span class="sd">    old,new : 2d arrays, two axes must be of equal length</span>
<span class="sd">    copy : see coord_trans()</span>
<span class="sd">    axis : axis where length-M vecs are placed if the timeaxis is removed</span>
<span class="sd">    timeaxis : time axis along which 2d arrays are aligned</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    | M = 3</span>
<span class="sd">    | coords :  (nstep,natoms,3)</span>
<span class="sd">    | old,new : (nstep,3,3)</span>
<span class="sd">    | timeaxis = 0</span>
<span class="sd">    | axis = 1 == -1 (remove timeaxis -&gt; 2d slices (natoms,3) and (3,3) -&gt; axis=1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">old</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span><span class="p">,</span> <span class="s2">&quot;ndim: coords: </span><span class="si">%i</span><span class="s2">, old: </span><span class="si">%i</span><span class="s2">, new: </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">timeaxis</span><span class="p">],</span> <span class="n">old</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">timeaxis</span><span class="p">],</span> <span class="n">new</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">timeaxis</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="o">==</span> <span class="n">c</span><span class="p">,</span> <span class="s2">&quot;shape[timeaxis]: coords: </span><span class="si">%i</span><span class="s2">, old: </span><span class="si">%i</span><span class="s2">, new: </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">ndim</span>
    <span class="n">nstep</span> <span class="o">=</span> <span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">timeaxis</span><span class="p">]</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nstep</span><span class="p">):</span>
        <span class="n">sl</span><span class="p">[</span><span class="n">timeaxis</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span>
        <span class="n">tsl</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coord_trans</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">tsl</span><span class="p">],</span>
                               <span class="n">old</span><span class="o">=</span><span class="n">old</span><span class="p">[</span><span class="n">tsl</span><span class="p">],</span>
                               <span class="n">new</span><span class="o">=</span><span class="n">new</span><span class="p">[</span><span class="n">tsl</span><span class="p">],</span>
                               <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                               <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">))</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">timeaxis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">timeaxis</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="min_image_convention">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.min_image_convention.html#pwtools.crys.min_image_convention">[docs]</a>
<span class="k">def</span> <span class="nf">min_image_convention</span><span class="p">(</span><span class="n">sij</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply minimum image convention to differences of fractional coords.</span>

<span class="sd">    Handles also cases where coordinates are separated by an arbitrary number</span>
<span class="sd">    of periodic images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sij : ndarray</span>
<span class="sd">        Differences of fractional coordinates, usually (natoms, natoms, 3),</span>
<span class="sd">        i.e. a, &quot;matrix&quot; of distance vectors, obtained by smth like</span>
<span class="sd">        ``sij = coords_frac[:,None,:] - coords_frac[None,:,:]`` where</span>
<span class="sd">        ``coords_frac.shape = (natoms,3)``.</span>
<span class="sd">    copy : bool, optional</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sij in-place modified or copy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sij</span> <span class="o">=</span> <span class="n">sij</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">sij</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">sij</span> <span class="o">&gt;=</span> <span class="mf">0.5</span>
    <span class="k">while</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">sij</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">-=</span> <span class="mf">1.0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">sij</span> <span class="o">&gt;=</span> <span class="mf">0.5</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">sij</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="k">while</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">sij</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">+=</span> <span class="mf">1.0</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">sij</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span>
    <span class="k">return</span> <span class="n">sij</span></div>



<div class="viewcode-block" id="rmax_smith">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.rmax_smith.html#pwtools.crys.rmax_smith">[docs]</a>
<span class="nd">@crys_add_doc</span>
<span class="k">def</span> <span class="nf">rmax_smith</span><span class="p">(</span><span class="n">cell</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate rmax as in [Smith]_, where rmax = the maximal distance up to</span>
<span class="sd">    which minimum image nearest neighbor distances are correct.</span>

<span class="sd">    The cell vecs must be the rows of `cell`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    %(cell_doc)s</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rmax : float</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [Smith] W. Smith, The Minimum Image Convention in Non-Cubic MD Cells,</span>
<span class="sd">               http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1696</span>
<span class="sd">               1989</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>
    <span class="n">bxc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>
    <span class="n">cxa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
    <span class="n">wa</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bxc</span><span class="p">))</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">bxc</span><span class="p">)</span>
    <span class="n">wb</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">cxa</span><span class="p">))</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">cxa</span><span class="p">)</span>
    <span class="n">wc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">axb</span><span class="p">))</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">axb</span><span class="p">)</span>
    <span class="n">rmax</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">wa</span><span class="p">,</span><span class="n">wb</span><span class="p">,</span><span class="n">wc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rmax</span></div>



<div class="viewcode-block" id="rpdf">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.rpdf.html#pwtools.crys.rpdf">[docs]</a>
<span class="k">def</span> <span class="nf">rpdf</span><span class="p">(</span><span class="n">trajs</span><span class="p">,</span> <span class="n">dr</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">amask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
         <span class="n">dmask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">norm_vmd</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">maxmem</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Radial pair distribution (pair correlation) function for Structures and</span>
<span class="sd">    Trajectories. In case of trajectories, the time-averaged RPDF is returned.</span>
<span class="sd">    Can also handle non-orthorhombic unit cells (simulation boxes).</span>
<span class="sd">    Only fixed-cell MD at the moment.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trajs : Structure or Trajectory or list of one or two such objects</span>
<span class="sd">        The case ``len(trajs)==1`` is the same as providing the object directly</span>
<span class="sd">        (most common case). Internally we expand the input to ``[trajs,</span>
<span class="sd">        trajs]``, i.e. the RPDF of the 2nd coord set w.r.t. to the first is</span>
<span class="sd">        calculated -- the order matters! This is like selection 1 and 2 in VMD,</span>
<span class="sd">        but nornmally you would use `amask` instead. The option to provide a</span>
<span class="sd">        list of two Trajectory objects exists for cases where you don&#39;t want to</span>
<span class="sd">        use `amask`, but create two different Trajectory objects outside.</span>
<span class="sd">    dr : float, optional</span>
<span class="sd">        Radius spacing. Must have the same unit as `cell`, e.g. Angstrom.</span>
<span class="sd">    rmax : {&#39;auto&#39;, float}, optional</span>
<span class="sd">        Max. radius up to which minimum image nearest neighbors are counted.</span>
<span class="sd">        For cubic boxes of side length L, this is L/2 [AT,MD].</span>

<span class="sd">        | &#39;auto&#39; : the method of [Smith] is used to calculate the max. sphere</span>
<span class="sd">        |     raduis for any cell shape</span>
<span class="sd">        | float : set value yourself</span>
<span class="sd">    amask : None, list of one or two bool 1d arrays, list of one or two strings</span>
<span class="sd">        Optional atom mask. This is the complementary functionality to</span>
<span class="sd">        `sel` in :func:`vmd_measure_gofr`. If ``len(amask)==1``, then we expand</span>
<span class="sd">        to ``[amask, amask]`` internally, which would calculate the RPDF</span>
<span class="sd">        between the same atom selection. If two masks are given, then the first</span>
<span class="sd">        is applied to ``trajs[0]`` and the second to ``trajs[1]``. Use this to</span>
<span class="sd">        select only certain atoms in each Trajectory. The default is to provide</span>
<span class="sd">        bool arrays. If you provide strings, they are assumed to be atom names</span>
<span class="sd">        and we create a bool array ``np.array(symbols) == amask[i]``.</span>
<span class="sd">    tmask : None or slice object, optional</span>
<span class="sd">        Time mask. Slice for the time axis, e.g. to use only every 100th step,</span>
<span class="sd">        starting from step 2000 to the end, use ``tmask=slice(2000,None,100)``,</span>
<span class="sd">        which is the same as ``np.s_[2000::100]``.</span>
<span class="sd">    dmask : None or string, optional</span>
<span class="sd">        Distance mask. Restrict to certain distances using numpy syntax for</span>
<span class="sd">        creating bool arrays::</span>

<span class="sd">            &#39;&gt;=1.0&#39;</span>
<span class="sd">            &#39;{d} &gt;=1.0&#39; # the same</span>
<span class="sd">            &#39;({d} &gt; 1.0) &amp; ({d} &lt; 3.0)&#39;</span>

<span class="sd">        where ``{d}`` is a placeholder for the distance array (you really have to</span>
<span class="sd">        use ``{d}``). The placeholder is optional in some pattern. This is similar</span>
<span class="sd">        to VMD&#39;s &quot;within&quot; (``pbc=False``) or &quot;pbwithin&quot; (``pbc=True``) syntax.</span>
<span class="sd">    pbc : bool, optional</span>
<span class="sd">        apply minimum image convention to distances</span>
<span class="sd">    norm_vmd : bool, optional</span>
<span class="sd">        Normalize `g(r)` like in VMD by counting duplicate atoms and normalize to</span>
<span class="sd">        ``natoms0 * natoms1 - duplicates`` instead of ``natoms0*natoms1``. Affects</span>
<span class="sd">        all-all correlations only. `num_int` is not affected. Use this only for</span>
<span class="sd">        testing.</span>
<span class="sd">    maxmem : float, optional</span>
<span class="sd">        Maximal allowed memory to use, in GB.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array (len(rad), 3), the columns are</span>
<span class="sd">    rad : 1d array</span>
<span class="sd">        radius (x-axis) with spacing `dr`, each value r[i] is the middle of a</span>
<span class="sd">        histogram bin</span>
<span class="sd">    hist : 1d array, (len(rad),)</span>
<span class="sd">        the function values `g(r)`</span>
<span class="sd">    num_int : 1d array, (len(rad),)</span>
<span class="sd">        the (averaged) number integral ``number_density*hist*4*pi*r**2.0*dr``</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `rmax` : The maximal `rmax` for which g(r) is correctly normalized is the</span>
<span class="sd">    result of :func:`rmax_smith`, i.e. the radius if the biggest sphere which</span>
<span class="sd">    fits entirely into the cell. This is simply L/2 for cubic boxes of side</span>
<span class="sd">    length L and volume L**3, for instance. We do explicitely allow `rmax` &gt;</span>
<span class="sd">    `rmax_smith` for testing, but be aware that `g(r)` and the number integral</span>
<span class="sd">    are *wrong* for `rmax` &gt; `rmax_smith`.</span>

<span class="sd">    Even though the number integral will always converge to the number of all</span>
<span class="sd">    neighbors for r -&gt; infinity, the integral value (the number of neigbors) is</span>
<span class="sd">    correct only up to `rmax_smith`.</span>

<span class="sd">    See ``examples/rpdf/`` for educational evidence. For notes on how VMD does</span>
<span class="sd">    this, see comments in the code below.</span>

<span class="sd">    selection : The selection mechanism with `amask` is in principle as capable</span>
<span class="sd">    as VMD&#39;s, but relies completely on the user&#39;s ability to create bool arrays</span>
<span class="sd">    to filter the atoms. In practice, anything more complicated than</span>
<span class="sd">    ``array(symbols)==&#39;O&#39;`` (&quot;name O&quot; in VMD) is much more difficult than VMD&#39;s</span>
<span class="sd">    powerful selection syntax.</span>

<span class="sd">    Curently, the atom distances are calculated by using numpy fancy indexing.</span>
<span class="sd">    That creates (big) arrays in memory. For data from long MDs, you may run</span>
<span class="sd">    into trouble here. For a 20000 step MD, start by using every 200th step or</span>
<span class="sd">    so (use ``tmask=slice(None,None,200)``) and look at the histogram, as you</span>
<span class="sd">    take more and more points into account (every 100th, 50th step, ...).</span>
<span class="sd">    Especially for Car Parrinello, where time steps are small and the structure</span>
<span class="sd">    doesn&#39;t change much, there is no need to use every step. See also `maxmem`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; # simple all-all RPDF, time-averaged over all MD steps</span>
<span class="sd">    &gt;&gt;&gt; d = rpdf(traj)</span>

<span class="sd">    &gt;&gt;&gt; # the same as rpdf(traj,...)</span>
<span class="sd">    &gt;&gt;&gt; d = rpdf([traj], ...)</span>
<span class="sd">    &gt;&gt;&gt; d = rpdf([traj, traj], ...)</span>

<span class="sd">    &gt;&gt;&gt; # 2 selections: RPDF of all H&#39;s around all O&#39;s, average time step 3000 to</span>
<span class="sd">    &gt;&gt;&gt; # end, take every 50th step</span>
<span class="sd">    &gt;&gt;&gt; traj = io.read_cp2k_md(&#39;cp2k.out&#39;)</span>
<span class="sd">    &gt;&gt;&gt; d = rpdf(traj, dr=0.1, amask=[&#39;O&#39;, &#39;H&#39;],tmask=np.s_[3000::50])</span>
<span class="sd">    &gt;&gt;&gt; plot(d[:,0], d[:,1], label=&#39;g(r)&#39;)</span>
<span class="sd">    &gt;&gt;&gt; twinx()</span>
<span class="sd">    &gt;&gt;&gt; plot(d[:,0], d[:,2], label=&#39;number integral&#39;)</span>

<span class="sd">    &gt;&gt;&gt; # use bool arrays for `amask`, need this for more complicated pattern</span>
<span class="sd">    &gt;&gt;&gt; sy = np.array(traj.symbols)</span>
<span class="sd">    &gt;&gt;&gt; # VMD: sel1=&#39;name O&#39;, sel2=&#39;name H&#39;, same as amask=[&#39;O&#39;, &#39;H&#39;]</span>
<span class="sd">    &gt;&gt;&gt; d = rpdf(traj, dr=0.1, amask=[sy==&#39;O&#39;, sy==&#39;H&#39;],tmask=np.s_[3000::50])</span>
<span class="sd">    &gt;&gt;&gt; # VMD: sel1=&#39;name O&#39;, sel2=&#39;name H Cl&#39;, note that the bool arrays must</span>
<span class="sd">    &gt;&gt;&gt; # be logically OR&#39;ed (| operator) to get the ffect of &quot;H and Cl&quot;</span>
<span class="sd">    &gt;&gt;&gt; d = rpdf(traj, dr=0.1, amask=[sy==&#39;O&#39;, (sy==&#39;H&#39;) | (sy==&#39;Cl&#39;)],tmask=np.s_[3000::50])</span>

<span class="sd">    &gt;&gt;&gt; # skip distances &gt;1 Ang</span>
<span class="sd">    &gt;&gt;&gt; d = rpdf(traj, dr=0.1, amask=[&#39;O&#39;, &#39;H&#39;],tmask=np.s_[3000::50]</span>
<span class="sd">    ...          dmask=&#39;{d}&gt;1.0&#39;)</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [AT] M. P. Allen, D. J. Tildesley, Computer Simulation of Liquids,</span>
<span class="sd">         Clarendon Press, 1989</span>
<span class="sd">    [MD] R. Haberlandt, S. Fritzsche, G. Peinel, K. Heinzinger,</span>
<span class="sd">         Molekulardynamik - Grundlagen und Anwendungen,</span>
<span class="sd">         Friedrich Vieweg &amp; Sohn Verlagsgesellschaft 1995</span>
<span class="sd">    [Smith] W. Smith, The Minimum Image Convention in Non-Cubic MD Cells,</span>
<span class="sd">            http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.1696</span>
<span class="sd">            1989</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Theory</span>
    <span class="c1"># ======</span>
    <span class="c1">#</span>
    <span class="c1"># 1) N equal particles (atoms) in a volume V.</span>
    <span class="c1">#</span>
    <span class="c1"># Below, &quot;density&quot; always means number density, i.e. (N atoms in the unit</span>
    <span class="c1"># cell)  / (unit cell volume V).</span>
    <span class="c1">#</span>
    <span class="c1"># g(r) is (a) the average atom density in a shell [r,r+dr] around an atom at</span>
    <span class="c1"># r=0, relative to an &quot;ideal gas&quot; (random distribution) of density N/V.</span>
    <span class="c1"># (b) Equivalent: The average number of atom pairs with distance r relative</span>
    <span class="c1"># to the number of pairs with distance r in a random distribution.</span>
    <span class="c1">#</span>
    <span class="c1"># For each atom i=1,N, count the number of atoms j around it in the shell</span>
    <span class="c1"># [r,r+dr] with r_ij = r_i - r_j, r &lt; r_ij &lt;= r+dr</span>
    <span class="c1">#</span>
    <span class="c1">#   s(r) = sum(i=1,N) sum(j=1,N, j!=i) delta(r - r_ij)</span>
    <span class="c1">#</span>
    <span class="c1"># In practice, this is done by calculating all distances r_ij and bin them</span>
    <span class="c1"># into a histogram s(k) with k = r_ij / dr the histogram index.</span>
    <span class="c1">#</span>
    <span class="c1">#   g(r) = s(r) / [N * (N/V) * V(r)]</span>
    <span class="c1">#        = s(r) / [N**2/V * V(r)]</span>
    <span class="c1">#   V(r) = 4*pi*r**2*dr = 4/3*pi*[(r+dr)**3 - r**3]</span>
    <span class="c1">#</span>
    <span class="c1"># where V(r) the volume of the shell. Normalization to V(r) is necessary</span>
    <span class="c1"># b/c the shell [r, r+dr] has on average more atoms for increasing &quot;r&quot;.</span>
    <span class="c1">#</span>
    <span class="c1"># We sum over N atoms, so we have to divide by N : s(r) / N -- that&#39;s why</span>
    <span class="c1"># g(r) is an average.</span>
    <span class="c1">#</span>
    <span class="c1"># Interpretation (a): Since we further divide by the shell volume V(r), the</span>
    <span class="c1"># average shell atom count s(r) / N becomes the average shell atom density</span>
    <span class="c1"># s(r) / [N * V(r)]. We finally normalize by the ideal gas density N/V to</span>
    <span class="c1"># get a the dimensionless g(r).</span>
    <span class="c1">#</span>
    <span class="c1"># Interpretation (b): The average shell atom count is s(r) / N. It has no</span>
    <span class="c1"># unit. The denominator is then (N/V) * V(r), which is the shell atom count</span>
    <span class="c1"># for a random distribution of density N/V.</span>
    <span class="c1">#</span>
    <span class="c1"># g(r) -&gt; 1 for r -&gt; inf in liquids, i.e. long distances are not</span>
    <span class="c1"># correlated. Their distribution is random. In a crystal, we get an</span>
    <span class="c1"># infinite series of delta peaks at the distances of the 1st, 2nd, ...</span>
    <span class="c1"># nearest neighbor shell.</span>
    <span class="c1">#</span>
    <span class="c1"># The number integral is</span>
    <span class="c1">#</span>
    <span class="c1">#   I(r1,r2) = int(r=r1,r2) N/V*g(r)*4*pi*r**2*dr</span>
    <span class="c1">#            = int(r=r1,r2) N/V*g(r)*V(r)*dr</span>
    <span class="c1">#            = int(r=r1,r2) 1/N*s(r)*dr</span>
    <span class="c1">#</span>
    <span class="c1"># This can be used to calculate coordination numbers, i.e. it counts the</span>
    <span class="c1"># average (that&#39;s why 1/N) number of atoms around an atom in a shell</span>
    <span class="c1"># [r1,r2].</span>
    <span class="c1">#</span>
    <span class="c1"># Integrating to infinity</span>
    <span class="c1">#</span>
    <span class="c1">#   I(0,inf) = N-1</span>
    <span class="c1">#</span>
    <span class="c1"># gives the average number of *all* atoms around an atom, *excluding* the</span>
    <span class="c1"># central one. This integral will converge to N-1 with or without PBC, but</span>
    <span class="c1"># w/o PBC, the nearest neigbor numbers I(r1,r2) will be wrong! Always use</span>
    <span class="c1"># PBC (minimum image convention). Have a look at the following table.</span>
    <span class="c1"># rmax_auto is the rmax value for the given unit cell by the method of</span>
    <span class="c1"># [Smith], which is L/2 for a cubic box of side length L. It is the radius</span>
    <span class="c1"># of the biggest sphere which still fits entirely into the cell. In the</span>
    <span class="c1"># table: &quot;+&quot; = OK, &quot;-&quot; = wrong.</span>
    <span class="c1">#</span>
    <span class="c1">#                                    nearest neighb.     I(0,rmax) = N-1</span>
    <span class="c1"># 1.) pbc=Tue,   rmax &lt;  rmax_auto   +                   -</span>
    <span class="c1"># 2.) pbc=Tue,   rmax &gt;&gt; rmax_auto   + (&lt; rmax_auto)     +</span>
    <span class="c1"># 3.) pbc=False, rmax &lt;  rmax_auto   -                   -</span>
    <span class="c1"># 4.) pbc=False, rmax &gt;&gt; rmax_auto   -                   +</span>
    <span class="c1">#</span>
    <span class="c1"># (1) is the use case in [Smith]. Always use this.</span>
    <span class="c1">#</span>
    <span class="c1"># (2) appears to be also useful. However, it can be shown that nearest</span>
    <span class="c1"># neigbors are correct only up to rmax_auto! See examples/rpdf/rpdf_aln.py.</span>
    <span class="c1"># This is because if rmax &gt; rmax_auto (say &gt; L/2), then the shell is empty</span>
    <span class="c1"># for all r outside of the box, which means that the counted number of</span>
    <span class="c1"># surrounding atoms will be to small.</span>
    <span class="c1">#</span>
    <span class="c1"># For a crystal, integrating over a peak [r-dr/2, r+dr/2] gives *exactly*</span>
    <span class="c1"># the number of nearest neighbor atoms for that distance r b/c the</span>
    <span class="c1"># normalization factor -- the number of atoms in an ideal gas for a narrow</span>
    <span class="c1"># shell of width dr -- is 1.</span>
    <span class="c1">#</span>
    <span class="c1"># 2) 2 selections</span>
    <span class="c1">#</span>
    <span class="c1"># Lets say you have 10 waters -&gt; 10 x O (atom type A), 20 x H (type B),</span>
    <span class="c1"># then let A = 10, B = 20.</span>
    <span class="c1">#</span>
    <span class="c1">#   s(r) = sum(i=1,A) sum(j=1,B) delta(r - r_ij)</span>
    <span class="c1">#        = s_AB(r) + s_BA(r)</span>
    <span class="c1">#</span>
    <span class="c1"># where s_AB(r) is the number of B&#39;s around A&#39;s and vice versa. With the</span>
    <span class="c1"># densities A/V and B/V, we get</span>
    <span class="c1">#</span>
    <span class="c1">#   g(r) = g_AB(r) + g_BA(r) =</span>
    <span class="c1">#          s_AB(r) / [A * (B/V) * V(r)] +</span>
    <span class="c1">#          s_BA(r) / [B * (A/V) * V(r)]</span>
    <span class="c1">#</span>
    <span class="c1"># Note that the density used is always the density of the *sourrounding*</span>
    <span class="c1"># atom type. g_AB(r) or g_BA(r) is the result that you want. Finally, we</span>
    <span class="c1"># can also write g(r) for the all-all case, i.e. 1 atom type.</span>
    <span class="c1">#</span>
    <span class="c1">#  g(r) = [s_AB(r) +  s_BA(r)] / [A*B/V * V(r)]</span>
    <span class="c1">#</span>
    <span class="c1"># Note the similarity to the case of one atom type:</span>
    <span class="c1">#</span>
    <span class="c1">#  g(r) = s(r) / [N**2/V * V(r)]</span>
    <span class="c1">#</span>
    <span class="c1"># The integrals are:</span>
    <span class="c1">#</span>
    <span class="c1">#  I_AB(r1,r2) = int(r=r1,r2) (B/V)*g_AB(r)*4*pi*r**2*dr</span>
    <span class="c1">#                int(r=r1,r2) 1/A*s_AB(r)*dr</span>
    <span class="c1">#  I_BA(r1,r2) = int(r=r1,r2) (A/V)*g_BA(r)*4*pi*r**2*dr</span>
    <span class="c1">#                int(r=r1,r2) 1/B*s_BA(r)*dr</span>
    <span class="c1">#</span>
    <span class="c1"># Note the similarity to the one-atom case:</span>
    <span class="c1">#</span>
    <span class="c1">#  I(r1,r2)    = int(r=r1,r2) 1/N*s(r)*dr</span>
    <span class="c1">#</span>
    <span class="c1"># These integrals converge to the total number of *sourrounding*</span>
    <span class="c1"># atoms of the other type:</span>
    <span class="c1">#</span>
    <span class="c1">#   I_AB(0,inf) = B  (not B-1 !)</span>
    <span class="c1">#   I_BA(0,inf) = A  (not A-1 !)</span>
    <span class="c1">#</span>
    <span class="c1"># Verification</span>
    <span class="c1"># ============</span>
    <span class="c1">#</span>
    <span class="c1"># This function was tested against VMD&#39;s &quot;measure gofr&quot; command. VMD can</span>
    <span class="c1"># only handle orthorhombic boxes. To test non-orthorhombic boxes, see</span>
    <span class="c1"># examples/rpdf/.</span>
    <span class="c1">#</span>
    <span class="c1"># Make sure to convert all length to Angstrom of you compare with VMD.</span>
    <span class="c1">#</span>
    <span class="c1"># Implementation details</span>
    <span class="c1"># ======================</span>
    <span class="c1">#</span>
    <span class="c1"># Number integral mehod</span>
    <span class="c1"># ---------------------</span>
    <span class="c1">#</span>
    <span class="c1"># To match with VMD results, we use the &quot;rectangle rule&quot;, i.e. just y_i*dx.</span>
    <span class="c1"># This is even cheaper than the trapezoidal rule, but by far accurate</span>
    <span class="c1"># enough for small ``dr``. Try yourself by using a more sophisticated</span>
    <span class="c1"># method like</span>
    <span class="c1"># &gt;&gt;&gt; num_int2 = scipy.integrate.cumtrapz(hist, rad)</span>
    <span class="c1"># &gt;&gt;&gt; plot(rad[:-1]+0.5*dr, num_int2)</span>
    <span class="c1">#</span>
    <span class="c1"># distance calculation</span>
    <span class="c1"># --------------------</span>
    <span class="c1"># sij : &quot;matrix&quot; of distance vectors in crystal coords</span>
    <span class="c1"># rij : in cartesian coords, same unit as `cell`, e.g. Angstrom</span>
    <span class="c1">#</span>
    <span class="c1"># sij:        (natoms0, natoms1, 3) # coords 2d</span>
    <span class="c1"># sij: (nstep, natoms0, natoms1, 3) # coords 3d</span>
    <span class="c1">#</span>
    <span class="c1"># broadcasting 2d:</span>
    <span class="c1">#</span>
    <span class="c1">#   coords0:        (natoms0, 1,       3)</span>
    <span class="c1">#   coords1:        (1,       natoms1, 3)</span>
    <span class="c1">#   sij:            (natoms0, natoms1, 3)</span>
    <span class="c1">#   &gt;&gt;&gt; coords0[:,None,:] - coords1[None,:,:]</span>
    <span class="c1">#</span>
    <span class="c1"># broadcasting 3d:</span>
    <span class="c1">#</span>
    <span class="c1">#   coords0: (nstep, natoms0, 1,       3)</span>
    <span class="c1">#   coords1: (nstep, 1,       natoms1, 3)</span>
    <span class="c1">#   sij:     (nstep, natoms0, natoms1, 3)</span>
    <span class="c1">#   &gt;&gt;&gt; coords0[:,:,None,:] - coords1[:,None,:,:]</span>
    <span class="c1">#</span>
    <span class="c1"># If we have arbitrary selections, we cannot use np.tri() to select only</span>
    <span class="c1"># the upper (or lower) triangle of this &quot;matrix&quot; to skip duplicates (zero</span>
    <span class="c1"># distance on the main diagonal). Note that if we used tri(), we&#39;d have to</span>
    <span class="c1"># multiply the histogram by two, b/c now, we always double-count ij and ji</span>
    <span class="c1"># distances, which seems to be correct (compare w/ VMD).</span>
    <span class="c1">#</span>
    <span class="c1"># We can easily create a MemoryError b/c of the temp arrays that numpy</span>
    <span class="c1"># creates. But even w/ numexpr, which avoids big temp arrays, we store the</span>
    <span class="c1"># result sij, which is a 4d array. For natoms=100, nstep=1e5, we already</span>
    <span class="c1"># have a 24 GB array in RAM! The only solution is to code this section</span>
    <span class="c1"># using Fortran/Cython/whatever in loops:</span>
    <span class="c1">#   * distances</span>
    <span class="c1">#   * apply min_image_convention() (optional)</span>
    <span class="c1">#   * sij -&gt; rij transform</span>
    <span class="c1">#   * redcution to distances</span>
    <span class="c1">#</span>
    <span class="c1"># Variable cell</span>
    <span class="c1"># -------------</span>
    <span class="c1"># Currently, we allow only fixed cell data b/c then we can use numpy</span>
    <span class="c1"># broadcasting to convert fractional to cartesian coords. But if we</span>
    <span class="c1"># implement the distance calculation in Fortran, we can easily allow</span>
    <span class="c1"># variable cell b/c then, we explicitely loop over time steps and can</span>
    <span class="c1"># perform the conversion at every step.</span>
    <span class="c1">#</span>
    <span class="c1"># Differences to VMD&#39;s measure gofr</span>
    <span class="c1"># =================================</span>
    <span class="c1">#</span>
    <span class="c1"># duplicates</span>
    <span class="c1"># ----------</span>
    <span class="c1"># In vmd/src/Measure.C, they count the number of identical atoms in both</span>
    <span class="c1"># selections (variable ``duplicates``). These atoms lead to an r=0 peak in</span>
    <span class="c1"># the histogram, which is bogus and must be corrected. VMD subtracts these</span>
    <span class="c1"># number from the first histogram bin, while we simply set it to zero and</span>
    <span class="c1"># don&#39;t count ``duplicates`` at all.</span>
    <span class="c1">#</span>
    <span class="c1"># normalization</span>
    <span class="c1"># -------------</span>
    <span class="c1"># For normalizing g(r) to account for growing shell volumes around the</span>
    <span class="c1"># central atom for increasing r, we use the textbook formulas, which lead</span>
    <span class="c1"># to</span>
    <span class="c1">#</span>
    <span class="c1">#     norm_fac = volume / volume_shells / (natoms0 * natoms1)</span>
    <span class="c1">#</span>
    <span class="c1"># while VMD uses smth similar to</span>
    <span class="c1">#</span>
    <span class="c1">#     norm_fac = volume / volume_shells / (natoms0 * natoms1 - duplicates)</span>
    <span class="c1">#</span>
    <span class="c1"># VMD calculates g(r) using this norm_fac, but the num_int is always</span>
    <span class="c1"># calculated using the textbook result</span>
    <span class="c1">#</span>
    <span class="c1">#   I_AB(r1,r2) = int(r=r1,r2) 1/A*s_AB(r)</span>
    <span class="c1">#</span>
    <span class="c1"># which is what we do, i.e. just integrate the histogram. That means VMD&#39;s</span>
    <span class="c1"># results are inconsistent if duplicates != 0. In that case g(r) is</span>
    <span class="c1"># slightly wrong, but num_int is still correct. This is only the case for</span>
    <span class="c1"># simple all-all correlation (i.e. all atoms are considered the same),</span>
    <span class="c1"># duplicates = natoms0 = natoms1 = the number of zeros on the distance</span>
    <span class="c1"># matrix&#39; main diagonal. Then we have a small difference in g(r), where</span>
    <span class="c1"># VMD&#39;s is always a little higher b/c norm_fac is smaller then it should.</span>
    <span class="c1">#</span>
    <span class="c1"># As a result, VMD&#39;s g(r) -&gt; 1.0 for random points (= ideal gas) and</span>
    <span class="c1"># num_int -&gt; N (would VMD&#39;s g(r) be integrated directly), while our g(r) -&gt;</span>
    <span class="c1"># &lt; 1.0 (e.g. 0.97) and num_int -&gt; N-1.</span>
    <span class="c1">#</span>
    <span class="c1"># rmax</span>
    <span class="c1"># ----</span>
    <span class="c1"># VMD has a unique feature that lets you use a higher rmax. VMD extends the</span>
    <span class="c1"># range of rmax over rmax_auto, up to rmax_vmd=2*sqrt(0.5)*rmax_auto (~</span>
    <span class="c1"># 14.14 for rmax_auto=10) which is just the length of the vector</span>
    <span class="c1"># [rmax_auto, rmax_auto], i.e. the radius of a sphere which touches one</span>
    <span class="c1"># vertice of the box. Then, we have a spherical cap, which partly covers</span>
    <span class="c1"># the smallest box side (remember that VMD can do orthorhombic boxes only).</span>
    <span class="c1"># VMD corrects the volume of the shells for normalization in that case for</span>
    <span class="c1"># rmax_auto &lt; r &lt; rmax_vmd.</span>
    <span class="c1">#</span>
    <span class="c1"># For distinct selections, our g(r) and VMD&#39;s are exactly the same up to</span>
    <span class="c1"># rmax_auto. After that, VMD&#39;s are correct up to rmax_vmd. At that value,</span>
    <span class="c1"># VMD sets g(r) and num_int to 0.0.</span>
    <span class="c1">#</span>
    <span class="c1"># The problem is: Even if g(r) is normalized correctly for rmax_auto &lt; r &lt;</span>
    <span class="c1"># rmax_vmd, the num_int in that region will be wrong b/c the integral</span>
    <span class="c1"># formula must be changed for that region to account for the changed</span>
    <span class="c1"># normalization factor, which VMD doesn&#39;t do, as far as I read the code. If</span>
    <span class="c1"># I&#39;m wrong, send me an email. All in all, VMD&#39;s num_int sould be trusted</span>
    <span class="c1"># up to rmax_auto, just as in our case. The only advantage is a correctly</span>
    <span class="c1"># normalized g(r) for rmax_auto &lt; r &lt; rmax_vmd, which is however of little</span>
    <span class="c1"># use, if the num_int doesn&#39;t match.</span>

    <span class="n">dup_trajs</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">amask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">amask</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">tmask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tmask</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">trajs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">type</span><span class="p">([]):</span>
        <span class="n">trajs</span> <span class="o">=</span> <span class="p">[</span><span class="n">trajs</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">trajs</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="n">dup_trajs</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">amask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">amask</span> <span class="o">*=</span> <span class="mi">2</span>
    <span class="n">trajs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">struct2traj</span><span class="p">,</span> <span class="n">trajs</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">trajs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;len(trajs) != 2&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">amask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;len(amask) != 2&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dup_trajs</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">symbols</span> <span class="o">==</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;symbols differ&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> \
            <span class="p">(</span><span class="s2">&quot;coords do not both have ndim=3&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">nstep</span> <span class="o">==</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">nstep</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;nstep differs&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cell</span> <span class="o">==</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(),</span> <span class="p">(</span><span class="s2">&quot;cells are not the same&quot;</span><span class="p">)</span>
    <span class="c1"># special case: amask is string: &#39;Ca&#39; -&gt; sy==&#39;Ca&#39; bool array</span>
    <span class="n">sy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">amask</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">amask</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
            <span class="n">amask</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span><span class="o">==</span><span class="n">amask</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span>
    <span class="n">clst</span> <span class="o">=</span> <span class="p">[</span><span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">[</span><span class="n">tmask</span><span class="p">,</span><span class="n">amask</span><span class="p">[</span><span class="mi">0</span><span class="p">],:],</span>
            <span class="n">trajs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">[</span><span class="n">tmask</span><span class="p">,</span><span class="n">amask</span><span class="p">[</span><span class="mi">1</span><span class="p">],:]]</span>
    <span class="c1"># Add time axis back if removed after time slice, e.g. if tmask=np.s_[-1]</span>
    <span class="c1"># (only one step). One could also slice ararys and put them thru the</span>
    <span class="c1"># Trajectory() machinery again to assert 3d arrays.</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clst</span><span class="p">)):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clst</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">clst</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">clst</span><span class="p">[</span><span class="n">ii</span><span class="p">][</span><span class="kc">None</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">clst</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
            <span class="k">assert</span> <span class="n">clst</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
    <span class="n">natoms0</span> <span class="o">=</span> <span class="n">clst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">natoms1</span> <span class="o">=</span> <span class="n">clst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># assume fixed cell, 2d</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="n">volume</span> <span class="o">=</span> <span class="n">trajs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">volume</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nstep</span> <span class="o">=</span> <span class="n">clst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rmax_auto</span> <span class="o">=</span> <span class="n">rmax_smith</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rmax</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">rmax</span> <span class="o">=</span> <span class="n">rmax_auto</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rmax</span><span class="o">+</span><span class="n">dr</span><span class="p">,</span> <span class="n">dr</span><span class="p">)</span>
    <span class="n">rad</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dr</span>
    <span class="n">volume_shells</span> <span class="o">=</span> <span class="mf">4.0</span><span class="o">/</span><span class="mf">3.0</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">**</span><span class="mf">3.0</span> <span class="o">-</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mf">3.0</span><span class="p">)</span>
    <span class="n">norm_fac_pre</span> <span class="o">=</span> <span class="n">volume</span> <span class="o">/</span> <span class="n">volume_shells</span>

    <span class="k">if</span> <span class="n">nstep</span> <span class="o">*</span> <span class="n">natoms0</span> <span class="o">*</span> <span class="n">natoms1</span> <span class="o">*</span> <span class="mf">24.0</span> <span class="o">/</span> <span class="mf">1e9</span> <span class="o">&gt;</span> <span class="n">maxmem</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;would use more than maxmem=</span><span class="si">%f</span><span class="s2"> GB of memory, &quot;</span>
                            <span class="s2">&quot;try `tmask` to reduce time steps&quot;</span> <span class="o">%</span><span class="n">maxmem</span><span class="p">)</span>

    <span class="c1"># distances</span>
    <span class="c1"># sij: (nstep, natoms0, natoms1, 3)</span>
    <span class="n">sij</span> <span class="o">=</span> <span class="n">clst</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,:,</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">clst</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="kc">None</span><span class="p">,:,:]</span>
    <span class="k">assert</span> <span class="n">sij</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nstep</span><span class="p">,</span> <span class="n">natoms0</span><span class="p">,</span> <span class="n">natoms1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pbc</span><span class="p">:</span>
        <span class="n">sij</span> <span class="o">=</span> <span class="n">min_image_convention</span><span class="p">(</span><span class="n">sij</span><span class="p">)</span>
    <span class="c1"># sij: (nstep, atoms0 * natoms1, 3)</span>
    <span class="n">sij</span> <span class="o">=</span> <span class="n">sij</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nstep</span><span class="p">,</span> <span class="n">natoms0</span><span class="o">*</span><span class="n">natoms1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="c1"># rij: (nstep, natoms0 * natoms1, 3)</span>
    <span class="n">rij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sij</span><span class="p">,</span> <span class="n">cell</span><span class="p">)</span>
    <span class="c1"># dists_all: (nstep, natoms0 * natoms1)</span>
    <span class="n">dists_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">rij</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">norm_vmd</span><span class="p">:</span>
        <span class="n">msk</span> <span class="o">=</span> <span class="n">dists_all</span> <span class="o">&lt;</span> <span class="mf">1e-15</span>
        <span class="n">dups</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">entry</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">msk</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nstep</span><span class="p">,))</span>

    <span class="c1"># Not needed b/c bins[-1] == rmax, but doesn&#39;t hurt. Plus, test_rpdf.py</span>
    <span class="c1"># would fail b/c old reference data calculated w/ that setting (difference</span>
    <span class="c1"># 1%, only the last point differs).</span>
    <span class="n">dists_all</span><span class="p">[</span><span class="n">dists_all</span> <span class="o">&gt;=</span> <span class="n">rmax</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">if</span> <span class="n">dmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">placeholder</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{d}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">placeholder</span> <span class="ow">in</span> <span class="n">dmask</span><span class="p">:</span>
            <span class="n">_dmask</span> <span class="o">=</span> <span class="n">dmask</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">placeholder</span><span class="p">,</span> <span class="s1">&#39;dists_all&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_dmask</span> <span class="o">=</span> <span class="s1">&#39;dists_all &#39;</span> <span class="o">+</span> <span class="n">dmask</span>
        <span class="n">dists_all</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="nb">eval</span><span class="p">(</span><span class="n">_dmask</span><span class="p">))]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="n">hist_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">number_integral_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># Calculate hists for each time step and average them. This Python loop is</span>
    <span class="c1"># the bottleneck if we have many timesteps.</span>
    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">nstep</span><span class="p">)):</span>
        <span class="c1"># rad_hist == bins</span>
        <span class="n">hist</span><span class="p">,</span> <span class="n">rad_hist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">dists_all</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">hist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">norm_fac</span> <span class="o">=</span> <span class="n">norm_fac_pre</span> <span class="o">/</span> <span class="p">(</span><span class="n">natoms0</span> <span class="o">*</span> <span class="n">natoms1</span> <span class="o">-</span> <span class="n">dups</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">hist_sum</span> <span class="o">+=</span> <span class="n">hist</span> <span class="o">*</span> <span class="n">norm_fac</span>
        <span class="n">number_integral_sum</span> <span class="o">+=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hist</span><span class="p">)</span> <span class="o">/</span> <span class="n">natoms0</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rad</span><span class="p">),</span> <span class="mi">3</span><span class="p">))</span>
    <span class="n">out</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">rad</span>
    <span class="n">out</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">hist_sum</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nstep</span><span class="p">)</span>
    <span class="n">out</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">number_integral_sum</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">nstep</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="call_vmd_measure_gofr">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.call_vmd_measure_gofr.html#pwtools.crys.call_vmd_measure_gofr">[docs]</a>
<span class="k">def</span> <span class="nf">call_vmd_measure_gofr</span><span class="p">(</span><span class="n">trajfn</span><span class="p">,</span> <span class="n">dr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="s1">&#39;all&#39;</span><span class="p">],</span>
                          <span class="n">fntype</span><span class="o">=</span><span class="s1">&#39;xsf&#39;</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">last</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">usepbc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                          <span class="n">datafn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scriptfn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logfn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Call VMD&#39;s &quot;measure gofr&quot; command. This is a simple interface which does</span>
<span class="sd">    in fact the same thing as the gofr GUI, only scriptable. Accepts a file</span>
<span class="sd">    with trajectory data.</span>

<span class="sd">    Only orthogonal boxes are allowed (like in VMD).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    trajfn : filename of trajectory which is fed to VMD (e.g. foo.axsf)</span>
<span class="sd">    dr : float</span>
<span class="sd">        dr in Angstrom</span>
<span class="sd">    rmax : float</span>
<span class="sd">        Max. radius up to which minimum image nearest neighbors are counted.</span>
<span class="sd">        For cubic boxes of side length L, this is L/2 [AT,MD].</span>
<span class="sd">    sel : list of two strings, optional</span>
<span class="sd">        string to select atoms, [&quot;name Ca&quot;, &quot;name O&quot;], [&quot;all&quot;, &quot;all&quot;], ...,</span>
<span class="sd">        where sel[0] is selection 1, sel[1] is selection 2 in VMD</span>
<span class="sd">    fntype : str, optional</span>
<span class="sd">        file type of `fn` for the VMD &quot;mol&quot; command</span>
<span class="sd">    first, last, step : int, optional</span>
<span class="sd">        Select which MD steps are averaged. Like Python, VMD starts counting at</span>
<span class="sd">        0. Last is -1, like in Python.</span>
<span class="sd">    usepbc : int {1,0}, optional</span>
<span class="sd">        Whether to use the minimum image convention.</span>
<span class="sd">    datafn : str, optional</span>
<span class="sd">        temp file where VMD results are written to and loaded</span>
<span class="sd">    scriptfn : str, optional</span>
<span class="sd">        temp file where VMD tcl input script is written to</span>
<span class="sd">    logfn : str, optional</span>
<span class="sd">        file where VMD output is logged</span>
<span class="sd">    tmpdir : str, optional</span>
<span class="sd">        dir where auto-generated tmp files are written</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        display VMD output</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array (len(rad), 3), colums 0,1,2:</span>

<span class="sd">    rad : 1d array</span>
<span class="sd">        radius (x-axis) with spacing `dr`, each value r[i] is the middle of a</span>
<span class="sd">        histogram bin</span>
<span class="sd">    hist : 1d array, (len(rad),)</span>
<span class="sd">        the function values g(r)</span>
<span class="sd">    num_int : 1d array, (len(rad),)</span>
<span class="sd">        the (averaged) number integral ``number_density*hist*4*pi*r**2.0*dr``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vmd_tcl</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    # VMD interface script. Call &quot;measure gofr&quot; and write RPDF to file.</span>
<span class="s2">    # Tested with VMD 1.8.7, 1.9</span>
<span class="s2">    #</span>
<span class="s2">    # Automatically generated by pwtools, XXXTIME</span>
<span class="s2">    #</span>
<span class="s2">    # Format of the output file (columns):</span>
<span class="s2">    #</span>
<span class="s2">    # radius    avg(g(r))    avg(number integral)</span>
<span class="s2">    # [Ang]</span>

<span class="s2">    # Load molecule file with MD trajectory. Typically, foo.axsf with type=xsf</span>
<span class="s2">    mol new XXXTRAJFN type XXXFNTYPE  waitfor all</span>

<span class="s2">    # &quot;top&quot; is the current top molecule (the one labeled with &quot;T&quot; in the GUI).</span>
<span class="s2">    set molid top</span>
<span class="s2">    set selstr1 &quot;XXXSELSTR1&quot;</span>
<span class="s2">    set selstr2 &quot;XXXSELSTR2&quot;</span>
<span class="s2">    set first XXXFIRST</span>
<span class="s2">    set last XXXLAST</span>
<span class="s2">    set step XXXSTEP</span>
<span class="s2">    set delta XXXDR</span>
<span class="s2">    set rmax XXXRMAX</span>
<span class="s2">    set usepbc XXXUSEPBC</span>

<span class="s2">    set sel1 [atomselect $molid &quot;$selstr1&quot;]</span>
<span class="s2">    set sel2 [atomselect $molid &quot;$selstr2&quot;]</span>

<span class="s2">    # $result is a list of 5 lists, we only need the first 3</span>
<span class="s2">    set result [measure gofr $sel1 $sel2 delta $delta rmax $rmax first $first last $last step $step usepbc $usepbc]</span>
<span class="s2">    set rad [lindex $result 0]</span>
<span class="s2">    set hist [lindex $result 1]</span>
<span class="s2">    set num_int [lindex $result 2]</span>

<span class="s2">    # write to file</span>
<span class="s2">    set fp [open &quot;XXXDATAFN&quot; w]</span>
<span class="s2">    foreach r $rad h $hist i $num_int {</span>
<span class="s2">        puts $fp &quot;$r $h $i&quot;</span>
<span class="s2">    }</span>
<span class="s2">    quit</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="c1"># Skip test if cell is orthogonal, VMD will complain anyway if it isn&#39;t</span>
    <span class="k">assert</span> <span class="kc">None</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">dr</span><span class="p">,</span> <span class="n">rmax</span><span class="p">],</span> <span class="s2">&quot;`dr` or `rmax` is None&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">fntype</span> <span class="o">==</span> <span class="s1">&#39;xsf&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;only XSF files supported&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tmpdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tmpdir</span> <span class="o">=</span> <span class="s1">&#39;/tmp&#39;</span>
    <span class="k">if</span> <span class="n">datafn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">datafn</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;vmd_data_&#39;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">scriptfn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scriptfn</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;vmd_script_&#39;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">logfn</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logfn</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;vmd_log_&#39;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dct</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;trajfn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">trajfn</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;fntype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fntype</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;selstr1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;selstr2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sel</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;first&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;last&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;step&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">step</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;dr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dr</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;rmax&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">rmax</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;usepbc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">usepbc</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;datafn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">datafn</span>
    <span class="n">dct</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">asctime</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="n">dct</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">vmd_tcl</span> <span class="o">=</span> <span class="n">vmd_tcl</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;XXX&#39;</span><span class="o">+</span><span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
    <span class="n">common</span><span class="o">.</span><span class="n">file_write</span><span class="p">(</span><span class="n">scriptfn</span><span class="p">,</span> <span class="n">vmd_tcl</span><span class="p">)</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="s2">&quot;vmd -dispdev none -eofexit -e </span><span class="si">%s</span><span class="s2"> &quot;</span> <span class="o">%</span><span class="n">scriptfn</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="s2">&quot;2&gt;&amp;1 | tee </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="n">logfn</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="s2">&quot; &gt; </span><span class="si">%s</span><span class="s2"> 2&gt;&amp;1&quot;</span> <span class="o">%</span><span class="n">logfn</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">backtick</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">out</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">datafn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>



<div class="viewcode-block" id="vmd_measure_gofr">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.vmd_measure_gofr.html#pwtools.crys.vmd_measure_gofr">[docs]</a>
<span class="k">def</span> <span class="nf">vmd_measure_gofr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">dr</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="s1">&#39;all&#39;</span><span class="p">],</span> <span class="n">first</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                     <span class="n">last</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">usepbc</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">slicefirst</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tmpdir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Call call_vmd_measure_gofr(), accept Structure / Trajectory as input.</span>
<span class="sd">    This is intended as a complementary function to rpdf() and should, of</span>
<span class="sd">    course, produce the &quot;same&quot; results.</span>

<span class="sd">    Only orthogonal boxes are allowed (like in VMD).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    traj : Structure or Trajectory</span>
<span class="sd">    dr : float</span>
<span class="sd">        dr in Angstrom</span>
<span class="sd">    rmax : {&#39;auto&#39;, float}, optional</span>
<span class="sd">        Max. radius up to which minimum image nearest neighbors are counted.</span>
<span class="sd">        For cubic boxes of side length L, this is L/2 [AT,MD].</span>

<span class="sd">        | &#39;auto&#39; : the method of [Smith] is used to calculate the max. sphere</span>
<span class="sd">        |          raduis for any cell shape</span>
<span class="sd">        | float : set value yourself</span>
<span class="sd">    sel : list of two strings, optional</span>
<span class="sd">        string to select atoms, [&quot;name Ca&quot;, &quot;name O&quot;], [&quot;all&quot;, &quot;all&quot;], ...,</span>
<span class="sd">        where sel[0] is selection 1, sel[1] is selection 2 in VMD</span>
<span class="sd">    first,last,step : int, optional</span>
<span class="sd">        Select which MD steps are averaged. Like Python, VMD starts counting at</span>
<span class="sd">        zero. Last is -1, like in Python.</span>
<span class="sd">    usepbc : int {1,0}, optional</span>
<span class="sd">        Whether to use the minimum image convention.</span>
<span class="sd">    slicefirst : bool, optional</span>
<span class="sd">        Whether to slice coords here in the wrapper based on first,last,step.</span>
<span class="sd">        This will write a smaller XSF file, which can save time. In the VMD</span>
<span class="sd">        script, we always use first=0,last=-1,step=1 in that case.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        display VMD output</span>
<span class="sd">    tmpdir : str, optional</span>
<span class="sd">        dir where auto-generated tmp files are written</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    array (len(rad), 3), colums 0,1,2:</span>
<span class="sd">    rad : 1d array</span>
<span class="sd">        radius (x-axis) with spacing `dr`, each value r[i] is the middle of a</span>
<span class="sd">        histogram bin</span>
<span class="sd">    hist : 1d array, (len(rad),)</span>
<span class="sd">        the function values g(r)</span>
<span class="sd">    num_int : 1d array, (len(rad),)</span>
<span class="sd">        the (averaged) number integral ``number_density*hist*4*pi*r**2.0*dr``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Need to import here b/c of cyclic dependency crys -&gt; io -&gt; crys ...</span>
    <span class="kn">from</span> <span class="nn">pwtools</span> <span class="kn">import</span> <span class="n">io</span>
    <span class="n">traj</span> <span class="o">=</span> <span class="n">struct2traj</span><span class="p">(</span><span class="n">traj</span><span class="p">)</span>
    <span class="c1"># Speed: The VMD command &quot;measure gofr&quot; is multithreaded and written in C.</span>
    <span class="c1"># That&#39;s why it is faster than the pure Python rpdf() above when we have to</span>
    <span class="c1"># average many timesteps. But the writing of the .axsf file here is</span>
    <span class="c1"># actually the bottleneck and makes this function slower.</span>
    <span class="k">if</span> <span class="n">tmpdir</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">tmpdir</span> <span class="o">=</span> <span class="s1">&#39;/tmp&#39;</span>
    <span class="n">trajfn</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="nb">dir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;vmd_xsf_&#39;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="n">cc</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">cryst_const</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cc</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="o">-</span> <span class="mf">90.0</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;`cell` is not orthogonal, check angles&quot;</span><span class="p">)</span>
    <span class="n">rmax_auto</span> <span class="o">=</span> <span class="n">rmax_smith</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rmax</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
        <span class="n">rmax</span> <span class="o">=</span> <span class="n">rmax_auto</span>
    <span class="c1"># Slice here and write less to xsf file (speed!). Always use first=0,</span>
    <span class="c1"># last=-1, step=1 in vmd script.</span>
    <span class="k">if</span> <span class="n">slicefirst</span><span class="p">:</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">last</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="n">traj2</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">coords_frac</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span><span class="o">...</span><span class="p">],</span>
                           <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
                           <span class="n">symbols</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>
        <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">traj2</span> <span class="o">=</span> <span class="n">traj</span>
    <span class="n">io</span><span class="o">.</span><span class="n">write_axsf</span><span class="p">(</span><span class="n">trajfn</span><span class="p">,</span> <span class="n">traj2</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">call_vmd_measure_gofr</span><span class="p">(</span><span class="n">trajfn</span><span class="p">,</span> <span class="n">dr</span><span class="o">=</span><span class="n">dr</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="n">rmax</span><span class="p">,</span> <span class="n">sel</span><span class="o">=</span><span class="n">sel</span><span class="p">,</span>
                                <span class="n">fntype</span><span class="o">=</span><span class="s1">&#39;xsf&#39;</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="n">first</span><span class="p">,</span>
                                <span class="n">last</span><span class="o">=</span><span class="n">last</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">usepbc</span><span class="o">=</span><span class="n">usepbc</span><span class="p">,</span>
                                <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span><span class="n">tmpdir</span><span class="o">=</span><span class="n">tmpdir</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span></div>



<div class="viewcode-block" id="distances">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.distances.html#pwtools.crys.distances">[docs]</a>
<span class="k">def</span> <span class="nf">distances</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fullout</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for _flib.distsq_frac(). Calculate distances of all atoms in</span>
<span class="sd">    `struct`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    struct : Structure instance</span>
<span class="sd">    pbc : bool, optional</span>
<span class="sd">        Apply PBC wrapping to distances (minimum image distances)</span>
<span class="sd">    squared : bool, optional</span>
<span class="sd">        Return squared distances</span>
<span class="sd">    fullout : bool</span>
<span class="sd">        See below</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dists : if fullout=False</span>
<span class="sd">    dists, distvecs, distvecs_frac : if fullout=True</span>
<span class="sd">    dists : 2d array (natoms, natoms)</span>
<span class="sd">        (Squared, see `squared` arg) distances. Note that ``dists[i,j] ==</span>
<span class="sd">        dists[j,i]``.</span>
<span class="sd">    distvecs : (natoms,natoms,3)</span>
<span class="sd">        Cartesian distance vectors.</span>
<span class="sd">    distvecs_frac : (natoms,natoms,3)</span>
<span class="sd">        Fractional distance vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># numpy version (10x slower):</span>
    <span class="c1">#</span>
    <span class="c1"># cf = struct.coords_frac</span>
    <span class="c1"># cell = struct.cell</span>
    <span class="c1"># distvecs_frac = cf[:,None,:] - cf[None,:,:]</span>
    <span class="c1"># if pbc:</span>
    <span class="c1">#     distvecs_frac = min_image_convention(distvecs_frac)</span>
    <span class="c1"># distvecs = np.dot(distvecs_frac, cell)</span>
    <span class="c1"># distsq = (distvecs**2.0).sum(axis=2)</span>
    <span class="c1"># dists = np.sqrt(distsq)</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">natoms</span>
    <span class="n">distsq</span> <span class="o">=</span> <span class="n">fempty</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span><span class="n">nn</span><span class="p">))</span>
    <span class="n">distvecs</span> <span class="o">=</span> <span class="n">fempty</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span><span class="n">nn</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">distvecs_frac</span> <span class="o">=</span> <span class="n">fempty</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span><span class="n">nn</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">_flib</span><span class="o">.</span><span class="n">distsq_frac</span><span class="p">(</span><span class="n">coords_frac</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">,</span>
                      <span class="n">cell</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span>
                      <span class="n">pbc</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">pbc</span><span class="p">),</span>
                      <span class="n">distsq</span><span class="o">=</span><span class="n">distsq</span><span class="p">,</span>
                      <span class="n">distvecs</span><span class="o">=</span><span class="n">distvecs</span><span class="p">,</span>
                      <span class="n">distvecs_frac</span><span class="o">=</span><span class="n">distvecs_frac</span><span class="p">)</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">distsq</span> <span class="k">if</span> <span class="n">squared</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">distsq</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fullout</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dists</span><span class="p">,</span> <span class="n">distvecs</span><span class="p">,</span> <span class="n">distvecs_frac</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">distvecs</span>
        <span class="k">del</span> <span class="n">distvecs_frac</span>
        <span class="k">return</span> <span class="n">dists</span></div>



<div class="viewcode-block" id="distances_traj">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.distances_traj.html#pwtools.crys.distances_traj">[docs]</a>
<span class="k">def</span> <span class="nf">distances_traj</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cartesian distances along a trajectory.</span>

<span class="sd">    Wrapper for _flib.distances_traj().</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    traj : Trajectory</span>
<span class="sd">    pbc : bool</span>
<span class="sd">        Use minimum image distances.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dists : (nstep, natoms, natoms)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">natoms</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">fempty</span><span class="p">((</span><span class="n">traj</span><span class="o">.</span><span class="n">nstep</span><span class="p">,</span><span class="n">nn</span><span class="p">,</span><span class="n">nn</span><span class="p">))</span>
    <span class="n">_flib</span><span class="o">.</span><span class="n">distances_traj</span><span class="p">(</span><span class="n">coords_frac</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span>
                         <span class="n">cell</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span>
                         <span class="n">pbc</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">pbc</span><span class="p">),</span>
                         <span class="n">dists</span><span class="o">=</span><span class="n">dists</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dists</span></div>



<div class="viewcode-block" id="angles">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.angles.html#pwtools.crys.angles">[docs]</a>
<span class="k">def</span> <span class="nf">angles</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mask_val</span><span class="o">=</span><span class="mf">999.0</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper for _flib.angles(), which accepts a Structure.</span>
<span class="sd">    Calculate all angles between atom triples in `struct`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    struct : Structure instance</span>
<span class="sd">    pbc : bool, optional</span>
<span class="sd">        Apply PBC wrapping to distances (minimum image distances)</span>
<span class="sd">    mask_val : float</span>
<span class="sd">        Fill value for ``anglesijk[ii,jj,kk]`` where ``ii==jj`` or ``ii==kk``</span>
<span class="sd">        or ``jj==kk``, i.e. no angle defined. Can be used to create bool mask</span>
<span class="sd">        arrays in numpy. Should be outside of [-1,1] (``deg=False``) or [0,180]</span>
<span class="sd">        (``deg=True``).</span>
<span class="sd">    deg : bool</span>
<span class="sd">        Return angles in degree (True) or cosine values (False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    anglesijk : 3d array (natoms,natoms,natoms)</span>
<span class="sd">        All angles. See also `mask_val`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; natoms = struct.natoms</span>
<span class="sd">    &gt;&gt;&gt; mask_val = 999</span>
<span class="sd">    &gt;&gt;&gt; anglesijk = crys.angles(struct, mask_val=mask_val)</span>
<span class="sd">    &gt;&gt;&gt; # angleidx holds all ii,jj,kk triples which we would get from:</span>
<span class="sd">    &gt;&gt;&gt; angleidx = []</span>
<span class="sd">    ... for ii in range(natoms):</span>
<span class="sd">    ...     for jj in range(natoms):</span>
<span class="sd">    ...         for kk in range(natoms):</span>
<span class="sd">    ...             if (ii != jj) and (ii != kk) and (jj != kk):</span>
<span class="sd">    ...                 angleidx.append([ii,jj,kk])</span>
<span class="sd">    &gt;&gt;&gt; # which is the same as</span>
<span class="sd">    &gt;&gt;&gt; angleidx2 = [x for x in itertools.permutations(range(natoms),3)]</span>
<span class="sd">    &gt;&gt;&gt; # or</span>
<span class="sd">    &gt;&gt;&gt; angleidx3 = np.array(zip(*(anglesijk != mask_val).nonzero()))</span>
<span class="sd">    &gt;&gt;&gt; # the number of valid angles</span>
<span class="sd">    &gt;&gt;&gt; len(angleidx) == natoms * (natoms - 1) * (natoms - 2)</span>
<span class="sd">    &gt;&gt;&gt; len(angleidx) == factorial(natoms) / factorial(natoms - 3)</span>
<span class="sd">    &gt;&gt;&gt; # angles in 1d array for histogram or whatever</span>
<span class="sd">    &gt;&gt;&gt; angles1d = anglesijk[anglesijk != mask_val]</span>
<span class="sd">    &gt;&gt;&gt; y,x = np.histogram(angles1d, bins=100)</span>
<span class="sd">    &gt;&gt;&gt; plot(x[:-1]+0.5*(x[1]-x[0]), y)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">deg</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">mask_val</span> <span class="o">&lt;=</span> <span class="mi">180</span><span class="p">),</span> <span class="s2">&quot;mask_val must be outside [0,180]&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">mask_val</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;mask_val must be outside [-1,1]&quot;</span>
    <span class="n">nn</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">natoms</span>
    <span class="n">dists</span><span class="p">,</span> <span class="n">distvecs</span><span class="p">,</span> <span class="n">distvecs_frac</span> <span class="o">=</span> <span class="n">distances</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">,</span> <span class="n">squared</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                               <span class="n">fullout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">distvecs_frac</span>
    <span class="n">anglesijk</span> <span class="o">=</span> <span class="n">fempty</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span><span class="n">nn</span><span class="p">,</span><span class="n">nn</span><span class="p">))</span>
    <span class="n">_flib</span><span class="o">.</span><span class="n">angles</span><span class="p">(</span><span class="n">distvecs</span><span class="o">=</span><span class="n">distvecs</span><span class="p">,</span>
                 <span class="n">dists</span><span class="o">=</span><span class="n">dists</span><span class="p">,</span>
                 <span class="n">mask_val</span><span class="o">=</span><span class="n">mask_val</span><span class="p">,</span>
                 <span class="n">deg</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">deg</span><span class="p">),</span>
                 <span class="n">anglesijk</span><span class="o">=</span><span class="n">anglesijk</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">anglesijk</span></div>



<div class="viewcode-block" id="nearest_neighbors_from_dists">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.nearest_neighbors_from_dists.html#pwtools.crys.nearest_neighbors_from_dists">[docs]</a>
<span class="k">def</span> <span class="nf">nearest_neighbors_from_dists</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                 <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                 <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fullout</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Core part of nearest_neighbors(), which accepts pre-calculated</span>
<span class="sd">    distances.</span>

<span class="sd">    Can be more efficient in loops where many different</span>
<span class="sd">    nearest neighbors should be calculated from the same distances.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dists : 2d array (natoms,natoms)</span>
<span class="sd">        Cartesian distances (see distances()).</span>
<span class="sd">    symbols : sequence of strings (natoms,)</span>
<span class="sd">        Atom symbols, i.e. struct.symbols</span>

<span class="sd">    Rest see nearest_neighbors().</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;idx is None&quot;</span>
    <span class="k">assert</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="n">num</span><span class="p">,</span><span class="n">cutoff</span><span class="p">],</span> <span class="s2">&quot;use either num or cutoff&quot;</span>
    <span class="c1"># dists: distance matrix (natoms, natoms), each row or col is sorted like</span>
    <span class="c1"># struct.symbols</span>
    <span class="c1">#</span>
    <span class="c1"># dist from atom `idx` to all atoms, same as dists[idx,:] b/c `dist` is</span>
    <span class="c1"># symmetric</span>
    <span class="n">dist1d</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[:,</span><span class="n">idx</span><span class="p">]</span>
    <span class="c1"># order by distance, `idx` first with dist=0</span>
    <span class="n">idx_lst_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dist1d</span><span class="p">)</span>
    <span class="n">dist1d_sort</span> <span class="o">=</span> <span class="n">dist1d</span><span class="p">[</span><span class="n">idx_lst_sort</span><span class="p">]</span>
    <span class="n">symbols_sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">symbols</span><span class="p">)[</span><span class="n">idx_lst_sort</span><span class="p">]</span>
    <span class="n">skip</span> <span class="o">=</span> <span class="n">common</span><span class="o">.</span><span class="n">asseq</span><span class="p">(</span><span class="n">skip</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">skip</span> <span class="o">!=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]:</span>
        <span class="n">msk</span> <span class="o">=</span> <span class="n">symbols_sort</span> <span class="o">==</span> <span class="n">skip</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">skip</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">msk</span> <span class="o">=</span> <span class="n">msk</span> <span class="o">|</span> <span class="p">(</span><span class="n">symbols_sort</span> <span class="o">==</span> <span class="n">item</span><span class="p">)</span>
        <span class="n">only_msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">invert</span><span class="p">(</span><span class="n">msk</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">only_msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">symbols_sort</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># ``1:`` : central atom excluded</span>
        <span class="n">cut_msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ret_idx</span> <span class="o">=</span> <span class="n">idx_lst_sort</span><span class="p">[</span><span class="n">only_msk</span><span class="p">][</span><span class="n">cut_msk</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cut_msk</span> <span class="o">=</span> <span class="p">(</span><span class="n">dist1d_sort</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dist1d_sort</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">ret_idx</span> <span class="o">=</span> <span class="n">idx_lst_sort</span><span class="p">[</span><span class="n">cut_msk</span> <span class="o">&amp;</span> <span class="n">only_msk</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sort</span><span class="p">:</span>
        <span class="n">orig_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dist1d</span><span class="p">))</span>
        <span class="n">ret_idx</span> <span class="o">=</span> <span class="n">orig_idx</span><span class="p">[</span><span class="n">match_mask</span><span class="p">(</span><span class="n">orig_idx</span><span class="p">,</span><span class="n">ret_idx</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">fullout</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret_idx</span><span class="p">,</span> <span class="n">dist1d</span><span class="p">[</span><span class="n">ret_idx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret_idx</span></div>



<div class="viewcode-block" id="nearest_neighbors">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.nearest_neighbors.html#pwtools.crys.nearest_neighbors">[docs]</a>
<span class="k">def</span> <span class="nf">nearest_neighbors</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fullout</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indices of the nearest neighbor atoms to atom `idx`, skipping atoms</span>
<span class="sd">    whose symbols are `skip`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    struct : Structure</span>
<span class="sd">    idx : int</span>
<span class="sd">        Atom index of the central atom.</span>
<span class="sd">    skip : str or sequence of strings</span>
<span class="sd">        Symbol(s) of the atoms to skip.</span>
<span class="sd">    num : int</span>
<span class="sd">        number of requested nearest neighbors</span>
<span class="sd">    cutoff : float</span>
<span class="sd">        Cutoff radius in unit defined in `struct`, e.g. Angstrom. Return all</span>
<span class="sd">        neighbors within that radius. Use either `num` of `cutoff`.</span>
<span class="sd">    pbc : bool</span>
<span class="sd">        Apply PBC to distances.</span>
<span class="sd">    sort : bool</span>
<span class="sd">        Sort `nn_idx` and `nn_dist` by distance.</span>
<span class="sd">    fullout : bool</span>
<span class="sd">        See below.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nn_idx : fullout=False</span>
<span class="sd">    nn_idx,nn_dist : fullout=True</span>
<span class="sd">    nn_idx : 1d array</span>
<span class="sd">        Indices into struct.symbols / coords.</span>
<span class="sd">    nn_dist : 1d array</span>
<span class="sd">        Distances ordered as in `nn_idx`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    num.match_mask</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `num` : Depending on `struct`, there may not be `num` nearest neighbors,</span>
<span class="sd">    especially if you use `skip` to leave certain species out. Then the</span>
<span class="sd">    number of returned indices may be less then `num`.</span>

<span class="sd">    Ordering : If ``sort=True``, then returnd indices `nn_idx` and distances</span>
<span class="sd">    `nn_dist` are sorted small -&gt; high. If ``sort=False``, then they are in the</span>
<span class="sd">    same order as the symbols in ``struct.symbols``.</span>
<span class="sd">    For structs with high symmetry (i.e. bulk crystals) where many</span>
<span class="sd">    nearest neighbors have the same distance from the central atom, the</span>
<span class="sd">    ordering of depends on how ``numpy.argsort`` sorts equal values in an</span>
<span class="sd">    array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ni=nearest_neighbors(struct, idx=struct.symbols.index(&#39;Ca&#39;), num=6, skip=&#39;H&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ni=nearest_neighbors(struct, idx=23, cutoff=5.3, skip=[&#39;H&#39;,&#39;Cl&#39;])</span>
<span class="sd">    &gt;&gt;&gt; # simple rock salt example (used ASE to build dummy struct)</span>
<span class="sd">    &gt;&gt;&gt; from ase import lattice</span>
<span class="sd">    &gt;&gt;&gt; at=lattice.bulk(&#39;AlN&#39;, a=4, crystalstructure=&#39;rocksalt&#39;)</span>
<span class="sd">    &gt;&gt;&gt; st=crys.atoms2struct(at); st=crys.scell(st,(2,2,2))</span>
<span class="sd">    &gt;&gt;&gt; ni,nd=crys.nearest_neighbors(st, idx=0, num=8, fullout=True)</span>
<span class="sd">    &gt;&gt;&gt; ni</span>
<span class="sd">    array([ 9, 10, 11, 12, 13, 14,  1,  2])</span>
<span class="sd">    &gt;&gt;&gt; nd</span>
<span class="sd">    [ 2. 2. 2. 2. 2. 2. 2.82842712 2.82842712]</span>
<span class="sd">    &gt;&gt;&gt; # Use `ni` or bool array created from that for indexing</span>
<span class="sd">    &gt;&gt;&gt; array(st.symbols)[ni]</span>
<span class="sd">    array([&#39;Al&#39;, &#39;Al&#39;, &#39;N&#39;, &#39;N&#39;, &#39;N&#39;, &#39;N&#39;, &#39;N&#39;, &#39;N&#39;], dtype=&#39;|S2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; msk=num.match_mask(arange(st.natoms), ni)</span>
<span class="sd">    &gt;&gt;&gt; array(st.symbols)[msk]</span>
<span class="sd">    array([&#39;Al&#39;, &#39;Al&#39;, &#39;N&#39;, &#39;N&#39;, &#39;N&#39;, &#39;N&#39;, &#39;N&#39;, &#39;N&#39;], dtype=&#39;|S2&#39;)</span>
<span class="sd">    &gt;&gt;&gt; # If you have many different symbols to skip and you don&#39;t want to type</span>
<span class="sd">    &gt;&gt;&gt; # a longish `skip` list, then use smth like this to include only &#39;O&#39;</span>
<span class="sd">    &gt;&gt;&gt; # for example</span>
<span class="sd">    &gt;&gt;&gt; symbols=[&#39;Ca&#39;, &#39;Cl&#39;, &#39;Cl&#39;] + [&#39;O&#39;]*10 + [&#39;H&#39;]*20</span>
<span class="sd">    &gt;&gt;&gt; skip=filter(lambda x: x!=&#39;O&#39;, set(symbols))</span>
<span class="sd">    &gt;&gt;&gt; [&#39;H&#39;, &#39;Ca&#39;, &#39;Cl&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Distance matrix (natoms, natoms). Each row or col is sorted like</span>
    <span class="c1"># struct.symbols. If used in loops over trajs, the distances() call is the</span>
    <span class="c1"># most costly part, even though coded in Fortran.</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">distances</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">pbc</span><span class="o">=</span><span class="n">pbc</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nearest_neighbors_from_dists</span><span class="p">(</span><span class="n">dists</span><span class="o">=</span><span class="n">dists</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
                                        <span class="n">skip</span><span class="o">=</span><span class="n">skip</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">num</span><span class="p">,</span>
                                        <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">,</span> <span class="n">fullout</span><span class="o">=</span><span class="n">fullout</span><span class="p">)</span></div>



<div class="viewcode-block" id="nearest_neighbors_struct">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.nearest_neighbors_struct.html#pwtools.crys.nearest_neighbors_struct">[docs]</a>
<span class="k">def</span> <span class="nf">nearest_neighbors_struct</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return Structure with only nearest neighbors.</span>

<span class="sd">    Calls ``nearest_neighbors()`` and takes the same arguments. The returned</span>
<span class="sd">    Structure contains the central atom set by the `idx` keyword to</span>
<span class="sd">    nearest_neighbors().</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from pwtools import crys, visualize</span>
<span class="sd">    &gt;&gt;&gt; st = crys.nearest_neighbors_struct(struct, cutoff=3.3, skip=&#39;H&#39;)</span>
<span class="sd">    &gt;&gt;&gt; visualize.view_avogadro(st)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ni</span> <span class="o">=</span> <span class="n">nearest_neighbors</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="c1"># include `idx` atom</span>
    <span class="n">ni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ni</span><span class="p">,</span> <span class="p">[</span><span class="n">kwds</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]]))</span>
    <span class="n">msk</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">match_mask</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">natoms</span><span class="p">),</span> <span class="n">ni</span><span class="p">)</span>
    <span class="n">new_struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">coords_frac</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">[</span><span class="n">msk</span><span class="p">,:],</span>
                           <span class="n">cell</span><span class="o">=</span><span class="n">struct</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span>
                           <span class="n">symbols</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">symbols</span><span class="p">)[</span><span class="n">msk</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">new_struct</span></div>



<div class="viewcode-block" id="center_on_atom">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.center_on_atom.html#pwtools.crys.center_on_atom">[docs]</a>
<span class="k">def</span> <span class="nf">center_on_atom</span><span class="p">(</span><span class="n">obj_in</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Shift all coords in `obj` such that the atom with index `idx` is at the</span>
<span class="sd">    center of the cell: [0.5,0.5,0.5] fractional coords.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;provide atom index&quot;</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">obj_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">obj_in</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># [...,idx,:] works for (natoms,3) and (nstep,natoms,3) -- numpy rocks!</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">coords_frac</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords_frac</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">idx</span><span class="p">,:][</span><span class="o">...</span><span class="p">,</span><span class="kc">None</span><span class="p">,:]</span> <span class="o">+</span> <span class="mf">0.5</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">set_all</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">obj</span></div>



<span class="c1">#-----------------------------------------------------------------------------</span>
<span class="c1"># Container classes for crystal structures and trajectories.</span>
<span class="c1">#-----------------------------------------------------------------------------</span>

<div class="viewcode-block" id="UnitsHandler">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.UnitsHandler.html#pwtools.crys.UnitsHandler">[docs]</a>
<span class="k">class</span> <span class="nc">UnitsHandler</span><span class="p">(</span><span class="n">FlexibleGetters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for :class:`Structure`, providing unit conversion methods.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="UnitsHandler.__init__">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.UnitsHandler.html#pwtools.crys.UnitsHandler.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># XXX cryst_const is not in &#39;length&#39; and needs to be treated specially,</span>
        <span class="c1"># see _apply_units_raw()</span>

        <span class="c1"># map physical quantity to variable names in Structure/Trajectory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units_map</span> <span class="o">=</span> \
            <span class="p">{</span><span class="s1">&#39;length&#39;</span><span class="p">:</span>      <span class="p">[</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;coords&#39;</span><span class="p">,</span> <span class="s1">&#39;abc&#39;</span><span class="p">],</span>
             <span class="s1">&#39;energy&#39;</span><span class="p">:</span>      <span class="p">[</span><span class="s1">&#39;etot&#39;</span><span class="p">,</span> <span class="s1">&#39;ekin&#39;</span><span class="p">],</span>
             <span class="s1">&#39;stress&#39;</span><span class="p">:</span>      <span class="p">[</span><span class="s1">&#39;stress&#39;</span><span class="p">],</span>
             <span class="s1">&#39;forces&#39;</span><span class="p">:</span>      <span class="p">[</span><span class="s1">&#39;forces&#39;</span><span class="p">],</span>
             <span class="s1">&#39;temperature&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;temperature&#39;</span><span class="p">],</span>
             <span class="s1">&#39;velocity&#39;</span><span class="p">:</span>    <span class="p">[</span><span class="s1">&#39;velocity&#39;</span><span class="p">],</span>
             <span class="s1">&#39;time&#39;</span><span class="p">:</span>        <span class="p">[</span><span class="s1">&#39;timestep&#39;</span><span class="p">],</span>
             <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_default_units</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">units_map</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units_applied</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Init all unit factors in self.units to 1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_units</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_apply_units_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Only used by derived classes. Apply unit factors to all attrs in</span>
<span class="sd">        self.units_map.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">units_applied</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;_apply_units_raw() already called&quot;</span><span class="p">)</span>
        <span class="c1"># XXX special-case cryst_const for trajectory case here (ndim = 2), it</span>
        <span class="c1"># would be better to split cryst_const into self.abc and self.angles or</span>
        <span class="c1"># so, but that would break too much code, BUT we could just add</span>
        <span class="c1"># backward compat get_cryst_const, which concatenates these ...</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;cryst_const&#39;</span><span class="p">):</span>
            <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cryst_const</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">cc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cc</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">cc</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cc</span><span class="p">[:,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;self.cryst_const has ndim != [1,2]&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cryst_const</span> <span class="o">=</span> <span class="n">cc</span>
        <span class="k">for</span> <span class="n">unit</span><span class="p">,</span> <span class="n">lst</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">units_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">unit</span><span class="p">]</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="n">attr_name</span><span class="p">):</span>
                        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span>  <span class="n">attr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="p">[</span><span class="n">unit</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units_applied</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="UnitsHandler.apply_units">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.UnitsHandler.apply_units.html#pwtools.crys.UnitsHandler.apply_units">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Like _apply_units_raw(), make sure that units are only applied once.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">units_applied</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_apply_units_raw</span><span class="p">()</span></div>


<div class="viewcode-block" id="UnitsHandler.update_units">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.UnitsHandler.update_units.html#pwtools.crys.UnitsHandler.update_units">[docs]</a>
    <span class="k">def</span> <span class="nf">update_units</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">units</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update self.units dict from `units`. All units not contained in</span>
<span class="sd">        `units` remain at the default (1.0), see self._default_units.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        units : dict, {&#39;length&#39;: 5, &#39;energy&#39;: 30, ...}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_units</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">units_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">units</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">all_units</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unknown unit: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">units</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">units</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Structure">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.html#pwtools.crys.Structure">[docs]</a>
<span class="k">class</span> <span class="nc">Structure</span><span class="p">(</span><span class="n">UnitsHandler</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Container class for representing a single crystal structure (unit</span>
<span class="sd">    cell + atoms).</span>

<span class="sd">    Derived classes may add attributes and getters but the idea is that this</span>
<span class="sd">    class is the minimal API for how to pass an atomic structure around.</span>

<span class="sd">    Units are supposed to be similar to ASE:</span>

<span class="sd">    =========== ==============  ===============================</span>
<span class="sd">    what        unit            SI</span>
<span class="sd">    =========== ==============  ===============================</span>
<span class="sd">    length      Angstrom        (1e-10 m)</span>
<span class="sd">    energy      eV              (1.602176487e-19 J)</span>
<span class="sd">    forces      eV / Angstrom</span>
<span class="sd">    stress      GPa             (not eV/Angstrom**3)</span>
<span class="sd">    temperature K</span>
<span class="sd">    velocity    Angstrom / fs</span>
<span class="sd">    time        fs              (1e-15 s)</span>
<span class="sd">    mass        amu             (1.6605387820000001e-27 kg)</span>
<span class="sd">    =========== ==============  ===============================</span>

<span class="sd">    Unit conversion factors, which are applied to input arguments for</span>
<span class="sd">    conversion to the above units can be given by the `units` input keyword.</span>

<span class="sd">    Note that we cannot verify the unit of input args to the constructor, but</span>
<span class="sd">    all functions in this package, which use Structure / Trajectory as</span>
<span class="sd">    container classes, assume these units.</span>

<span class="sd">    This class is very much like ase.Atoms, but without the &quot;calculators&quot;.</span>
<span class="sd">    You can use :meth:`get_ase_atoms` to get an Atoms object or</span>
<span class="sd">    :meth:`get_fake_ase_atoms` for a minimal Atoms-like object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; symbols=[&#39;N&#39;, &#39;Al&#39;, &#39;Al&#39;, &#39;Al&#39;, &#39;N&#39;, &#39;N&#39;, &#39;Al&#39;]</span>
<span class="sd">    &gt;&gt;&gt; coords_frac=rand(len(symbols),3)</span>
<span class="sd">    &gt;&gt;&gt; cryst_const=np.array([5,5,5,90,90,90.0])</span>
<span class="sd">    &gt;&gt;&gt; st=Structure(coords_frac=coords_frac,</span>
<span class="sd">    ...              cryst_const=cryst_const,</span>
<span class="sd">    ...              symbols=symbols)</span>
<span class="sd">    &gt;&gt;&gt; st.symbols</span>
<span class="sd">    [&#39;N&#39;, &#39;Al&#39;, &#39;Al&#39;, &#39;Al&#39;, &#39;N&#39;, &#39;N&#39;, &#39;Al&#39;]</span>
<span class="sd">    &gt;&gt;&gt; st.symbols_unique</span>
<span class="sd">    [&#39;Al&#39;, &#39;N&#39;]</span>
<span class="sd">    &gt;&gt;&gt; st.order</span>
<span class="sd">    {&#39;Al&#39;: 1, &#39;N&#39;: 2}</span>
<span class="sd">    &gt;&gt;&gt; st.typat</span>
<span class="sd">    [2, 1, 1, 1, 2, 2, 1]</span>
<span class="sd">    &gt;&gt;&gt; st.znucl_unique</span>
<span class="sd">    [13, 7]</span>
<span class="sd">    &gt;&gt;&gt; st.nspecies</span>
<span class="sd">    {&#39;Al&#39;: 4, &#39;N&#39;: 3}</span>
<span class="sd">    &gt;&gt;&gt; st.coords</span>
<span class="sd">    array([[ 1.1016541 ,  4.52833103,  0.57668453],</span>
<span class="sd">           [ 0.18088339,  3.41219704,  4.93127985],</span>
<span class="sd">           [ 2.98639824,  2.87207221,  2.36208784],</span>
<span class="sd">           [ 2.89717342,  4.21088541,  3.13154023],</span>
<span class="sd">           [ 2.28147351,  2.39398397,  1.49245281],</span>
<span class="sd">           [ 3.16196033,  3.72534409,  3.24555934],</span>
<span class="sd">           [ 4.90318748,  2.02974457,  2.49846847]])</span>
<span class="sd">    &gt;&gt;&gt; st.coords_frac</span>
<span class="sd">    array([[ 0.22033082,  0.90566621,  0.11533691],</span>
<span class="sd">           [ 0.03617668,  0.68243941,  0.98625597],</span>
<span class="sd">           [ 0.59727965,  0.57441444,  0.47241757],</span>
<span class="sd">           [ 0.57943468,  0.84217708,  0.62630805],</span>
<span class="sd">           [ 0.4562947 ,  0.47879679,  0.29849056],</span>
<span class="sd">           [ 0.63239207,  0.74506882,  0.64911187],</span>
<span class="sd">           [ 0.9806375 ,  0.40594891,  0.49969369]])</span>
<span class="sd">    &gt;&gt;&gt; st.cryst_const</span>
<span class="sd">    array([  5.,   5.,   5.,  90.,  90.,  90.])</span>
<span class="sd">    &gt;&gt;&gt; st.cell</span>
<span class="sd">    array([[  5.00000000e+00,   0.00000000e+00,   0.00000000e+00],</span>
<span class="sd">           [  3.06161700e-16,   5.00000000e+00,   0.00000000e+00],</span>
<span class="sd">           [  3.06161700e-16,   3.06161700e-16,   5.00000000e+00]])</span>
<span class="sd">    &gt;&gt;&gt; st.get_ase_atoms(pbc=True)</span>
<span class="sd">    Atoms(symbols=&#39;NAl3N2Al&#39;, positions=..., cell=[[2.64588604295, 0.0, 0.0],</span>
<span class="sd">    [1.6201379367036871e-16, 2.64588604295, 0.0], [1.6201379367036871e-16,</span>
<span class="sd">    1.6201379367036871e-16, 2.64588604295]], pbc=[True, True, True])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># attrs_nstep arrays have shape (nstep,...), i.e time along `timeaxis`</span>
    <span class="n">timeaxis</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">is_traj</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_struct</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="Structure.__init__">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.html#pwtools.crys.Structure.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set_all_auto</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coords : (natoms, 3) [Ang]</span>
<span class="sd">            Cartesian coords.</span>
<span class="sd">            Optional if `coords_frac` given.</span>
<span class="sd">        coords_frac : (natoms, 3)</span>
<span class="sd">            Fractional coords w.r.t. `cell`.</span>
<span class="sd">            Optional if `coords` given.</span>
<span class="sd">        symbols : sequence of strings (natoms,)</span>
<span class="sd">            atom symbols</span>
<span class="sd">        cell : (3,3)</span>
<span class="sd">            Unit cell vectors as rows. [Ang]</span>
<span class="sd">            Optional if `cryst_const` given.</span>
<span class="sd">        cryst_const : (6,)</span>
<span class="sd">            [a,b,c,alpha,beta,gamma]; a,b,c in [Ang]</span>
<span class="sd">            Optional if `cell` given.</span>
<span class="sd">        forces : (natoms, 3), optional</span>
<span class="sd">            [eV/Ang]</span>
<span class="sd">        stress : (3,3), optional</span>
<span class="sd">            stress tensor [GPa]</span>
<span class="sd">        etot : float, optional</span>
<span class="sd">            total energy [eV]</span>
<span class="sd">        units : optional, dict,</span>
<span class="sd">            see :class:`UnitsHandler`</span>
<span class="sd">        set_all_auto : optional, bool</span>
<span class="sd">            Call :meth:`set_all` in :meth:`__init__`.</span>

<span class="sd">        Only Trajectory</span>

<span class="sd">        ekin : (nstep,)</span>
<span class="sd">            [eV]</span>
<span class="sd">        forces : (nstep,natoms,3)</span>
<span class="sd">            [eV/Ang]</span>
<span class="sd">        pressure : (nstep,)</span>
<span class="sd">            [GPa]</span>
<span class="sd">        stress : (nstep,3,3)</span>
<span class="sd">            [GPa]</span>
<span class="sd">        temperature : (nstep,)</span>
<span class="sd">            [K]</span>
<span class="sd">        timestep : float</span>
<span class="sd">            [fs]</span>
<span class="sd">        velocity : (nstep, natoms, 3)</span>
<span class="sd">            [Ang/fs]</span>
<span class="sd">        volume : (nstep,)</span>
<span class="sd">            [Ang^3]</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        cell, cryst_const : Provide either `cell` or `cryst_const`, or both</span>
<span class="sd">            (which is redundant). If only one is given, the other is calculated</span>
<span class="sd">            from it. See {cell2cc,cc2cell}.</span>
<span class="sd">        coords, coords_frac : Provide either `coords` or `coords_frac`, or both</span>
<span class="sd">            (which is redundant). If only one is given, the other is calculated</span>
<span class="sd">            from it. See coord_trans().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># accepted by input, some derived if not given</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_attr_lst</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;cell&#39;</span><span class="p">,</span>
            <span class="s1">&#39;coords&#39;</span><span class="p">,</span>
            <span class="s1">&#39;coords_frac&#39;</span><span class="p">,</span>
            <span class="s1">&#39;cryst_const&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ekin&#39;</span><span class="p">,</span>
            <span class="s1">&#39;etot&#39;</span><span class="p">,</span>
            <span class="s1">&#39;forces&#39;</span><span class="p">,</span>
            <span class="s1">&#39;pressure&#39;</span><span class="p">,</span>
            <span class="s1">&#39;stress&#39;</span><span class="p">,</span>
            <span class="s1">&#39;symbols&#39;</span><span class="p">,</span>
            <span class="s1">&#39;temperature&#39;</span><span class="p">,</span>
            <span class="s1">&#39;timestep&#39;</span><span class="p">,</span>
            <span class="s1">&#39;velocity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;volume&#39;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="c1"># not as input, only derived from input attrs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">derived_attr_lst</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;mass&#39;</span><span class="p">,</span>
            <span class="s1">&#39;mass_unique&#39;</span><span class="p">,</span>
            <span class="s1">&#39;natoms&#39;</span><span class="p">,</span>
            <span class="s1">&#39;nspecies&#39;</span><span class="p">,</span>
            <span class="s1">&#39;nstep&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ntypat&#39;</span><span class="p">,</span>
            <span class="s1">&#39;order&#39;</span><span class="p">,</span>
            <span class="s1">&#39;symbols_unique&#39;</span><span class="p">,</span>
            <span class="s1">&#39;typat&#39;</span><span class="p">,</span>
            <span class="s1">&#39;time&#39;</span><span class="p">,</span>
            <span class="s1">&#39;znucl&#39;</span><span class="p">,</span>
            <span class="s1">&#39;znucl_unique&#39;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="c1"># If these are given as input args, then they must be 3d.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_3d</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;coords&#39;</span><span class="p">,</span>
            <span class="s1">&#39;coords_frac&#39;</span><span class="p">,</span>
            <span class="s1">&#39;stress&#39;</span><span class="p">,</span>
            <span class="s1">&#39;forces&#39;</span><span class="p">,</span>
            <span class="s1">&#39;velocity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;cell&#39;</span><span class="p">,</span>         <span class="c1"># can be 2d, see _extend()</span>
            <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_2d</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;cryst_const&#39;</span><span class="p">,</span>  <span class="c1"># can be 1d, see _extend()</span>
            <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_1d</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;pressure&#39;</span><span class="p">,</span>
            <span class="s1">&#39;volume&#39;</span><span class="p">,</span>
            <span class="s1">&#39;etot&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ekin&#39;</span><span class="p">,</span>
            <span class="s1">&#39;temperature&#39;</span><span class="p">,</span>
            <span class="s1">&#39;time&#39;</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs_only_traj</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s1">&#39;nstep&#39;</span><span class="p">,</span>
            <span class="s1">&#39;timestep&#39;</span><span class="p">,</span>
            <span class="s1">&#39;time&#39;</span><span class="p">,</span>
            <span class="s1">&#39;ekin&#39;</span><span class="p">,</span>
            <span class="s1">&#39;velocity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;temperature&#39;</span><span class="p">,</span>
            <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_3d</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_2d</span> <span class="o">+</span> \
                           <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_1d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_2d_3d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_3d</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_2d</span>

        <span class="c1"># init all in self.attr_lst to None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr_lst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_attr_lst</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">derived_attr_lst</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_attr_lst</span><span class="p">()</span>

        <span class="c1"># hackish but virtually no overhead here: create Structure by deleting</span>
        <span class="c1"># stuff in attributes lists</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_only_traj</span><span class="p">:</span>
                <span class="c1"># while: for some reason list.remove() doesn&#39;t always work</span>
                <span class="k">while</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_lst</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">attr_lst</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr_lst</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">))</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Structure</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">np_array_t</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># for iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># initialize the self.units dictionary with unit conversion factors,</span>
        <span class="c1"># used in self.apply_units()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_units</span><span class="p">(</span><span class="n">units</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_all_auto</span> <span class="o">=</span> <span class="n">set_all_auto</span>

        <span class="c1"># assign input args, overwrite default None</span>
        <span class="c1">#   self.foo = foo</span>
        <span class="c1">#   self.bar = bar</span>
        <span class="c1">#   ...</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">kwds</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_attr_lst</span><span class="p">,</span> \
                <span class="s2">&quot;illegal input arg: &#39;</span><span class="si">%s</span><span class="s2">&#39;, allowed: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_attr_lst</span><span class="p">))</span>
            <span class="c1"># cell can be 2d and will be treated by _extend() later</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_traj</span> <span class="ow">and</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_3d</span><span class="p">)</span> <span class="ow">and</span> \
               <span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;cell&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">kwds</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;input &#39;</span><span class="si">%s</span><span class="s2">&#39; is not 3d&quot;</span> <span class="o">%</span><span class="n">name</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kwds</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>

        <span class="c1"># calculate all missing attrs if requested, their units are based on</span>
        <span class="c1"># the ones set above</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_all_auto</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_all</span><span class="p">()</span></div>


<div class="viewcode-block" id="Structure.set_all">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.set_all.html#pwtools.crys.Structure.set_all">[docs]</a>
    <span class="k">def</span> <span class="nf">set_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extend arrays, apply units, call all getters.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extend_arrays_apply_units</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Structure</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">set_all</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_extend_arrays_apply_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_units</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extend</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_extend</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;nstep&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;cryst_const&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cryst_const</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_cc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cryst_const</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extend_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">nstep</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">nstep</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assert_set_attr</span><span class="p">(</span><span class="s1">&#39;nstep&#39;</span><span class="p">)</span>
            <span class="n">nstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstep</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">.</span><span class="n">extend_array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">nstep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_extend_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cell</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cell</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cell</span>
        <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_array</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_array</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cell</span>

    <span class="k">def</span> <span class="nf">_extend_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cc</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">cc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cc</span>
        <span class="k">if</span> <span class="n">cc</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">6</span><span class="p">,):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_array</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">cc</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_array</span><span class="p">(</span><span class="n">cc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cc</span>

<div class="viewcode-block" id="Structure.compress">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.compress.html#pwtools.crys.Structure.compress">[docs]</a>
    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forget</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;forces&#39;</span><span class="p">,</span> <span class="s1">&#39;stress&#39;</span><span class="p">,</span>
                               <span class="s1">&#39;coords&#39;</span><span class="p">,</span><span class="s1">&#39;cryst_const&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compress Trajectory by deleting unused or redundant attrs (see</span>
<span class="sd">        `forget`). Cast float arrays to `dtype`. float32 is usually quite OK</span>
<span class="sd">        for MD data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        forget : list</span>
<span class="sd">            Names of attributes to delete. They will be set to None.</span>
<span class="sd">        dtype : numpy dtype</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">forget</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_array_t</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="n">attr</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span></div>


<div class="viewcode-block" id="Structure.copy">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.copy.html#pwtools.crys.Structure.copy">[docs]</a>
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of the inctance.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">set_all_auto</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">set_all_auto</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># Copy attrs over</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_lst</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># dict.copy() is shallow, use deepcopy instead</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;copy&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">obj</span></div>


<div class="viewcode-block" id="Structure.get_velocity">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_velocity.html#pwtools.crys.Structure.get_velocity">[docs]</a>
    <span class="k">def</span> <span class="nf">get_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate `velocity` from `coords` and `timestep` if</span>
<span class="sd">        `velocity=None`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Trajectory&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;velocity&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">([</span><span class="s1">&#39;coords&#39;</span><span class="p">,</span> <span class="s1">&#39;timestep&#39;</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">velocity_traj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timestep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">endpoints</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span></div>


<div class="viewcode-block" id="Structure.get_ekin">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_ekin.html#pwtools.crys.Structure.get_ekin">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ekin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; ekin [eV] &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Trajectory&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;ekin&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">([</span><span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="s1">&#39;velocity&#39;</span><span class="p">]):</span>
                <span class="c1"># velocity [Ang/fs], mass [amu]</span>
                <span class="n">vv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">velocity</span>
                <span class="n">mm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mass</span>
                <span class="n">amu</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">amu</span>  <span class="c1"># kg</span>
                <span class="n">fs</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">fs</span>
                <span class="n">eV</span> <span class="o">=</span> <span class="n">constants</span><span class="o">.</span><span class="n">eV</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">return</span> <span class="p">((</span><span class="n">vv</span><span class="o">**</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">mm</span><span class="p">[</span><span class="kc">None</span><span class="p">,:]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">Angstrom</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">amu</span> <span class="o">/</span> <span class="n">eV</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ekin</span></div>


<div class="viewcode-block" id="Structure.get_temperature">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_temperature.html#pwtools.crys.Structure.get_temperature">[docs]</a>
    <span class="k">def</span> <span class="nf">get_temperature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; [K] &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Trajectory&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;temperature&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">([</span><span class="s1">&#39;ekin&#39;</span><span class="p">,</span> <span class="s1">&#39;natoms&#39;</span><span class="p">]):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ekin</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">eV</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">natoms</span> <span class="o">/</span> <span class="n">constants</span><span class="o">.</span><span class="n">kb</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="mf">3.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span></div>


<div class="viewcode-block" id="Structure.get_natoms">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_natoms.html#pwtools.crys.Structure.get_natoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_natoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;symbols&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords_frac&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_coords">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_coords.html#pwtools.crys.Structure.get_coords">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords_frac&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords_frac&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">([</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;natoms&#39;</span><span class="p">]):</span>
                    <span class="n">nstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">]</span>
                    <span class="n">req_shape_coords_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">nstep</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">req_shape_coords_frac</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;shape &quot;</span>
                        <span class="s2">&quot;mismatch: coords_frac: </span><span class="si">%s</span><span class="s2">, need: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">req_shape_coords_frac</span><span class="p">)))</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nstep</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;shape mismatch: &quot;</span>
                        <span class="s2">&quot;cell: </span><span class="si">%s</span><span class="s2">, coords_frac: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">_flib</span><span class="o">.</span><span class="n">frac2cart_traj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span></div>


<div class="viewcode-block" id="Structure.get_coords_frac">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_coords_frac.html#pwtools.crys.Structure.get_coords_frac">[docs]</a>
    <span class="k">def</span> <span class="nf">get_coords_frac</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords_frac&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">_flib</span><span class="o">.</span><span class="n">cart2frac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords_frac&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">([</span><span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;natoms&#39;</span><span class="p">]):</span>
                    <span class="n">nstep</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">]</span>
                    <span class="n">req_shape_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">nstep</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">natoms</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">req_shape_coords</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;shape &quot;</span>
                        <span class="s2">&quot;mismatch: coords: </span><span class="si">%s</span><span class="s2">, need: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">req_shape_coords</span><span class="p">)))</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nstep</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;shape mismatch: &quot;</span>
                        <span class="s2">&quot;cell: </span><span class="si">%s</span><span class="s2">, coords: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="k">return</span> <span class="n">_flib</span><span class="o">.</span><span class="n">cart2frac_traj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span></div>


<div class="viewcode-block" id="Structure.get_volume">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_volume.html#pwtools.crys.Structure.get_volume">[docs]</a>
    <span class="k">def</span> <span class="nf">get_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;volume&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">volume_cell3d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">volume_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">volume</span></div>


<div class="viewcode-block" id="Structure.get_cell">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_cell.html#pwtools.crys.Structure.get_cell">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;cryst_const&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
                    <span class="n">cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_cc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cryst_const</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">cc2cell3d</span><span class="p">(</span><span class="n">cc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">cc2cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cryst_const</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span></div>


<div class="viewcode-block" id="Structure.get_cryst_const">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_cryst_const.html#pwtools.crys.Structure.get_cryst_const">[docs]</a>
    <span class="k">def</span> <span class="nf">get_cryst_const</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;cryst_const&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;cell&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
                    <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extend_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">cell2cc3d</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">cell2cc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cryst_const</span></div>


<div class="viewcode-block" id="Structure.get_pressure">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_pressure.html#pwtools.crys.Structure.get_pressure">[docs]</a>
    <span class="k">def</span> <span class="nf">get_pressure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;pressure&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;stress&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span> <span class="o">==</span> <span class="mi">0</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stress</span><span class="p">,</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stress</span><span class="p">)</span><span class="o">/</span><span class="mf">3.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span></div>


<div class="viewcode-block" id="Structure.get_time">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_time.html#pwtools.crys.Structure.get_time">[docs]</a>
    <span class="k">def</span> <span class="nf">get_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Trajectory&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">([</span><span class="s1">&#39;timestep&#39;</span><span class="p">,</span> <span class="s1">&#39;nstep&#39;</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstep</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">timestep</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstep</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_timestep">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_timestep.html#pwtools.crys.Structure.get_timestep">[docs]</a>
    <span class="k">def</span> <span class="nf">get_timestep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Trajectory&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestep</span></div>


<div class="viewcode-block" id="Structure.get_nstep">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_nstep.html#pwtools.crys.Structure.get_nstep">[docs]</a>
    <span class="k">def</span> <span class="nf">get_nstep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_struct</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Trajectory&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;coords_frac&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_symbols">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_symbols.html#pwtools.crys.Structure.get_symbols">[docs]</a>
    <span class="k">def</span> <span class="nf">get_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of atomic symbols.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span></div>


<div class="viewcode-block" id="Structure.get_forces">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_forces.html#pwtools.crys.Structure.get_forces">[docs]</a>
    <span class="k">def</span> <span class="nf">get_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span></div>


<div class="viewcode-block" id="Structure.get_stress">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_stress.html#pwtools.crys.Structure.get_stress">[docs]</a>
    <span class="k">def</span> <span class="nf">get_stress</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Stress tensor&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stress</span></div>


<div class="viewcode-block" id="Structure.get_etot">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_etot.html#pwtools.crys.Structure.get_etot">[docs]</a>
    <span class="k">def</span> <span class="nf">get_etot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total anergy.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">etot</span></div>


<div class="viewcode-block" id="Structure.get_symbols_unique">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_symbols_unique.html#pwtools.crys.Structure.get_symbols_unique">[docs]</a>
    <span class="k">def</span> <span class="nf">get_symbols_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of unique atom symbols.</span>

<span class="sd">        ``[Al,N]`` if ``symbols=[&#39;Al&#39;]*10 + [&#39;N&#39;]*10``.</span>
<span class="sd">        ``len(self.symbols_unique)`` = number of atomic species&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="k">if</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;symbols&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_order">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_order.html#pwtools.crys.Structure.get_order">[docs]</a>
    <span class="k">def</span> <span class="nf">get_order</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dict which maps ``symbols_unique`` to numbers, starting at 1.</span>

<span class="sd">        ``{&#39;Al&#39;: 1, &#39;N&#39;:2, &#39;O&#39;: 3, &#39;Si&#39;: 4}`` for ``symbols=[&#39;Al&#39;]*5 + [&#39;N&#39;]*5</span>
<span class="sd">        + [&#39;O&#39;]*10 + [&#39;Si&#39;]*20``.</span>
<span class="sd">        Can be used in mapping a atom &quot;type&quot; number to a symbol (e.g. in</span>
<span class="sd">        LAMMPS).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;symbols_unique&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">sym</span><span class="p">,</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">num</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span>
                         <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols_unique</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_typat">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_typat.html#pwtools.crys.Structure.get_typat">[docs]</a>
    <span class="k">def</span> <span class="nf">get_typat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of atom type integers in ``self.order``, same length as</span>
<span class="sd">        `symbols`.</span>

<span class="sd">        ``[1]*10 + [2]*10`` for ````symbols=[&#39;Al&#39;]*10 + [&#39;N&#39;]*10``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">([</span><span class="s1">&#39;symbols&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">[</span><span class="n">ss</span><span class="p">]</span> <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_znucl_unique">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_znucl_unique.html#pwtools.crys.Structure.get_znucl_unique">[docs]</a>
    <span class="k">def</span> <span class="nf">get_znucl_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unique atomic numbers.</span>

<span class="sd">        ``[13,7]`` for ``symbols = [&#39;Al&#39;,&#39;Al&#39;,&#39;N&#39;,N&#39;]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;symbols_unique&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">atomic_data</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols_unique</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_znucl">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_znucl.html#pwtools.crys.Structure.get_znucl">[docs]</a>
    <span class="k">def</span> <span class="nf">get_znucl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;All atomic numbers.</span>

<span class="sd">        ``[13,13,7,7]`` for ``symbols = [&#39;Al&#39;,&#39;Al&#39;,&#39;N&#39;,N&#39;]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;symbols&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">atomic_data</span><span class="o">.</span><span class="n">numbers</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_ntypat">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_ntypat.html#pwtools.crys.Structure.get_ntypat">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ntypat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of atomic species.</span>

<span class="sd">        2 for ``symbols=[&#39;Al&#39;,&#39;Al&#39;,&#39;N&#39;,N&#39;]``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;symbols_unique&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols_unique</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_nspecies">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_nspecies.html#pwtools.crys.Structure.get_nspecies">[docs]</a>
    <span class="k">def</span> <span class="nf">get_nspecies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dict with number of atoms per species.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">([</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;typat&#39;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">sym</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">typat</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="k">for</span> <span class="n">sym</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_mass">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_mass.html#pwtools.crys.Structure.get_mass">[docs]</a>
    <span class="k">def</span> <span class="nf">get_mass</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;1D array of atomic masses in amu (atomic mass unit 1.660538782e-27</span>
<span class="sd">        kg as in periodic table). The order is the one from self.symbols.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;symbols&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atomic_data</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="n">sym</span><span class="p">][</span><span class="s1">&#39;mass&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_mass_unique">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_mass_unique.html#pwtools.crys.Structure.get_mass_unique">[docs]</a>
    <span class="k">def</span> <span class="nf">get_mass_unique</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr</span><span class="p">(</span><span class="s1">&#39;znucl_unique&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">atomic_data</span><span class="o">.</span><span class="n">masses</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">znucl_unique</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_ase_atoms">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_ase_atoms.html#pwtools.crys.Structure.get_ase_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ase_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return ASE Atoms object.</span>

<span class="sd">        Obviously, you must have ASE installed. We use</span>
<span class="sd">        ``scaled_positions=self.coords_frac``, so only ``self.cell`` must be in</span>
<span class="sd">        [Ang].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwds :</span>
<span class="sd">            additional keywords passed to the Atoms() constructor.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`get_fake_ase_atoms`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By default, we use ``Atoms(...,pbc=False)`` to avoid pbc-wrapping</span>
<span class="sd">        ``atoms.scaled_positions`` (we don&#39;t want that for MD structures, for</span>
<span class="sd">        instance). If you need the pbc flag in your Atoms object, then use::</span>

<span class="sd">        &gt;&gt;&gt; # Note that the `pbc` flag is passed to ase.Atoms, so you can use</span>
<span class="sd">        &gt;&gt;&gt; # whatever that accepts, like pbc=[1,1,1] etc.</span>
<span class="sd">        &gt;&gt;&gt; atoms=struct.get_ase_atoms(pbc=True)</span>
<span class="sd">        &gt;&gt;&gt; # or</span>
<span class="sd">        &gt;&gt;&gt; atoms=struct.get_ase_atoms()</span>
<span class="sd">        &gt;&gt;&gt; atoms.set_pbc(True)</span>

<span class="sd">        but then, ``scaled_positions`` will be wrapped by ASE and I&#39;m not sure</span>
<span class="sd">        if ``atoms.positions`` is updated in that case. Please test that -- I</span>
<span class="sd">        don&#39;t use ASE much.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">req</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;coords_frac&#39;</span><span class="p">,</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span> <span class="s1">&#39;symbols&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_set_attr_lst</span><span class="p">(</span><span class="n">req</span><span class="p">):</span>
            <span class="c1"># We don&#39;t wanna make ase a dependency. Import only when needed.</span>
            <span class="kn">from</span> <span class="nn">ase</span> <span class="kn">import</span> <span class="n">Atoms</span>
            <span class="n">_kwds</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pbc&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>
            <span class="n">_kwds</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwds</span><span class="p">)</span>
            <span class="n">at</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span>
                       <span class="n">scaled_positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">,</span>
                       <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">_kwds</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">at</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Structure.get_fake_ase_atoms">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_fake_ase_atoms.html#pwtools.crys.Structure.get_fake_ase_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_fake_ase_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;:class:`FakeASEAtoms` instance representing this Structure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FakeASEAtoms</span><span class="p">(</span><span class="n">scaled_positions</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_coords_frac</span><span class="p">(),</span>
                            <span class="n">cell</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_cell</span><span class="p">(),</span>
                            <span class="n">symbols</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_symbols</span><span class="p">())</span></div>


<div class="viewcode-block" id="Structure.get_traj">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_traj.html#pwtools.crys.Structure.get_traj">[docs]</a>
    <span class="k">def</span> <span class="nf">get_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nstep</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a Trajectory object, where this Structure is copied `nstep`</span>
<span class="sd">        times.&quot;&quot;&quot;</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">set_all_auto</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_lst</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_attr</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">tr</span><span class="o">.</span><span class="n">attrs_nstep</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_array_t</span><span class="p">:</span>
                    <span class="n">new_attr</span> <span class="o">=</span> <span class="n">num</span><span class="o">.</span><span class="n">extend_array</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">nstep</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">attr</span><span class="p">]</span><span class="o">*</span><span class="n">nstep</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_attr</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">new_attr</span><span class="p">)</span>
        <span class="c1"># re-calculate nstep</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">nstep</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">tr</span><span class="o">.</span><span class="n">set_all</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tr</span></div>


<div class="viewcode-block" id="Structure.get_spglib">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Structure.get_spglib.html#pwtools.crys.Structure.get_spglib">[docs]</a>
    <span class="k">def</span> <span class="nf">get_spglib</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return spglib input tuple (cell, coords_frac, znucl).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords_frac</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">znucl</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="Trajectory">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Trajectory.html#pwtools.crys.Trajectory">[docs]</a>
<span class="k">class</span> <span class="nc">Trajectory</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Like :class:`Structure`, but all attrs in `attrs_nstep` have a timeaxis</span>
<span class="sd">    along axis=0 and length `nstep`:</span>

<span class="sd">    ===========     ============    ================</span>
<span class="sd">    attribute       Structure       Trajectory</span>
<span class="sd">    ===========     ============    ================</span>
<span class="sd">    coords          (nstoms,3)      (nstep,natoms,3)</span>
<span class="sd">    coords_frac     (nstoms,3)      (nstep,natoms,3)</span>
<span class="sd">    forces          (nstoms,3)      (nstep,natoms,3)</span>
<span class="sd">    velocity        --              (nstep,natoms,3)</span>
<span class="sd">    cryst_const     (6,)            (nstep,6)</span>
<span class="sd">    cell            (3,3)           (nstep,3,3)</span>
<span class="sd">    stress          (3,3)           (nstep,3,3)</span>
<span class="sd">    etot            scalar          (nstep,)</span>
<span class="sd">    volume          scalar          (nstep,)</span>
<span class="sd">    pressure        scalar          (nstep,)</span>
<span class="sd">    ekin            --              (nstep,)</span>
<span class="sd">    temperature     --              (nstep,)</span>
<span class="sd">    time            --              (nstep,)</span>
<span class="sd">    ===========     ============    ================</span>

<span class="sd">    Also, we have additional attrs which are only defined for</span>
<span class="sd">    :class:`Trajectory`, see `attrs_only_traj`:</span>

<span class="sd">    | nstep</span>
<span class="sd">    | timestep</span>
<span class="sd">    | time</span>
<span class="sd">    | ekin</span>
<span class="sd">    | velocity</span>
<span class="sd">    | temperature</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_traj</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_struct</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Trajectory.__init__">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Trajectory.html#pwtools.crys.Trajectory.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Trajectory</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

<div class="viewcode-block" id="Trajectory.__getitem__">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Trajectory.__getitem__.html#pwtools.crys.Trajectory.__getitem__">[docs]</a>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">want_traj</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">set_all_auto</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">timestep_fac</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span> <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">1.0</span>
            <span class="n">want_traj</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">set_all_auto</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">timestep_fac</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr_lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">want_traj</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_only_traj</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep</span><span class="p">:</span>
                    <span class="c1"># the timeaxis check may be a problem for parsed MD data</span>
                    <span class="c1"># where some arrays are 1 or two steps longer/shorter than</span>
                    <span class="c1"># coords (from which we get nstep), for example lammps:</span>
                    <span class="c1"># temperature, volume, etc can be longer if multiple runs</span>
                    <span class="c1"># are done from the same input file and the parser</span>
                    <span class="c1"># currently doesn&#39;t handle that</span>
                    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_2d_3d</span> \
                        <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstep</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span><span class="o">...</span><span class="p">])</span>
                    <span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attrs_nstep_1d</span> \
                        <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstep</span><span class="p">:</span>
                        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># After possible slicing, calculate new nstep</span>
        <span class="k">if</span> <span class="n">want_traj</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">nstep</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_nstep</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_set_attr</span><span class="p">(</span><span class="s1">&#39;timestep&#39;</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">timestep</span> <span class="o">*=</span> <span class="n">timestep_fac</span>
        <span class="k">return</span> <span class="n">obj</span></div>


    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">nstep</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">]</span>

<div class="viewcode-block" id="Trajectory.get_ase_atoms">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Trajectory.get_ase_atoms.html#pwtools.crys.Trajectory.get_ase_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_ase_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Structure&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trajectory.get_fake_ase_atoms">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Trajectory.get_fake_ase_atoms.html#pwtools.crys.Trajectory.get_fake_ase_atoms">[docs]</a>
    <span class="k">def</span> <span class="nf">get_fake_ase_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Structure&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trajectory.get_traj">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Trajectory.get_traj.html#pwtools.crys.Trajectory.get_traj">[docs]</a>
    <span class="k">def</span> <span class="nf">get_traj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Structure&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Trajectory.get_spglib">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.Trajectory.get_spglib.html#pwtools.crys.Trajectory.get_spglib">[docs]</a>
    <span class="k">def</span> <span class="nf">get_spglib</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;only in Structure&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="compress">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.compress.html#pwtools.crys.compress">[docs]</a>
<span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Wrapper for :meth:`Trajectory.compress`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Return compressed copy or in-place modified object.</span>
<span class="sd">    **kwds : keywords</span>
<span class="sd">        keywords to :meth:`Trajectory.compress`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; trc = compress(tr, copy=True, forget=[&#39;coords&#39;])</span>
<span class="sd">    &gt;&gt;&gt; trc.dump(&#39;very_small_file.pk&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">traj</span>
    <span class="n">out</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="atoms2struct">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.atoms2struct.html#pwtools.crys.atoms2struct">[docs]</a>
<span class="k">def</span> <span class="nf">atoms2struct</span><span class="p">(</span><span class="n">at</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform ASE Atoms object to Structure.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Structure</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">at</span><span class="o">.</span><span class="n">get_chemical_symbols</span><span class="p">(),</span>
                     <span class="n">cell</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">at</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()),</span>
                     <span class="n">coords_frac</span><span class="o">=</span><span class="n">at</span><span class="o">.</span><span class="n">get_scaled_positions</span><span class="p">())</span></div>



<div class="viewcode-block" id="struct2atoms">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.struct2atoms.html#pwtools.crys.struct2atoms">[docs]</a>
<span class="k">def</span> <span class="nf">struct2atoms</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform Structure to ASE Atoms object.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">st</span><span class="o">.</span><span class="n">get_ase_atoms</span><span class="p">(</span><span class="o">**</span><span class="n">kwds</span><span class="p">)</span></div>



<div class="viewcode-block" id="struct2traj">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.struct2traj.html#pwtools.crys.struct2traj">[docs]</a>
<span class="k">def</span> <span class="nf">struct2traj</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Transform Structure to Trajectory with nstep=1.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">get_traj</span><span class="p">(</span><span class="n">nstep</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="FakeASEAtoms">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.FakeASEAtoms.html#pwtools.crys.FakeASEAtoms">[docs]</a>
<span class="k">class</span> <span class="nc">FakeASEAtoms</span><span class="p">(</span><span class="n">Structure</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mimic the basic behavior of ``ase.Atoms``.</span>

<span class="sd">    Used to be used as input for ``spglib`` in symmetry.py, but not anymore as</span>
<span class="sd">    of spglib 1.9.x. Now, we use :meth:`Structure.get_spglib`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="FakeASEAtoms.__init__">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.FakeASEAtoms.html#pwtools.crys.FakeASEAtoms.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scaled_positions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FakeASEAtoms</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">coords_frac</span><span class="o">=</span><span class="n">scaled_positions</span><span class="p">,</span>
                                           <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span>
                                           <span class="n">symbols</span><span class="o">=</span><span class="n">symbols</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_scaled_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coords_frac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_number_of_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_natoms</span></div>


<div class="viewcode-block" id="FakeASEAtoms.get_magnetic_moments">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.FakeASEAtoms.get_magnetic_moments.html#pwtools.crys.FakeASEAtoms.get_magnetic_moments">[docs]</a>
    <span class="k">def</span> <span class="nf">get_magnetic_moments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="FakeASEAtoms.get_atomic_numbers">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.FakeASEAtoms.get_atomic_numbers.html#pwtools.crys.FakeASEAtoms.get_atomic_numbers">[docs]</a>
    <span class="k">def</span> <span class="nf">get_atomic_numbers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_znucl</span><span class="p">())</span></div>
</div>



<div class="viewcode-block" id="populated_attrs">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.populated_attrs.html#pwtools.crys.populated_attrs">[docs]</a>
<span class="k">def</span> <span class="nf">populated_attrs</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set with attr names which are not None in all objects in `lst`.&quot;&quot;&quot;</span>
    <span class="n">attr_lists</span> <span class="o">=</span> <span class="p">[[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">attr_lst</span> \
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">name</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">attr_lists</span><span class="p">))</span></div>



<div class="viewcode-block" id="concatenate">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.concatenate.html#pwtools.crys.concatenate">[docs]</a>
<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Concatenate Structure or Trajectory objects into one Trajectory.</span>

<span class="sd">    For non-nstep attrs (symbols,...), the first item is used and no check is</span>
<span class="sd">    made whether they are the same in the others.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lst : sequence of Structure or Trajectory instances or both</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tr : Trajectory</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trlst</span> <span class="o">=</span> <span class="p">[</span><span class="n">struct2traj</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">]</span>
    <span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">set_all_auto</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">com_attrs</span> <span class="o">=</span> <span class="n">populated_attrs</span><span class="p">(</span><span class="n">trlst</span><span class="p">)</span>
    <span class="n">attr_lst</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">com_attrs</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">attrs_nstep</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">attr_lst</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">trlst</span><span class="p">),</span>
                              <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
    <span class="n">attrs_traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">attrs_nstep</span> <span class="o">+</span> <span class="n">traj</span><span class="o">.</span><span class="n">attrs_only_traj</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">set</span><span class="o">.</span><span class="n">symmetric_difference</span><span class="p">(</span><span class="n">com_attrs</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">attrs_traj</span><span class="p">)):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">trlst</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">))</span>
    <span class="n">traj</span><span class="o">.</span><span class="n">timestep</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">traj</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">traj</span><span class="o">.</span><span class="n">nstep</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_nstep</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">traj</span></div>



<div class="viewcode-block" id="mean">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.mean.html#pwtools.crys.mean">[docs]</a>
<span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="n">traj</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mean of Trajectory along `timeaxis`, like numpy.mean(array,axis=0).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    traj : Trajectory</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Structure :</span>
<span class="sd">        instance with extra velocity, temperature, ekin attrs which can hold</span>
<span class="sd">        the mean of the input `traj`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; #  a slice of the Trajectory</span>
<span class="sd">    &gt;&gt;&gt; st = mean(tr[200:500])</span>
<span class="sd">    &gt;&gt;&gt; # Say we know that coords_frac is pbc-wrpapped for some reason but</span>
<span class="sd">    &gt;&gt;&gt; # coords is not. Make sure that we average only coords and force a</span>
<span class="sd">    &gt;&gt;&gt; # recalculation of coords_frac by setting it to None and calling</span>
<span class="sd">    &gt;&gt;&gt; # set_all() at the end.</span>
<span class="sd">    &gt;&gt;&gt; tr.coords_frac = None</span>
<span class="sd">    &gt;&gt;&gt; st = mean(tr)</span>
<span class="sd">    &gt;&gt;&gt; st.set_all()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">traj</span><span class="o">.</span><span class="n">is_traj</span>
    <span class="n">struct</span> <span class="o">=</span> <span class="n">Structure</span><span class="p">(</span><span class="n">set_all_auto</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># add some non-Structure attrs like velocity,ekin,temperature</span>
    <span class="n">attrs_only_traj</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;timestep&#39;</span><span class="p">,</span> <span class="s1">&#39;nstep&#39;</span><span class="p">]</span>
    <span class="n">extra</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">attrs_only_traj</span><span class="p">),</span>
                                <span class="nb">set</span><span class="p">(</span><span class="n">attrs_only_traj</span><span class="p">)))</span>
    <span class="n">struct</span><span class="o">.</span><span class="n">attr_lst</span> <span class="o">+=</span> <span class="n">extra</span>
    <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="nb">set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">attrs_nstep</span><span class="p">),</span>
                                    <span class="nb">set</span><span class="p">(</span><span class="n">attrs_only_traj</span><span class="p">)):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">))</span>
    <span class="n">attrs_traj</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">attrs_nstep</span> <span class="o">+</span> <span class="n">attrs_only_traj</span>
    <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="nb">set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">attr_lst</span><span class="p">),</span>
                                    <span class="nb">set</span><span class="p">(</span><span class="n">attrs_traj</span><span class="p">)):</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">struct</span></div>



<div class="viewcode-block" id="smooth">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.smooth.html#pwtools.crys.smooth">[docs]</a>
<span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">kern</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Smooth Trajectory along `timeaxis`.</span>

<span class="sd">    Each array in `traj.attrs_nstep` is smoothed by convolution with `kern`</span>
<span class="sd">    along `timeaxis`, i.e. coords, coords_frac, etot, ... The kernel is only</span>
<span class="sd">    required to be a 1d array and is automatically broadcast to the shape of</span>
<span class="sd">    each array. A similar feature can be found in VMD -&gt; Representations -&gt;</span>
<span class="sd">    Trajectory.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    traj : Trajectory</span>
<span class="sd">    kern : 1d array</span>
<span class="sd">        Convolution kernel (smoothing window, see :func:`~pwtools.signal.smooth`).</span>
<span class="sd">    method : int</span>
<span class="sd">        Choose how to do the convolution:</span>

<span class="sd">            | 1 : loops over 1d convolutions, easy on memory, sometimes faster</span>
<span class="sd">                  than method=2 (default)</span>
<span class="sd">            | 2 : up to 3d kernel by broadcasting, can be very memory hungry for</span>
<span class="sd">                  big `traj` (i.e. 1e5 timesteps, 128 atoms)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tr : Trajectory</span>
<span class="sd">        Has the same `nstep` and `timestep` as the input Trajectory.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; kern = scipy.signal.hann(101)</span>
<span class="sd">    &gt;&gt;&gt; trs = smooth(tr, kern)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">traj</span><span class="o">.</span><span class="n">is_traj</span>
    <span class="k">assert</span> <span class="n">kern</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;need 1d kernel&quot;</span>
    <span class="k">if</span> <span class="n">traj</span><span class="o">.</span><span class="n">timeaxis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">kern1d</span> <span class="o">=</span> <span class="n">kern</span>
        <span class="n">kern2d</span> <span class="o">=</span> <span class="n">kern</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span>
        <span class="n">kern3d</span> <span class="o">=</span> <span class="n">kern</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ... but is trivial to add</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;timeaxis != 0 not implemented&quot;</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">set_all_auto</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="n">traj</span><span class="o">.</span><span class="n">attrs_nstep</span><span class="p">:</span>
        <span class="n">attr</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Remove that if we want to generalize to timeaxis != 0 and</span>
                <span class="c1"># adapt code below.</span>
                <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="n">traj</span><span class="o">.</span><span class="n">timeaxis</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">kern</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">tmp</span><span class="p">[:,</span><span class="n">jj</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">attr</span><span class="p">[:,</span><span class="n">jj</span><span class="p">],</span> <span class="n">kern</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                            <span class="n">tmp</span><span class="p">[:,</span><span class="n">jj</span><span class="p">,</span><span class="n">kk</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">attr</span><span class="p">[:,</span><span class="n">jj</span><span class="p">,</span><span class="n">kk</span><span class="p">],</span> <span class="n">kern</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ndim != 1,2,3 not allowed&quot;</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">attr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">krn</span> <span class="o">=</span> <span class="n">kern1d</span>
                <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">krn</span> <span class="o">=</span> <span class="n">kern2d</span>
                <span class="k">elif</span> <span class="n">attr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">krn</span> <span class="o">=</span> <span class="n">kern3d</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ndim != 1,2,3 not allowed&quot;</span><span class="p">)</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">krn</span><span class="p">,</span>
                                                      <span class="n">axis</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">timeaxis</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;unknown method&quot;</span><span class="p">)</span>
    <span class="c1"># nstep and timestep are the same for the smoothed traj, so we can copy all</span>
    <span class="c1"># non-nstep attrs over</span>
    <span class="k">for</span> <span class="n">attr_name</span> <span class="ow">in</span> <span class="nb">set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">attr_lst</span><span class="p">),</span>
                                    <span class="nb">set</span><span class="p">(</span><span class="n">traj</span><span class="o">.</span><span class="n">attrs_nstep</span><span class="p">)):</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">traj</span><span class="p">,</span> <span class="n">attr_name</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="mix">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.mix.html#pwtools.crys.mix">[docs]</a>
<span class="k">def</span> <span class="nf">mix</span><span class="p">(</span><span class="n">st1</span><span class="p">,</span> <span class="n">st2</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Linear interpolation between two Structures based on the numbers in</span>
<span class="sd">    `alpha`. Returns a :class:`Trajectory`.</span>

<span class="sd">    Mix two structures as (1-alpha)*st1 + alpha*st2. `coords` and `cell` are</span>
<span class="sd">    used, as well as `forces` if present.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    st1, st2 : Structures</span>
<span class="sd">    alpha : 1d sequence</span>
<span class="sd">        parameter values for mixing</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tr : Trajectory</span>
<span class="sd">        tr.nstep == len(alpha)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mix(st1, st2, linspace(0,1,50))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">st1</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">st1</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span>
    <span class="k">assert</span> <span class="n">st1</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">st2</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">st1</span><span class="o">.</span><span class="n">symbols</span> <span class="o">==</span> <span class="n">st2</span><span class="o">.</span><span class="n">symbols</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">st1</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">st1</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
    <span class="n">rr</span> <span class="o">=</span> <span class="n">alpha</span><span class="p">[:,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">rr</span> <span class="o">*</span> <span class="n">st2</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="kc">None</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rr</span><span class="p">)</span> <span class="o">*</span> <span class="n">st1</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="kc">None</span><span class="p">,:,:]</span>
    <span class="n">cell</span> <span class="o">=</span> <span class="n">rr</span> <span class="o">*</span> <span class="n">st2</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="kc">None</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rr</span><span class="p">)</span> <span class="o">*</span> <span class="n">st1</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="kc">None</span><span class="p">,:,:]</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">st1</span><span class="o">.</span><span class="n">forces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">st2</span><span class="o">.</span><span class="n">forces</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">forces</span> <span class="o">=</span> <span class="n">rr</span> <span class="o">*</span> <span class="n">st2</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="kc">None</span><span class="p">,:,:]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">rr</span><span class="p">)</span> <span class="o">*</span> <span class="n">st1</span><span class="o">.</span><span class="n">forces</span><span class="p">[</span><span class="kc">None</span><span class="p">,:,:]</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="n">st1</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span>
                          <span class="n">forces</span><span class="o">=</span><span class="n">forces</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># cannot use forces=None here, Structure.__init__ complains that it</span>
        <span class="c1"># is None ... this is by design but seems stupid -&gt; change input</span>
        <span class="c1"># checking logic there</span>
        <span class="k">return</span> <span class="n">Trajectory</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="n">cell</span><span class="p">,</span> <span class="n">symbols</span><span class="o">=</span><span class="n">st1</span><span class="o">.</span><span class="n">symbols</span><span class="p">)</span></div>



<div class="viewcode-block" id="align_cart">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.align_cart.html#pwtools.crys.align_cart">[docs]</a>
<span class="k">def</span> <span class="nf">align_cart</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vecs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cart</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">eps</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Align obj w.r.t. a new cartesian coord sys defined by x,y and</span>
<span class="sd">    z=cross(x,y).</span>

<span class="sd">    The new coord sys can be defined either by `x` + `y` or `vecs` or</span>
<span class="sd">    `indices` or `cart`. Vectors need not be normalized.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : Structure or Trajectory</span>
<span class="sd">    x, y : (3,)</span>
<span class="sd">        The two vectors spanning the x-y plane.</span>
<span class="sd">    vecs : (3,3)</span>
<span class="sd">        Array with 3 vectors as rows `[v0, v1, v2]` and ``x = v1 - v0``,</span>
<span class="sd">        ``y = v2 - v0``</span>
<span class="sd">    indices : sequence (4,) or (3,)</span>
<span class="sd">        Indices of atoms in `obj` with positions `v0,v1,v2`. Length 4 for</span>
<span class="sd">        obj=Trajectory: ``indices=[time_step, idx0, idx1, idx2]`` and length 3</span>
<span class="sd">        for obj=Structure: ``[idx0, idx1, idx2]`` with</span>

<span class="sd">        | ``v0 = obj.coords[time_step, idx0, ...]`` (Trajectory)</span>
<span class="sd">        | ``v1 = obj.coords[time_step, idx1, ...]``</span>
<span class="sd">        | ``v2 = obj.coords[time_step, idx2, ...]``</span>

<span class="sd">        or</span>

<span class="sd">        | ``v0 = obj.coords[idx0, ...]`` (Structure)</span>
<span class="sd">        | ``v1 = obj.coords[idx1, ...]``</span>
<span class="sd">        | ``v2 = obj.coords[idx2, ...]``</span>

<span class="sd">    cart : (3,3)</span>
<span class="sd">        new cartesian coord sys ``[x,y,z]``, matrix must be orthogonal</span>
<span class="sd">    eps : float</span>
<span class="sd">        Threshold for orthogonality check. Use `eps &lt;= 0` to disable the check.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : Structure or Trajectory</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    In case of a :class:`Trajectory`, the same rotation is applied to all</span>
<span class="sd">    structs, so the *relative* orientation within the Trajectory is not</span>
<span class="sd">    changed. That is OK if each struct shall be rotated in the same way.</span>
<span class="sd">    If however each struct has a different orientation, then you need</span>
<span class="sd">    to loop over the Trajectory like::</span>

<span class="sd">    &gt;&gt;&gt; from pwtools.crys import align_cart, concatenate</span>
<span class="sd">    &gt;&gt;&gt; trnew = concatenate([align_cart(st, cart=...) for st in tr])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cart</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">v0</span> <span class="o">=</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
                <span class="n">v1</span> <span class="o">=</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">1</span><span class="p">,:]</span>
                <span class="n">v2</span> <span class="o">=</span> <span class="n">vecs</span><span class="p">[</span><span class="mi">2</span><span class="p">,:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="n">v0</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">v0</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
                    <span class="n">v1</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
                    <span class="n">v2</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">-</span> <span class="n">v0</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v0</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">/</span> <span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">)])</span>
    <span class="k">if</span> <span class="n">eps</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">cart</span><span class="p">),</span> <span class="n">cart</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">eps</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">is_traj</span><span class="p">:</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">Trajectory</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">Structure</span>
    <span class="n">obj_new</span> <span class="o">=</span> <span class="n">container</span><span class="p">(</span><span class="n">coords_frac</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">coords_frac</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                        <span class="n">symbols</span><span class="o">=</span><span class="n">obj</span><span class="o">.</span><span class="n">symbols</span><span class="p">,</span>
                        <span class="n">cell</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">cart</span><span class="o">.</span><span class="n">T</span><span class="p">),</span>
                        <span class="p">)</span>
    <span class="k">return</span> <span class="n">obj_new</span></div>



<div class="viewcode-block" id="tensor2voigt">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.tensor2voigt.html#pwtools.crys.tensor2voigt">[docs]</a>
<span class="k">def</span> <span class="nf">tensor2voigt</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert stress tensor to Voigt notation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : (3,3)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    voigt: 1d array</span>
<span class="sd">        [xx,yy,zz,yz,xz,xy]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;tensor must be (3,3)&quot;</span>
    <span class="n">voigt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">voigt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">voigt</span></div>



<div class="viewcode-block" id="voigt2tensor">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.voigt2tensor.html#pwtools.crys.voigt2tensor">[docs]</a>
<span class="k">def</span> <span class="nf">voigt2tensor</span><span class="p">(</span><span class="n">voigt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert Voigt stress array to stress tensor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    voigt: 1d array</span>
<span class="sd">        [xx,yy,zz,yz,xz,xy]</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor : (3,3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">voigt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;voigt must be length 6 vector&quot;</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tensor</span></div>



<div class="viewcode-block" id="voigt2tensor3d">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.voigt2tensor3d.html#pwtools.crys.voigt2tensor3d">[docs]</a>
<span class="k">def</span> <span class="nf">voigt2tensor3d</span><span class="p">(</span><span class="n">voigt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as :func:`voigt2tensor` for trajectories.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    voigt: (nstep,6)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tensor : (nstep,3,3)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nstep</span> <span class="o">=</span> <span class="n">voigt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">voigt</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;voigt must be (nstep,6)&quot;</span>
    <span class="k">assert</span> <span class="n">voigt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;voigt must be (nstep,6)&quot;</span>
    <span class="n">tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nstep</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">voigt</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">tensor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">tensor</span></div>



<div class="viewcode-block" id="tensor2voigt3d">
<a class="viewcode-back" href="../../generated/api/pwtools.crys.tensor2voigt3d.html#pwtools.crys.tensor2voigt3d">[docs]</a>
<span class="k">def</span> <span class="nf">tensor2voigt3d</span><span class="p">(</span><span class="n">tensor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Same as :func:`tensor2voigt` for trajectories.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tensor : (nstep,3,3)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    voigt: (nstep,6)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">tensor</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;tensor must be (nstep,3,3)&quot;</span>
    <span class="k">assert</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;tensor must be (nstep,3,3)&quot;</span>
    <span class="n">nstep</span> <span class="o">=</span> <span class="n">tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">voigt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nstep</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
    <span class="n">voigt</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[:,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[:,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">voigt</span><span class="p">[:,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">tensor</span><span class="p">[:,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">voigt</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &#169;Steve Schmerler.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>